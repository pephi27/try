
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PayrollPro</title>

  <!-- Performance: preconnect to critical origins and modulepreload -->
  <link rel="preconnect" href="https://qzkzugzfpegozpiqutdv.supabase.co" crossorigin>
  <link rel="dns-prefetch" href="//qzkzugzfpegozpiqutdv.supabase.co">
  <link rel="preconnect" href="https://esm.sh" crossorigin>
  <link rel="dns-prefetch" href="//esm.sh">
  <link rel="modulepreload" href="https://esm.sh/@supabase/supabase-js@2?bundle" crossorigin>

  <script type="module">
    // Non-invasive performance tweaks: lazy-load offscreen media, async decode images.
    const onReady = (cb) => {
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', cb, { once: true });
      else cb();
    };
    onReady(() => {
      try {
        const vh = window.innerHeight || document.documentElement.clientHeight || 800;
        document.querySelectorAll('img').forEach(img => {
          try { if (!img.hasAttribute('decoding')) img.setAttribute('decoding', 'async'); } catch {}
          if (!img.hasAttribute('loading')) {
            const rect = img.getBoundingClientRect();
            if (rect && rect.top > vh) { try { img.setAttribute('loading', 'lazy'); } catch {} }
          }
        });
        document.querySelectorAll('iframe').forEach(el => {
          if (!el.hasAttribute('loading')) { try { el.setAttribute('loading', 'lazy'); } catch {} }
        });
      } catch { /* no-op */ }
    });
  </script>

<!-- === Supabase KV Sync Adapter (no-login, auto-sync) === -->
<script>
  // Global KV helpers for classic scripts; Supabase-aware if available.
  (function () {
    if (!window.readKV) {
      window.readKV = async function readKV(key, defaultValue = null) {
        try {
          if (window.supabase && window.SUPABASE_TABLE) {
            const { data, error } = await window.supabase
              .from(window.SUPABASE_TABLE)
              .select('value')
              .eq('key', key)
              .single();
            if (error || !data) return defaultValue;
            return (data.value ?? defaultValue);
          } else {
            const raw = localStorage.getItem(key);
            if (raw === null) return defaultValue;
            try { return JSON.parse(raw); } catch { return raw; }
          }
        } catch (e) {
          console.warn('readKV failed', e);
          return defaultValue;
        }
      };
    }
    if (!window.writeKV) {
      window.writeKV = async function writeKV(key, value) {
        try {
          if (window.supabase && window.SUPABASE_TABLE) {
            const { error } = await window.supabase
              .from(window.SUPABASE_TABLE)
              .upsert({ key, value }, { onConflict: 'key' });
            try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
            if (error) console.warn('writeKV error', error);
          } else {
            try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
          }
          return true;
        } catch (e) {
          console.warn('writeKV failed', e);
          try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
          return false;
        }
      };
    }
  })();
</script>
<script type="module">
// Minimal, no-login cloud persistence by mirroring localStorage to Supabase.
// 1) Create a table in Supabase named: kv_store
//    Columns:
//      key text PRIMARY KEY
//      value jsonb
//      updated_at timestamptz DEFAULT now()
// 2) Turn RLS ON and add permissive policies if you truly want no-login use:
//    - SELECT: USING (true)
//    - INSERT: WITH CHECK (true)
//    - UPDATE: USING (true)  WITH CHECK (true)   // optional; you can omit to prevent edits
//    - DELETE: USING (false)                      // optional; disallow deletes
// 3) Paste your Supabase project URL and anon key below.

import { createClient } from "https://esm.sh/@supabase/supabase-js@2?bundle"

const SUPABASE_URL = window.SUPABASE_URL || "https://qzkzugzfpegozpiqutdv.supabase.co"
const SUPABASE_KEY = window.SUPABASE_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6a3p1Z3pmcGVnb3pwaXF1dGR2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4MTc5MDMsImV4cCI6MjA3MTM5MzkwM30.mdFYuFjbRfsILWPkQQmVUCDR7dGqEo-mdPZ6iwolvGk"
const TABLE = "kv_store"
// List of localStorage keys that should be mirrored to Supabase.  If you add
// new keys anywhere in the application that you want to persist across
// devices, add them here as well.  Without inclusion in this list the
// `Storage.prototype.setItem` hook will ignore them and they will remain
// strictly deviceâ€‘local.
const KNOWN_KEYS = [
  "att_employees_v2",
  "att_schedules_v2",
  "att_schedules_default",
  "att_projects_v1",
  "att_filter_project_v1",
  "att_overrides_schedules",
  "att_overrides_projects",
  "att_splits_v1",
  // payroll configuration keys
  "payroll_rates",
  "payroll_reg_hours",
  "payroll_ot_hours",
  "payroll_ot_multiplier",
  "payroll_week_start",
  "payroll_week_end",
  "payroll_deduction_divisor",
  "payroll_sss_table",
  "payroll_loan_sss",
  "payroll_loan_pagibig",
  "payroll_vale",
  "payroll_vale_wed",
  "payroll_hist",
  // additional filter & state keys not previously persisted
  "dtr_filter_from",
  "dtr_filter_to",
  "payroll_active_index"
  ,"payroll_adjustments"
  ,"payroll_pagibig_rate"
  ,"payroll_philhealth_rate"
  ,"payroll_pagibig_table"
  ,"payroll_philhealth_table"
  ,"payroll_adjustment_hours"
  ,"payroll_bantay"
  ,"payroll_bantay_proj"
  ,"payroll_contrib_flags"
  ,"att_overrides_hours_v1"
]

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

// Expose the Supabase client on the global window so that other
// nonâ€‘module scripts (e.g. the boot guard) can access it without
// reâ€‘importing the library.  Also expose the table name used for
// key/value storage.  Without this, any attempt to read from
// Supabase outside of this module would require a duplicate client
// instantiation, and due to the asynchronous execution order of
// module scripts it is not guaranteed that the client would be
// available when the boot guard runs.  Assigning to `window`
// provides a simple, predictable global reference.
window.supabase = supabase;
window.SUPABASE_TABLE = TABLE;
// === Supabase KV helpers (no localStorage) ===
async function readKV(key){
  try{
    const { data, error } = await window.supabase
      .from(window.SUPABASE_TABLE)
      .select('value')
      .eq('key', key)
      .single();
    if (error || !data) return null;
    return data.value;
  }catch(e){ console.warn('readKV failed', e); return null; }
}
async function writeKV(key, value){
  try{
    await window.supabase
      .from(window.SUPABASE_TABLE)
      .upsert({ key, value });
  }catch(e){ console.warn('writeKV failed', e); }
}


const __origSetItem = Storage.prototype.setItem
const __origRemoveItem = Storage.prototype.removeItem

async function cloudUpsert(key, value) {
  try {
    // Try upsert
    const { error } = await supabase
      .from(TABLE)
      .upsert({ key, value: tryParse(value) }, { onConflict: "key" })
    if (error) console.warn("Supabase upsert error:", error.message)
  } catch (e) { console.warn("Supabase upsert failed", e) }
}
async function cloudDelete(key) {
  try {
    const { error } = await supabase.from(TABLE).delete().eq("key", key)
    if (error) console.warn("Supabase delete error:", error.message)
  } catch (e) { console.warn("Supabase delete failed", e) }
}
function tryParse(v) {
  try { return JSON.parse(v) } catch { return v }
}

// Write-through on any localStorage change
Storage.prototype.setItem = function(k, v) {
  try { __origSetItem.call(this, k, v) } catch {}
  // Only mirror known keys to reduce noise
  if (KNOWN_KEYS.includes(k)) cloudUpsert(k, v)
}
Storage.prototype.removeItem = function(k) {
  try { __origRemoveItem.call(this, k) } catch {}
  if (KNOWN_KEYS.includes(k)) cloudDelete(k)
}

// On first load, pull from cloud and hydrate localStorage automatically.
// If we detect changes vs. current localStorage, we populate and reload once
// so the rest of the app sees the new data without manual "sync".
;(async function initialHydrate(){
  try {
    const { data, error } = await supabase
      .from(TABLE)
      .select("key, value")
      .in("key", KNOWN_KEYS)
    if (error) { console.warn("Supabase fetch error:", error.message); return }
    let changed = false
    for (const row of (data || [])) {
      const k = row.key
      const cloudStr = safeStringify(row.value)
      const cur = localStorage.getItem(k)
      // Conflict resolution: if both sides look like period-scoped maps
      // and have __meta.lastUpdatedAt, prefer the newer side.
      let preferLocal = false
      try {
        const cloudObj = (row && typeof row.value === 'object') ? row.value : JSON.parse(cloudStr || 'null')
        const localObj = cur ? JSON.parse(cur) : null
        const lc = localObj && localObj.__meta && Number(localObj.__meta.lastUpdatedAt)
        const rc = cloudObj && cloudObj.__meta && Number(cloudObj.__meta.lastUpdatedAt)
        if (lc && rc && lc > rc) preferLocal = true
      } catch(_) {}
      if (preferLocal) {
        try { await supabase.from(TABLE).upsert({ key: k, value: JSON.parse(cur) }, { onConflict: 'key' }) } catch(_){ }
        continue
      }
      if (cloudStr != null && cloudStr !== cur) {
        try { __origSetItem.call(localStorage, k, cloudStr) } catch {}
        changed = true
      }
    }
    if (changed) {
      // Avoid reload: signal hydration complete and re-render once safely.
      try { sessionStorage.removeItem("__kv_reloaded"); } catch {}
      try { window.__kv_hydrated = true; } catch {}
      try { window.dispatchEvent(new Event('kv-hydrated')); } catch {}
      const rerender = () => {
        try { if (typeof window.calculateAll === 'function') window.calculateAll(); } catch {}
        try { if (typeof window.renderResults === 'function') window.renderResults(); } catch {}
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => { setTimeout(rerender, 0); }, { once: true });
      } else {
        setTimeout(rerender, 0);
      }
    }
  } catch (e) { console.warn("Initial hydrate failed", e) }
})()

function safeStringify(v){
  try { return typeof v === "string" ? v : JSON.stringify(v) } catch { return null }
}
</script>

<!-- Style to visually and functionally lock panels when payroll data is locked.
     When #panelMain has the 'locked' class, pointer events are disabled on
     all of its children and the panel appears dimmed. This prevents any
     interaction with DTR fields while still allowing navigation to other tabs. -->
<style>
  #panelMain.locked {
    pointer-events: none;
    opacity: 0.6;
  }

/* === PATCH: Adjustments & Bantay column widths === */
#payrollTable th:nth-child(10), #payrollTable td:nth-child(10) { width: 100px; min-width: 100px; } /* Adjustments */
#payrollTable th:nth-child(11), #payrollTable td:nth-child(11) { width: 100px; min-width: 100px; } /* Bantay */
/* === END PATCH === */

/* === PERF: faster layout for payroll table === */
#payrollTable { table-layout: fixed; }
#payrollTable th, #payrollTable td { white-space: nowrap; }


/* === Reports: Stabilize last 4 totals columns to prevent twitch === */
#r_table, #projectTotalsTable { table-layout: fixed; }
#r_table th:nth-last-child(4), #r_table td:nth-last-child(4),
#projectTotalsTable th:nth-last-child(4), #projectTotalsTable td:nth-last-child(4) { width: 100px; min-width: 100px; max-width: 110px; }
#r_table th:nth-last-child(3), #r_table td:nth-last-child(3),
#projectTotalsTable th:nth-last-child(3), #projectTotalsTable td:nth-last-child(3) { width: 100px; min-width: 100px; max-width: 110px; }
#r_table th:nth-last-child(2), #r_table td:nth-last-child(2),
#projectTotalsTable th:nth-last-child(2), #projectTotalsTable td:nth-last-child(2) { width: 120px; min-width: 120px; max-width: 140px; }
#r_table th:nth-last-child(1), #r_table td:nth-last-child(1),
#projectTotalsTable th:nth-last-child(1), #projectTotalsTable td:nth-last-child(1) { width: 110px; min-width: 110px; max-width: 120px; }
/* Make first (personnel) column robust but constrained */
#r_table th:first-child, #r_table td:first-child,
#projectTotalsTable th:first-child, #projectTotalsTable td:first-child {
  text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  width: 170px; min-width: 170px; max-width: 170px;
}

/* Manual DTR indicator */
#resultsTable .manual-indicator { color: #ef4444; margin-left: 4px; font-weight: 700; }

</style>
<!-- === / Supabase KV Sync Adapter === -->

<!-- Multi payslip printing functionality -->

<script>
// Safe print helper to avoid uncaught errors like
// "Failed to execute 'print' on 'Window': The provided callback is no longer runnable."
function safePrint(win){
  try { (win || window).print(); } catch(e){ console.warn('print failed', e); }
}
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var multiBtn = document.getElementById('printAllPayslipsBtn');
  if (!multiBtn) return;
  multiBtn.addEventListener('click', function() {
    var rows = document.querySelectorAll('#payrollTable tbody tr');
    if (!rows || rows.length === 0) return;
    var wsEl = document.getElementById('weekStart');
    var weEl = document.getElementById('weekEnd');
    var ws = wsEl ? (wsEl.value || '') : '';
    var we = weEl ? (weEl.value || '') : '';
    function gv(row, sel, prop) {
      var el = row.querySelector(sel);
      if (!el) return '';
      if (prop === 'value') return (el.value || '');
      return (el.textContent || '');
    }
    function d(x){
      var n = parseFloat((x||'').toString().replace(/,/g,''));
      return (!isNaN(n) && n === 0) ? '-' : (x||'');
    }
    function toNum(x){ var n = parseFloat(String(x||'').replace(/,/g,'')); return isNaN(n) ? 0 : n; }
    function fmt(x){ var n = toNum(x); return n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }
    var html = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>All Payslips</title>
<style>
@page { size: letter portrait; margin: 0.25in; }
html, body { width: 8.5in; height: 11in; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
body{font-family:Arial,Helvetica,sans-serif;margin:0;padding:0 0.1in;}
/* 12 per page: 3 columns x 4 rows, compact spacing */
.payslip-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:0.03in;}
.payslip{box-sizing:border-box;padding:0.06in;border:1px solid #e2e8f0;height:2.6in;overflow:hidden;border-radius:3px;background:#fff;}
table{border-collapse:collapse;width:100%;font-size:8.5px;}
th,td{border:1px solid #e2e8f0;padding:1px;text-align:left;}
th{background:#f1f5f9;}
.page-break{page-break-after:always;break-after:page;}
h3{margin:0 0 3px 0;font-size:10px;}
.payslip .meta{margin:0 0 2px 0;font-size:8px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
</style></head><body><div class="payslip-grid">`;
    rows.forEach(function(row, idx){
      var id = (row.cells[0]?.textContent || '').trim();
      var name = (row.cells[1]?.textContent || '').trim();
      var reg = gv(row, '.regHrs','value');
      var ot = gv(row, '.otHrs','value');
      var adjHrsTxt = gv(row, '.adjHrs','textContent');
      var totHrs = gv(row, '.totalHrs','textContent');
      var rate = gv(row, '.rate','value');
      var regPay = gv(row, '.regPay','textContent');
      var otPay = gv(row, '.otPay','textContent');
      var gross = gv(row, '.grossPay','textContent');
      var pagibig = gv(row, '.pagibig','textContent');
      var philhealth = gv(row, '.philhealth','textContent');
      var sss = gv(row, '.sss','textContent');
      var sssLoan = gv(row, '.loanSSS','value');
      var piLoan = gv(row, '.loanPI','value');
      var v = gv(row, '.vale','value');
      var vW = gv(row, '.valeWed','value') || gv(row, '.valeWed','textContent');
      var bantay = gv(row, '.bantay','value');
      var adj = gv(row, '.adjAmt','textContent');
      var total = gv(row, '.totalDed','textContent');
      var net = gv(row, '.netPay','textContent');
      // Fallback compute for total hours if cell not available
      if (!totHrs) {
        var r = parseFloat((reg||'').toString().replace(/,/g,''))||0;
        var o = parseFloat((ot||'').toString().replace(/,/g,''))||0;
        var ah = parseFloat((adjHrsTxt||'').toString().replace(/,/g,''))||0;
        totHrs = (r + o + ah).toFixed(2);
      }
      // Build deductions rows only when values are present (> 0)
      var dedRows = '';
      function addDed(label, val){ if (toNum(val) > 0) { dedRows += `<tr><td>${label}</td><td>${fmt(val)}</td></tr>`; } }
      addDed('Pag-IBIG', pagibig);
      addDed('PhilHealth', philhealth);
      addDed('SSS', sss);
      addDed('SSS Loan', sssLoan);
      addDed('Pag-IBIG Loan', piLoan);
      addDed('Account', v);
      addDed('Wed Vale', vW);

      html += `<div class="payslip">
        <h3>Payslip</h3>
        <p class="meta"><strong>Employee ID:</strong> ${id}</p>
        <p class="meta"><strong>Name:</strong> ${name}</p>
        <p class="meta"><strong>Period:</strong> ${ws}${we ? (' to ' + we) : ''}</p>
        <table>
          <tr><th>Description</th><th>Amount</th></tr>
          <tr><td>Total Hours</td><td>${d(totHrs)}</td></tr>
          ${toNum(bantay)!==0 ? `<tr><td>Bantay</td><td>${fmt(bantay)}</td></tr>` : ''}
          ${toNum(adj)!==0 ? `<tr><td>Adjustments</td><td>${fmt(adj)}</td></tr>` : ''}
          <tr><td>Gross Amount</td><td>${d(gross)}</td></tr>
          ${dedRows}
          ${toNum(total)>0 ? `<tr><td>Total Deductions</td><td>${fmt(total)}</td></tr>` : ''}
          <tr><th>Net Pay</th><th>${d(net)}</th></tr>
        </table>
      </div>`;
      if ((idx + 1) % 12 === 0 && idx !== rows.length - 1) {
        html += `</div><div class="page-break"></div><div class="payslip-grid">`;
      }
    });
    html += `</div></body></html>`;
    var w = window.open('', '', 'width=800,height=900');
    if (!w) return;
    w.document.open(); w.document.write(html); w.document.close();
    w.focus(); setTimeout(function(){ try { safePrint(w); } catch(e){} }, 0);
  });
});
</script>


<script>
// === PATCH v15: Strong zero formatting in Reports/Payroll tab ===
(function(){
  function zeroToDashInTable(){
    try{
      const tbl = document.getElementById('payrollTable');
      if(!tbl || !tbl.tBodies || !tbl.tBodies[0]) return;
      const tbody = tbl.tBodies[0];
      // Inputs: blank zeros only for the three computed fields
      tbody.querySelectorAll('input.regHrs, input.otHrs, input.rate').forEach(inp=>{
        const v = parseFloat((inp.value||'').toString().replace(/,/g,''));
        if(!isNaN(v) && v===0){ inp.value = ''; }
      });
      // Text cells: convert 0/0.00 to '-' (only numeric cells)
      Array.from(tbody.querySelectorAll('td.num')).forEach(td=>{
        if(td.querySelector('input')) return; // inputs handled above
        const raw = (td.textContent||'').replace(/,/g,'').trim();
        if(raw==='') return;
        const n = parseFloat(raw);
        if(!isNaN(n) && isFinite(n) && n===0){
          td.textContent = '-';
        }
      });
      // Footer totals too
      if(tbl.tFoot){
        Array.from(tbl.tFoot.querySelectorAll('td')).forEach(td=>{
          const raw = (td.textContent||'').replace(/,/g,'').trim();
          if(!raw) return;
          const n = parseFloat(raw);
          if(!isNaN(n) && n===0){ td.textContent = '-'; }
        });
      }
    }catch(e){ /* no-op */ }
  }

  // Debounced wrapper
  let __zTimer=null;
  function applyZeroSoon(){
    clearTimeout(__zTimer);
    __zTimer = setTimeout(zeroToDashInTable, 0);
  }

  // Hook common renderers (if defined later too)
  ['calculateAll','renderTable','renderDeductionsTable','renderReportTable'].forEach(fn=>{
    const hook = ()=>{
      const orig = window[fn];
      if(typeof orig==='function' && !orig.__zeroWrapped){
        window[fn] = function(){
          const out = orig.apply(this, arguments);
          applyZeroSoon();
          return out;
        };
        window[fn].__zeroWrapped = true;
      }
    };
    hook();
    document.addEventListener('readystatechange', hook);
    window.addEventListener('load', hook);
    setTimeout(hook, 0);
  });

  // Observe tbody for DOM changes
  const startObserver = ()=>{
    const tbl = document.getElementById('payrollTable');
    if(tbl && tbl.tBodies && tbl.tBodies[0]){
      // observer removed for perf
applyZeroSoon();
    }
  };
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', startObserver);
  }else{
    startObserver();
  }

  // Periodic fallback (lightweight) in case rendering bypasses hooks
})();
// === END PATCH v15 ===
</script>


<script>
(function(){
  function zeroBlankInputs(){
    try{
    document.querySelectorAll('#payrollTable input.regHrs, #payrollTable input.otHrs, #payrollTable input.rate').forEach(function(inp){
        var v = parseFloat((inp.value||'').toString().replace(/,/g,''));
        if(!isNaN(v) && v===0){ inp.value = ''; }
      });
    }catch(e){}
  }
  function hideThenFormat(run){
    var tbl = document.getElementById('payrollTable');
    var prevVis = tbl ? tbl.style.visibility : null;
    if (tbl) tbl.style.visibility = 'hidden';
    var out;
    try { out = run(); } catch(e){ out = undefined; }
    try { zeroBlankInputs(); } catch(e){}
    if (tbl) tbl.style.visibility = (prevVis==null? '' : prevVis);
    return out;
  }
  ['renderTable','calculateAll'].forEach(function(fn){
    var orig = window[fn];
    if (typeof orig === 'function' && !orig.__noflash){
      window[fn] = function(){ return hideThenFormat(function(){ return orig.apply(this, arguments); }); };
      window[fn].__noflash = true;
    }
  });
})();
</script>


<script>
(function(){
  function dashReports(){ try { if (typeof applyCommas === 'function') applyCommas(); } catch(e){} }
  const panel = document.getElementById('panelReports') || document.body;
  // observer removed for perf
window.addEventListener('load', dashReports);
})();
</script>



  <meta charset="utf-8"/>
  <title>
   Attendance &mdash; Schedules + Ranges (Merged) + Projects
  </title>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <style>
  /*
   * Allow the application to consume the full viewport width so wide tables (like
   * the DTR grid) are not artificially constrained. The original max-width of
   * 1200px caused wide tables to be clipped on larger screens and hid
   * additional columns. Removing the fixed max-width lets the container grow
   * with the window size, and combined with overflow handling on the panel
   * ensures that all columns remain accessible via horizontal scrolling when
   * necessary.
   */
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;max-width:100%;color:#0b1220}
  header{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab-btn{padding:8px 12px;cursor:pointer;border:1px solid #cbd5e1;background:#f8fafc;border-radius:6px}
  .tab-btn.active{background:#0ea5a4;color:#fff}
  section.panel{display:none}
  section.panel.active{display:block;padding-top:8px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  input[type=file],input[type=date],input[type=time],input[type=number],button,select{padding:6px 8px}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:center;font-size:13px}
  th{background:#f1f5f9;position:sticky;top:0;z-index:1}
  .missing{background:#ffdede;color:#7a0000;font-weight:700}
  .note{color:#64748b;font-size:13px;margin-top:6px}
  input.cell{width:100%;box-sizing:border-box}
  .small{font-size:12px;color:#64748b}
  .muted{color:#64748b;font-size:12px}
  @media (max-width:800px){th,td{font-size:12px}}
  .section-title{margin-top:12px;margin-bottom:4px;font-weight:700}
  /* Ensure DTR table columns stay visible and don't collapse in Chrome. Allow
     horizontal scrolling if needed by preventing cells from shrinking and
     wrapping. */
  #panelMain {
    overflow-x: auto;
  }
  #panelMain #resultsTable {
    /*
     * Use max-content so the table grows to accommodate all of its columns.
     * This prevents Chrome from collapsing column widths to fit a parent with
     * limited width and ensures that long headers (e.g. "Clock Out 4",
     * "Night Differential") do not disappear. When combined with the
     * overflow-x:auto on #panelMain, a horizontal scrollbar will appear
     * whenever the total table width exceeds the viewport, allowing users to
     * scroll horizontally to view hidden columns.
     */
    table-layout: auto;
    width: max-content;
  }
  #panelMain #resultsTable th,
  #panelMain #resultsTable td {
    white-space: nowrap;
  }

  /* Make the wrapper around the DTR results scrollable on the x-axis. Without
     this wrapper, wide tables can be clipped by parent containers with
     overflow hidden. */
  .results-wrapper {
    overflow-x: auto;
  }
  </style>
  <style>

  /* Hide individual deduction columns in Payroll table (show only Total Deductions).
     After adding the Adjustment column before Bantay, the indices shift by one.
     Hide Pag‑IBIG to Wed Vale columns (cols 13–19) for thead and tbody.
     The tfoot row has a collapsed first cell; hide cols 12–18 instead. */
  #payrollTab #payrollTable thead th:nth-child(13),
  #payrollTab #payrollTable tbody td:nth-child(13),
  #payrollTab #payrollTable thead th:nth-child(14),
  #payrollTab #payrollTable tbody td:nth-child(14),
  #payrollTab #payrollTable thead th:nth-child(15),
  #payrollTab #payrollTable tbody td:nth-child(15),
  #payrollTab #payrollTable thead th:nth-child(16),
  #payrollTab #payrollTable tbody td:nth-child(16),
  #payrollTab #payrollTable thead th:nth-child(17),
  #payrollTab #payrollTable tbody td:nth-child(17),
  #payrollTab #payrollTable thead th:nth-child(18),
  #payrollTab #payrollTable tbody td:nth-child(18),
  #payrollTab #payrollTable thead th:nth-child(19),
  #payrollTab #payrollTable tbody td:nth-child(19) { display: none; }
  #payrollTab #payrollTable tfoot td:nth-child(12),
  #payrollTab #payrollTable tfoot td:nth-child(13),
  #payrollTab #payrollTable tfoot td:nth-child(14),
  #payrollTab #payrollTable tfoot td:nth-child(15),
  #payrollTab #payrollTable tfoot td:nth-child(16),
  #payrollTab #payrollTable tfoot td:nth-child(17),
  #payrollTab #payrollTable tfoot td:nth-child(18) { display: none; }
/* === PATCH: column widths for Hourly Rate, Regular Hours, OT Hours === */
#payrollTable th, #payrollTable td { white-space: nowrap; }
#payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width: 110px; min-width: 110px; } /* Hourly Rate */
#payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width: 120px; min-width: 120px; } /* Regular Hours */
#payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width: 120px; min-width: 120px; } /* OT Hours */
/* keep inputs filling their cells cleanly */
#payrollTable td input.cell { width: 100%; box-sizing: border-box; }
/* === END PATCH === */


  
/* ===== Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  #panelProjectTotals, #panelProjectTotals * { visibility: visible !important; }
  #panelProjectTotals { position: absolute; left: 0; top: 0; width: 100%; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}
</style>

  <style id="payrollScopedStyles">
  #panelPayroll {
    --border:#e2e8f0; --bg:#f8fafc; --bg2:#f1f5f9; --text:#0b1220;
    /* Updated accent color to gold */
    --accent:#FFD700; --muted:#64748b;
  }
  #panelPayroll *, #panelPayroll *::before, #panelPayroll *::after { box-sizing:border-box }
  #panelPayroll { color:var(--text) }
  #panelPayroll header { display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px;flex-wrap:wrap }
  #panelPayroll h2 { margin:0 }
  #panelPayroll .tabs { display:flex;gap:6px;flex-wrap:wrap }
  #panelPayroll .tab-btn { padding:8px 12px;border:1px solid var(--border);background:white;border-radius:8px;cursor:pointer }
  #panelPayroll .tab-btn.active { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll .tab { display:none }
  #panelPayroll .tab.active { display:block }
  #panelPayroll .controls { display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:10px 0 }
  #panelPayroll label { font-size:12px;color:var(--muted) }
  #panelPayroll input[type=date], 
  #panelPayroll input[type=number], 
  #panelPayroll input[type=text], 
  #panelPayroll select, 
  #panelPayroll button { padding:6px 8px;border:1px solid var(--border);border-radius:6px }
  #panelPayroll button.primary { background:var(--accent);color:white;border-color:var(--accent) }
  #panelPayroll table { border-collapse:collapse;width:100%;margin-top:12px }
  #panelPayroll th, #panelPayroll td { border:1px solid var(--border);padding:8px;text-align:center;font-size:13px }
  #panelPayroll th { background:var(--bg2);position:sticky;top:0;z-index:1 }
  #panelPayroll td.num { text-align:right }
  #panelPayroll input.cell { width:100%;padding:4px;border:1px solid var(--border);border-radius:4px;text-align:right }
/* === PATCH: make computed hours/rate look like plain text & non-interactive === */
#panelPayroll input.regHrs,
#panelPayroll input.otHrs,
#panelPayroll input.rate {
  pointer-events: none;      /* no clicks */
  border: none;              /* look like text */
  background: transparent;
  color: inherit;
  padding: 0;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: textfield;
  appearance: none;
  text-align: right;
}
#panelPayroll input.regHrs[disabled],
#panelPayroll input.otHrs[disabled],
#panelPayroll input.rate[disabled] {
  color: inherit;            /* avoid greyed-out disabled look */
}
/* hide number spinners where applicable */
#panelPayroll input.regHrs::-webkit-outer-spin-button,
#panelPayroll input.regHrs::-webkit-inner-spin-button,
#panelPayroll input.otHrs::-webkit-outer-spin-button,
#panelPayroll input.otHrs::-webkit-inner-spin-button,
#panelPayroll input.rate::-webkit-outer-spin-button,
#panelPayroll input.rate::-webkit-inner-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}
/* === END PATCH === */

  #panelPayroll .note { font-size:12px;color:var(--muted) }
  #panelPayroll .section { background:var(--bg);padding:10px;border:1px solid var(--border);border-radius:10px;margin-top:8px }
  #panelPayroll .danger { color:#b91c1c }
  #panelPayroll .wrap { white-space:normal }

  </style>
  <style id="payroll-tabs-fix">
   #panelPayroll .tab{display:none} #panelPayroll .tab.active{display:block}
  </style>
 
<style>
/* --- Employees: Clean Add Employee UI --- */
#panelEmployees .form-card{
  background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:16px;
  box-shadow:0 1px 2px rgba(0,0,0,0.04);margin-bottom:12px;
}
#panelEmployees form{
  display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;align-items:start;
}
#panelEmployees label{display:block;font-size:12px;color:#334155;margin-bottom:6px;font-weight:600;}
#panelEmployees input, #panelEmployees select, #panelEmployees textarea{
  width:100%;padding:10px 12px;border:1px solid #cbd5e1;border-radius:10px;outline:none;
}
#panelEmployees input:focus, #panelEmployees select:focus, #panelEmployees textarea:focus{
  border-color:#64748b;box-shadow:0 0 0 3px rgba(100,116,139,0.15);
}
#panelEmployees input:invalid, #panelEmployees select:invalid, #panelEmployees textarea:invalid{
  border-color:#ef4444;
}
#panelEmployees .form-actions{grid-column:1 / -1;display:flex;gap:10px;justify-content:flex-end;margin-top:2px;}
#panelEmployees button, #panelEmployees input[type="submit"], #panelEmployees input[type="button"]{
  border:1px solid #cbd5e1;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;background:#f8fafc;
}
#panelEmployees button:hover, #panelEmployees input[type="submit"]:hover, #panelEmployees input[type="button"]:hover{
  filter:brightness(0.98);
}
#panelEmployees .btn-primary{background:#0ea5e9;border-color:#0284c7;color:#fff;}
#panelEmployees .btn-danger{background:#fee2e2;border-color:#fecaca;color:#b91c1c;}
#panelEmployees small.hint{display:block;color:#64748b;margin-top:4px;font-size:11px;}
@media (max-width:1100px){
  #panelEmployees form{grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
}
</style>

<style>

/* ===== Strong Print Styles for Project Totals ===== */
@media print {
  body * { visibility: hidden !important; }
  section.panel { display: none !important; }
  #panelProjectTotals { 
    position: absolute; left: 0; top: 0; width: 100%;
    display: block !important; 
    visibility: visible !important;
  }
  #panelProjectTotals * { visibility: visible !important; }
  header, .tabs, .controls, #panelProjectTotals .controls, #panelProjectTotals button { display: none !important; }
  #projectTotalsTable { width: 100%; border-collapse: collapse; font-size: 12px; }
  #projectTotalsTable th, #projectTotalsTable td { border: 1px solid #444; padding: 6px; text-align: right; }
  #projectTotalsTable th:first-child, #projectTotalsTable td:first-child { text-align: left; }
  .proj-emp-breakdown { page-break-inside: avoid; }
  .page-break { page-break-after: always; }
}

</style>

<style>

/* --- Per-project per page when printing --- */
@media print {
  /* If a project has a breakdown row, break after that row; otherwise break after the project header row */
  #panelProjectTotals tr.proj-emp-breakdown { page-break-after: always; }
  #panelProjectTotals tr.proj-row.no-breakdown { page-break-after: always; }
}

</style>

<style>
#payrollTab #payrollTable tfoot td,
#deductionsTab #deductionsTable tfoot td{ font-weight:700; background:#fff7ed; border-top:2px solid #e2e8f0; }
#payrollTab #payrollTable tfoot td.label-cell,
#deductionsTab #deductionsTable tfoot td.label-cell{ text-align:left; }
#payrollTab #payrollTable tfoot td.num,
#deductionsTab #deductionsTable tfoot td.num{ text-align:right; }
</style>
    <!-- Added payroll dashboard theme -->
    <style>
        /* Override default margins and background */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .app-container {
            display: flex;
            min-height: 100vh;
        }
        .sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            padding: 30px 0;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        .sidebar-header {
            padding: 0 30px 30px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        .logo {
            font-size: 24px;
            font-weight: 800;
            /* Updated logo color to yellow */
            color: #FFD700;
            background: none;
            -webkit-background-clip: border-box;
            background-clip: border-box;
            background-clip: border-box;
            background-clip: border-box;
            -webkit-text-fill-color: #FFD700;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .nav-menu {
            list-style: none;
            padding: 0 15px;
        }
        .nav-item {
            margin-bottom: 8px;
        }
        .nav-link {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            text-decoration: none;
            color: #6b7280;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
        }
        .nav-link:hover {
            background: #f3f4f6;
            color: #374151;
            transform: translateX(5px);
        }
        .nav-link.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        .main-content {
            flex: 1;
            margin-left: 280px;
            padding: 30px;
            /*
             * Permit horizontal scrolling within the main content area. The
             * original style hid any overflow on the x-axis, which meant
             * wide tables (such as the DTR results grid) could not be
             * scrolled into view and appeared to be missing columns. By
             * changing overflow-x to auto, the browser will show a
             * horizontal scrollbar when necessary, ensuring all columns
             * remain accessible.
             */
            overflow-x: auto;
        }
        .content-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .page-title {
            font-size: 28px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .page-subtitle {
            color: #6b7280;
            font-size: 14px;
        }
        .date-range {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        .date-input {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        .date-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .warning-note {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #92400e;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 13px;
            margin-top: 15px;
            border-left: 4px solid #f59e0b;
        }
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 999;
            }
            .sidebar.active {
                transform: translateX(0);
            }
            .main-content {
                margin-left: 0;
                padding: 80px 20px 20px;
            }
            .date-range {
                justify-content: center;
            }
        }
        /* Hide original top-level navigation tabs but keep payroll sub-tabs visible */
        .tabs { display: none !important; }
        /* Explicitly show the sub-tabs inside the Payroll panel. */
    #panelPayroll .tabs {
            display: flex !important;
        }
    </style>
    <!-- Additional styles for new header UI -->
    <style>
      body {
        background: #f8f8f8;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: linear-gradient(135deg, #000 0%, #333 100%);
        color: white;
        padding: 10px 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
      }
      .header .logo {
        font-size: 24px;
        font-weight: 800;
        color: #FFD700;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .header .nav-menu {
        list-style: none;
        display: flex;
        gap: 20px;
        margin: 0;
        padding: 0;
        align-items: center;
      }
      .header .nav-menu .nav-item .nav-link {
        border: none;
        background: none;
        color: white;
        font-weight: 600;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 8px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .header .nav-menu .nav-item .nav-link:hover {
        background-color: #FFD700;
        color: #000;
      }
      .header .nav-menu .nav-item .nav-link.active {
        background-color: #FFD700;
        color: #000;
      }
      .sidebar {
        display: none !important;
      }
      .mobile-menu-btn {
        display: none !important;
      }
      .main-content {
        margin-left: 0 !important;
        padding-top: 90px;
      }
</style>
</head>

<!-- UI fixes: restore emojis and icons if text got corrupted by encoding -->
<style>
  /* Replace corrupted nav icon text with emojis */
  .header .nav-icon { font-size: 0; line-height: 1; }
  #tabDashboard .nav-icon::before { content: "📊"; font-size: 14px; }
  #tabMain .nav-icon::before      { content: "🕒"; font-size: 14px; }
  #tabSchedule .nav-icon::before  { content: "🗓️"; font-size: 14px; }
  #tabEmployees .nav-icon::before { content: "👥"; font-size: 14px; }
  #tabProjects .nav-icon::before  { content: "🚀"; font-size: 14px; }
  #tabPayroll .nav-icon::before   { content: "💰"; font-size: 14px; }
  #tabProjectTotals .nav-icon::before { content: "📈"; font-size: 14px; }
  /* Sidebar duplicates */
  #old-tabDashboard .nav-icon::before { content: "📊"; }
  #old-tabMain .nav-icon::before      { content: "🕒"; }
  #old-tabSchedule .nav-icon::before  { content: "🗓️"; }
  #old-tabEmployees .nav-icon::before { content: "👥"; }
  #old-tabProjects .nav-icon::before  { content: "🚀"; }
  #old-tabPayroll .nav-icon::before   { content: "💰"; }
  #old-tabProjectTotals .nav-icon::before { content: "📈"; }

  /* Mobile menu icon */
  .mobile-menu-btn span { font-size: 0; }
  .mobile-menu-btn span::before { content: "☰"; font-size: 20px; }

  /* Sidebar logo: render clean text */
  .sidebar .logo { font-size: 0; }
  .sidebar .logo::before { content: "💰 PayrollHub"; font-size: 24px; }

  /* Page title icon */
  .page-title > span:first-child { font-size: 0; } .page-title > span:first-child::before { content: "📊"; font-size: 32px; } .page-title > span.icon-emoji { font-size: 32px !important; } .page-title > span.icon-emoji::before { content: none !important; }

  /* Warning note text */
  .warning-note { font-size: 0; }
  .warning-note::before { content: "⚠️ Data persisted in browser (localStorage). Use Clear to remove."; font-size: 14px; }
</style>

<!-- Boot guard to ensure global stored data is available early -->
<script>
/*
  Immediately initialize global data stores used throughout the app.
  In addition to reading from localStorage, this version attempts to
  fetch persisted values from Supabase.  Because the Supabase
  client is exposed on `window.supabase` by the kv sync adapter,
  we can asynchronously query the kv_store table for each known
  key.  If a value exists in Supabase, it takes precedence over
  localStorage; otherwise, the localStorage fallback is used.  This
  ensures that data entered on one device is available on other
  devices without relying on cached local storage.
*/
(function(){
  // Helper to fetch a single key from Supabase.  Returns a Promise
  // that resolves to the parsed JSON value or undefined on error.
  function fetchFromSupabase(key){
    return new Promise((resolve) => {
      try {
        const client = window.supabase;
        const table = window.SUPABASE_TABLE;
        if (!client || !table) return resolve(undefined);
        client
          .from(table)
          .select('value')
          .eq('key', key)
          .single()
          .then(({ data, error }) => {
            if (error || !data) return resolve(undefined);
            const v = data.value;
            if (v == null) return resolve(undefined);
            // If the stored value is a string, assume it is JSON and parse
            if (typeof v === 'string') {
              try { return resolve(JSON.parse(v)); } catch { return resolve(undefined); }
            }
            // Otherwise return the JSON value directly
            return resolve(v);
          })
          .catch(() => resolve(undefined));
      } catch (ex) {
        resolve(undefined);
      }
    });
  }
  (async function(){
    try {
      // Employees store (att_employees_v2)
      if (typeof window.storedEmployees === 'undefined') {
        const supaVal = await fetchFromSupabase('att_employees_v2');
        if (supaVal !== undefined) {
          window.storedEmployees = supaVal;
        } else {
          // fallback to localStorage
          window.storedEmployees = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
        }
      }
      // Attendance records store (att_records_v2)
      if (typeof window.storedRecords === 'undefined') {
        /*
         * Always initialize the attendance record array as empty.  Unlike other
         * data stores, DTR records are persisted in a dedicated Supabase table
         * (`dtr_records`) and should not be bootstrapped from localStorage.  By
         * starting with an empty array here, the application ensures that any
         * locally cached data is ignored until the remote dataset is loaded.
         */
        window.storedRecords = window.storedRecords || []; }
      // Projects store (att_projects_v1)
      if (typeof window.storedProjects === 'undefined') {
        const supaVal = await fetchFromSupabase('att_projects_v1');
        if (supaVal !== undefined) {
          window.storedProjects = supaVal;
        } else {
          window.storedProjects = JSON.parse(localStorage.getItem('att_projects_v1') || '{}');
        }
      }
      // Schedules store (att_schedules_v2) â€“ ensures schedules are available early
      if (typeof window.storedSchedules === 'undefined') {
        const supaVal = await fetchFromSupabase('att_schedules_v2');
        if (supaVal !== undefined) {
          window.storedSchedules = supaVal;
        } else {
          window.storedSchedules = JSON.parse(localStorage.getItem('att_schedules_v2') || '{}');
        }
      }
    } catch (e) {
      console.warn('Boot guard init failed', e);
    }
  })();
})();
</script>

  <!-- Mobile menu button for smaller screens -->
  <button class="mobile-menu-btn" onclick="toggleSidebar()">
    <span style="font-size: 20px;">â˜°</span>
  </button>
  <!-- Begin App Container with Sidebar and Main Content -->
  <div class="app-container">
      <!-- Added top navigation header to adapt payroll UI -->
      <header class="header">
        <div class="header-content">
          <div class="logo">PayrollPro</div>
          <nav>
            <ul class="nav-menu">
              <li class="nav-item"><button class="nav-link tab-btn active" id="tabDashboard" data-page="dashboard"><span class="nav-icon">ðŸ“Š</span> Dashboard</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabMain" data-page="dtr"><span class="nav-icon">ðŸ•</span> DTR</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabSchedule" data-page="schedules"><span class="nav-icon">ðŸ“…</span> Schedules</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabEmployees" data-page="employees"><span class="nav-icon">ðŸ‘¥</span> Employees</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjects" data-page="projects"><span class="nav-icon">ðŸš€</span> Projects</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabPayroll" data-page="payroll"><span class="nav-icon">ðŸ’°</span> Payroll</button></li>
              <li class="nav-item"><button class="nav-link tab-btn" id="tabProjectTotals" data-page="totals"><span class="nav-icon">ðŸ“ˆ</span> Reports</button></li>
            </ul>
          </nav>
        </div>
      </header>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          ðŸ’¼ PayrollHub
        </div>
      </div>
      <nav>
        <ul class="nav-menu">
          <li class="nav-item">
            <button class="nav-link tab-btn active" id="old-tabDashboard" data-page="dashboard">
              <span class="nav-icon">ðŸ“Š</span>
              Dashboard
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabMain" data-page="dtr">
              <span class="nav-icon">ðŸ•</span>
              DTR
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabSchedule" data-page="schedules">
              <span class="nav-icon">ðŸ“…</span>
              Schedules
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabEmployees" data-page="employees">
              <span class="nav-icon">ðŸ‘¥</span>
              Employees
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjects" data-page="projects">
              <span class="nav-icon">ðŸš€</span>
              Projects
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabPayroll" data-page="payroll">
              <span class="nav-icon">ðŸ’°</span>
              Payroll
            </button>
          </li>
          <li class="nav-item">
            <button class="nav-link tab-btn" id="old-tabProjectTotals" data-page="totals">
              <span class="nav-icon">ðŸ“ˆ</span>
              Reports
            </button>
          </li>
        </ul>
      </nav>
    </aside>
    <main class="main-content">
      <div class="content-header">
        <h1 class="page-title">
          <span style="font-size: 32px;">ðŸ“Š</span>
          Dashboard
        </h1>
        <p class="page-subtitle">Manage your payroll system efficiently</p>
        <!-- Hide the legacy date range controls but keep them in the DOM for backwards compatibility -->
        <div class="date-range" id="dateRangeLegacy" style="display:none">
          <span style="font-weight: 600; color: #374151;">Start:</span>
          <input id="weekStart" type="date" class="date-input">
          <span style="font-weight: 600; color: #374151;">End:</span>
          <input id="weekEnd" type="date" class="date-input">
          <button id="dashGenerate" style="margin-left: 8px;">Generate</button>
        </div>
        <!-- New Active Payroll picker -->
        <div class="date-range" id="activePayrollPicker" style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
          <span style="font-weight:600;color:#374151;">Payroll period:</span>
          <select id="activePayrollSelect" class="date-input activeWeekSelect" style="min-width:260px;"></select>
          <button id="newPayrollPeriod" type="button" class="date-input">New period</button>
        </div>
        <!-- New Period Modal (pre-rendered for instant open) -->
        <style>
          /* Modal overlay */
          #newPeriodModal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);z-index:2000;align-items:center;justify-content:center}
          /* Modal card */
          #newPeriodModal .card{background:#fff;padding:18px 18px 14px;border-radius:12px;box-shadow:0 12px 34px rgba(0,0,0,.22);width:480px;max-width:96vw;font-family:inherit;box-sizing:border-box;border:1px solid #e5e7eb}
          #newPeriodModal h3{margin:0 0 10px 0;font-size:18px}
          #newPeriodModal label{display:block;font-size:13px;color:#374151;margin-top:8px}
          #newPeriodModal input[type=date]{width:100%;margin-top:4px;padding:8px;border:1px solid #D1D5DB;border-radius:8px;box-sizing:border-box}
          #newPeriodModal .row{display:flex;gap:12px;margin-top:4px;flex-wrap:wrap}
          #newPeriodModal .row > div{flex:1 1 0;min-width:0}
          #newPeriodModal .actions{margin-top:14px;display:flex;gap:8px;justify-content:flex-end}
          #newPeriodModal .spinner{width:16px;height:16px;border:2px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;animation:npSpin 0.8s linear infinite;display:none}
          #newPeriodModal .status{font-size:12px;color:#6B7280;margin-right:auto;display:none;align-items:center;gap:6px}
          @keyframes npSpin{to{transform:rotate(360deg)}}
          #newPeriodModal .error{color:#b91c1c;font-size:12px;display:none;margin-top:8px}
          @media (max-width: 520px){
            #newPeriodModal .card{width:94vw}
            #newPeriodModal .row > div{flex-basis:100%}
          }
        </style>
        <div id="newPeriodModal">
          <div class="card">
            <h3>New Payroll Period</h3>
            <div class="row">
              <div>
                <label>Start date
                  <input type="date" id="newPeriodStart" />
                </label>
              </div>
              <div>
                <label>End date
                  <input type="date" id="newPeriodEnd" />
                </label>
              </div>
            </div>
            <div class="error" id="newPeriodErr">End date must be on/after start date.</div>
            <div class="actions">
              <div class="status" id="newPeriodStatus"><span class="spinner" id="newPeriodSpin"></span><span>Creating snapshot…</span></div>
              <button id="cancelNewPeriod" type="button">Cancel</button>
              <button id="saveNewPeriod" type="button" class="primary">Create</button>
            </div>
          </div>
        </div>
        <div class="warning-note">
          ðŸ’¾ Data persisted in browser (localStorage). Use Clear to remove.
        </div>
      </div>

      <!-- Begin original content -->

<!-- Original tab buttons and header removed in favour of sidebar navigation -->
  <!-- Dashboard panel to host high-level metrics and payroll history -->
  <section class="panel active" id="panelDashboard">
   <h3>Dashboard</h3>
   <!-- Date range picker and action buttons -->
   <!-- The Generate button has been moved into the date-range picker; retain the controls container for future actions if needed. -->
   <div class="controls"></div>
   <!-- Container for viewing a snapshot or diff results -->
   <div id="snapshotView" style="margin-top:12px;"></div>

   <!-- Active Payrolls table showing all un-locked snapshots -->
   <h4>Active Payrolls</h4>
   <table id="activePayrollTable">
     <thead>
       <tr>
         <th>Start</th>
         <th>End</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <!-- Payroll History table showing all generated/locked snapshots -->
   <h4>Payroll History</h4>
   <table id="historyTable">
     <thead>
       <tr>
         <th>Select</th>
         <th>Start</th>
         <th>End</th>
         <th>Locked At</th>
         <th>Hash</th>
         <th>Actions</th>
       </tr>
     </thead>
     <tbody></tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
     <button id="diffBtn">Diff Selected</button>
   </div>

   <!-- Full Backup & Restore (Dashboard) -->
   <h4 style="margin-top:18px">Full Backup & Restore</h4>
   <div class="controls" id="dashBackupControls" style="gap:8px; align-items:center; flex-wrap:wrap;">
     <button id="dashBackupNow" class="primary" type="button">Backup Now</button>
     <button id="dashRestoreFile" type="button">Restore From File</button>
     <input id="dashRestoreInput" type="file" accept=".json" style="display:none" />
     <!-- Cloud listing and restore removed by request -->
     <span id="dashBackupStatus" style="font-size:12px;color:#334155"></span>
   </div>
   <div id="dashBackupLog" style="display:none;margin:8px 0;padding:10px;border:1px solid #e5e7eb;background:#fff;border-radius:8px;font-size:12px;color:#111;line-height:1.35;max-width:920px;"></div>
  <!-- Detail view for locked payroll snapshots. Hidden by default and shown when a user clicks Open/View on a history row. -->
  <div id="snapshotDetailsScreen" style="display:none; margin-top:12px;">
     <h4 id="snapshotDetailTitle"></h4>
     <div id="snapshotPayrollContainer" style="margin-bottom:16px;"></div>
     <div id="snapshotDTRContainer"></div>
     <button id="snapshotBackButton" type="button" style="margin-top:12px;">Back</button>
  </div>
  </section>

  <script>
  // === Dashboard Full Backup & Restore ===
  (function(){
    const statusEl = document.getElementById('dashBackupStatus');
    const logEl = document.getElementById('dashBackupLog');
    const btnBackup = document.getElementById('dashBackupNow');
    const btnRestoreFile = document.getElementById('dashRestoreFile');
    const inputRestore = document.getElementById('dashRestoreInput');
    // Only keep local backup and file-restore controls
    if(!btnBackup || !btnRestoreFile || !inputRestore) return;

    // Lazily resolve Supabase to avoid capturing `null` before the module loads
    const getSupa = () => (window.supabase || null);
    const KV_TABLE = window.SUPABASE_TABLE || 'kv_store';
    const DTR_TABLE = 'dtr_records';
    const BUCKET = 'backups';

    function setStatus(msg, isError){ if(statusEl){ statusEl.textContent = msg; statusEl.style.color = isError?'#b91c1c':'#334155'; } }
    function log(msg){ try{ logEl.style.display='block'; const d=document.createElement('div'); d.textContent=msg; logEl.appendChild(d);}catch(e){} }
    function clearLog(){ try{ logEl.innerHTML=''; logEl.style.display='none'; }catch(e){} }
    function tryJSON(v){ try{ return JSON.parse(v); }catch{ return v; } }

    async function fetchKVAll(){
      const supa = getSupa();
      if(!supa) return { rows:[], error:'No Supabase client' };
      try{
        const { data, error } = await supa.from(KV_TABLE).select('key,value');
        return { rows: data||[], error: error? error.message : null };
      }catch(e){ return { rows:[], error: String(e) } }
    }
    async function fetchDTR(){
      const supa = getSupa();
      if(!supa) return { rows:[], error:'No Supabase client' };
      try{
        const { data, error } = await supa.from(DTR_TABLE).select('*').limit(1);
        if(error) return { rows:[], error: error.message };
        // Support schemas {id, data} or flat arrays
        if(Array.isArray(data) && data.length){
          const row = data[0];
          if(row && Array.isArray(row.data)) return { rows: row.data, error:null };
        }
        return { rows:[], error:null };
      }catch(e){ return { rows:[], error:String(e) } }
    }

    function snapshotLocalStorage(){
      const kv = {};
      try{
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(!k || k.startsWith('__') || k.startsWith('vscode')) continue;
          kv[k] = tryJSON(localStorage.getItem(k));
        }
      }catch(e){}
      return kv;
    }

    async function buildBundle(){
      clearLog(); setStatus('Building backup...', false);
      const ls = snapshotLocalStorage();
      log('Collected localStorage keys: ' + Object.keys(ls).length);
      const kvRes = await fetchKVAll(); if(kvRes.error) log('KV fetch warning: ' + kvRes.error); else log('KV rows: ' + kvRes.rows.length);
      const dtrRes = await fetchDTR(); if(dtrRes.error) log('DTR fetch warning: ' + dtrRes.error); else log('DTR rows: ' + dtrRes.rows.length);
      const bundle = {
        schema: 'payrollhub.full.v1',
        created_at: new Date().toISOString(),
        localStorage: ls,
        kv: kvRes.rows||[],
        dtr: dtrRes.rows||[]
      };
      return bundle;
    }

    async function uploadBundleToCloud(bundle){
      const supa = getSupa();
      if(!supa || !supa.storage){ log('No Supabase storage client (skipping cloud upload)'); return null; }
      try{
        const json = JSON.stringify(bundle);
        const name = 'full_backup_' + new Date().toISOString().replace(/[:.]/g,'_') + '.json';
        const blob = new Blob([json], { type: 'application/json' });
        const { error } = await supa.storage.from(BUCKET).upload(name, blob, { upsert: true, contentType: 'application/json' });
        if(error){ log('Upload failed: ' + error.message); return null; }
        log('Uploaded to storage: ' + name);
        return name;
      }catch(e){ log('Upload failed: ' + String(e)); return null; }
    }

    // Cloud listing removed

    function applyLocalStorage(ls){
      try{ Object.keys(ls||{}).forEach(k=>{ try{ localStorage.setItem(k, JSON.stringify(ls[k])); }catch(_){} }); }catch(e){}
    }
    async function applyKV(kv){
      const supa = getSupa();
      if(!supa) return;
      try{
        for(const row of (kv||[])){
          if(!row || !row.key) continue;
          try{ await supa.from(KV_TABLE).upsert({ key: row.key, value: row.value }, { onConflict: 'key' }); }catch(_){}
        }
      }catch(e){ log('KV upsert error: ' + String(e)); }
    }
    async function applyDTR(rows){
      const supa = getSupa();
      if(!supa) return;
      try{
        await supa.from(DTR_TABLE).upsert({ id:'records', data: Array.isArray(rows)?rows:[] }, { onConflict:'id' });
        window.storedRecords = Array.isArray(rows)?rows:[];
        try{ localStorage.setItem('att_records_v2', JSON.stringify(window.storedRecords)); }catch(_){ }
      }catch(e){ log('DTR upsert error: ' + String(e)); }
    }

    btnBackup.addEventListener('click', async ()=>{
      btnBackup.disabled = true; setStatus('Building backup...', false); clearLog();
      try{
        const bundle = await buildBundle();
        // Download locally
        try{
          const url = URL.createObjectURL(new Blob([JSON.stringify(bundle)],{type:'application/json'}));
          const a=document.createElement('a'); a.href=url; a.download='payroll_full_backup_'+ new Date().toISOString().slice(0,10)+'.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500);
          log('Downloaded local backup');
        }catch(e){ log('Local download failed: ' + String(e)); }
        // Upload to cloud
        await uploadBundleToCloud(bundle);
        setStatus('Backup complete', false);
      }catch(e){ setStatus('Backup error: ' + String(e), true); }
      finally{ btnBackup.disabled = false; }
    });

    btnRestoreFile.addEventListener('click', ()=> inputRestore.click());
    inputRestore.addEventListener('change', async (ev)=>{
      const f = ev.target.files && ev.target.files[0]; ev.target.value=''; if(!f) return;
      setStatus('Restoring from file...', false); clearLog();
      try{
        const text = await f.text(); const bundle = JSON.parse(text||'{}');
        if(!bundle || bundle.schema !== 'payrollhub.full.v1') throw new Error('Invalid bundle schema');
        applyLocalStorage(bundle.localStorage || {}); log('Applied localStorage');
        await applyKV(bundle.kv || []); log('Applied KV table');
        await applyDTR(bundle.dtr || []); log('Applied DTR rows');
        setStatus('Restore complete', false); alert('Restore complete.');
      }catch(e){ setStatus('Restore failed: ' + String(e), true); alert('Restore failed: ' + String(e)); }
    });

    // Cloud restore removed
  })();
  // === / Dashboard Full Backup & Restore ===
  </script>

  <!-- Original Main panel (DTR) no longer active by default -->
  <section class="panel" id="panelMain">
<!-- Removed DTR-specific Active Payroll selector -->

   <div class="controls">
    <label>
     Upload .DAT/.TXT (multiple)
     <input accept=".dat,.txt" id="fileInput" multiple="" type="file"/>
    </label>
    <button id="manualDtrBtn">Enter Manual DTR</button>
    <button id="printDtrBtn">Print DTR</button>
    <button id="clearData">
     Clear All Data
    </button>
    <label>
     Project:
     <select id="filterProject" title="Filter by project">
     </select>
    </label>
<button id="downloadCSV" style="display:none">
     Download CSV
    </button>
    <label> Search Name: <input id="dtrSearchName" type="text" placeholder="Type a name" style="width:220px" /></label>
   </div>
   <div class="note">
    Regular hours computed per schedule segments. Grace applies to AM/PM in. OT detected after PM out reference.
   </div>
   <!-- Alert to display when there is no remote DTR data and no local DTR data.  This
        banner is hidden by default and shown via showRemoteDtrAlert() -->
   <div id="remoteDtrAlert" style="display:none;margin:8px 0;padding:10px;border:1px solid #facc15;background:#fef9c3;color:#713f12;border-radius:6px;font-weight:600;">
     âš  No remote DTR data found. Import a .DAT/.TXT file on this device to populate cloud data.
   </div>
   <!-- Wrap the results table in a scrollable container so horizontal overflow
        is always visible. Without this wrapper some layouts (especially when
        embedding this page in an iframe or within a limited-width container)
        can hide the horizontal scroll bar and make it appear as if columns
        are missing. -->
   <div class="results-wrapper">
   <!-- DTR Date Finder Controls -->
<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;">
  <label style="display:flex;align-items:center;gap:.35rem;">
    <span>Date:</span>
    <input id="dtrDateFrom" type="date" />
  </label>
  <span>-</span>
  <label>
    <input id="dtrDateTo" type="date" />
  </label>
  <button id="dtrDateClear" type="button">Clear</button>
</div>
<table aria-live="polite" id="resultsTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Project
      </th>
      <th>
       Schedule
      </th>
      <th>
       Date
      </th>
      <th>
       Clock In 1
      </th>
      <th>
       Clock Out 1
      </th>
      <th>
       Clock In 2
      </th>
      <th>
       Clock Out 2
      </th>
      <th>
       OT In
      </th>
      <th>
       OT Out
      </th>
      <th>
       Regular Hrs
      </th>
      <th>
       OT Hrs
      </th>
      <th>Total Hours</th>
      <th>
       Split
      </th>
      <!-- Added explicit Actions column to ensure consistent header structure -->
      <th class="actions-header">
       Actions
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
   <!-- Summary of DTR totals and employee count -->
   <div id="dtrSummary" style="margin-top:4px;font-weight:bold;"></div>
   </div>
  </section>
  
  <section class="panel" id="panelSchedule">
   <h3>
    Schedules
   </h3>
   <div class="controls">
    <label>
     Choose schedule:
     <select id="scheduleSelect">
     </select>
    </label>
    <button id="addScheduleBtn">
     Add
    </button>
    <button id="deleteScheduleBtn">
     Delete
    </button>
    <button id="setDefaultScheduleBtn">
     Set Default
    </button>
   </div>
   <div class="section-title">
    Schedule segments
   </div>
   <table id="scheduleTable">
    <thead>
     <tr>
      <th>
       Segment
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       AM
      </td>
      <td>
       <input class="cell" data-key="sch_am_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_am_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       PM
      </td>
      <td>
       <input class="cell" data-key="sch_pm_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="sch_pm_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday</td>
      <td><input class="cell" data-key="sch_sat_start" type="time"/></td>
      <td><input class="cell" data-key="sch_sat_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <label>
     Grace Minutes:
     <input class="cell" data-key="sch_grace" min="0" style="width:90px" type="number"/>
    </label>
    <label style="margin-left:8px">
     Schedule name:
     <input class="cell" id="scheduleName" style="width:200px"/>
    </label>
    <button id="saveScheduleBtn">
     Save
    </button>
   </div>
   <div class="section-title">
    Ranges (detection per schedule)
   </div>
   <table id="rangesTable">
    <thead>
     <tr>
      <th>
       Slot
      </th>
      <th>
       Start
      </th>
      <th>
       End
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       Clock In 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 1
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_am_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock In 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       Clock Out 2
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_pm_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT In
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_in_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>
       OT Out
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_start" type="time"/>
      </td>
      <td>
       <input class="cell" data-key="rng_ot_out_end" type="time"/>
      </td>
     </tr>
     <tr>
      <td>Saturday OT In</td>
      <td><input class="cell" data-key="rng_sat_ot_start" type="time"/></td>
      <td><input class="cell" data-key="rng_sat_ot_end" type="time"/></td>
     </tr>
    </tbody>
   </table>
   <div class="controls" style="margin-top:8px;">
    <button id="saveRangesBtn">
     Save Ranges
    </button>
    <button id="resetRangesBtn">
     Reset Ranges
    </button>
   </div>
  </section>
  
  <section class="panel" id="panelEmployees">
   <h3>
    Employees
   </h3>
   <div class="controls">
    <input class="cell" id="empIdInput" placeholder="ID" style="width:120px"/>
    <input class="cell" id="empNameInput" placeholder="Name" style="width:220px"/>
    <input class="cell" id="empRateInput" min="0" placeholder="Hourly Rate" step="0.01" style="width:140px" type="number"/>
    <input class="cell" id="empBankInput" placeholder="Bank Account" style="width:220px"/>
    <label>
     Schedule:
     <select id="empScheduleSelect">
     </select>
    </label>
    <label>
     Project:
     <select id="empProjectSelect">
     </select>
    </label>
    <button id="addEmployeeBtn">
     Add
    </button>
    <button id="clearEmployeesBtn">
     Clear All Employees
    </button>
   </div>
   <div class="controls" style="margin-top:6px;align-items:center;">
    <label style="font-weight:600">
     Upload employee list (no header):
    </label>
    <input accept=".xlsx,.xls,.csv" id="empFileInput" type="file"/>
    <button id="downloadEmployeesCSV">
     Download Employees CSV
    </button>
    <div class="muted">
     Cols: A = ID, B = Name, C = Hourly Rate (optional), D = Schedule Name (optional), E = Project Name (optional), F = Bank Account (optional). Imported employees get default schedule and no project unless set.
    </div>
   </div>


   <table id="employeesTable">
    <thead>
     <tr>
      <th>
       ID
      </th>
      <th>
       Name
      </th>
      <th>
       Hourly Rate
      </th>
      <th>
       Schedule
      </th>
      <th>
       Project
      </th>
      <th>Bank Account</th><th>Pag-IBIG</th><th>PhilHealth</th><th>SSS</th><th>Action</th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  
  <section class="panel" id="panelProjects">
   <h3>
    Projects
   </h3>
   <div class="controls">
    <input class="cell" id="projectNameInput" placeholder="Project Name" style="width:220px"/>
    <button id="addProjectBtn">
     Add
    </button>
    <button id="clearProjectsBtn">
     Clear All Projects
    </button>
   </div>
   <table id="projectsTable">
    <thead>
     <tr>
      <th>
       Project Name
      </th>
      <th>
       Action
      </th>
     </tr>
    </thead>
    <tbody>
    </tbody>
   </table>
  </section>
  <section class="panel" id="panelPayroll">
   <div id="payrollWrapper">
    <header>
     <h2>
      Payroll
     </h2>
     <div class="tabs">
      <button class="tab-btn active" data-tab="payrollTab">
       Payroll
      </button>
      <!-- Renamed SSS sub-tab to Contributions to include additional government contributions -->
      <button class="tab-btn" data-tab="contributionsTab">
       Contributions
      </button>
      <button class="tab-btn" data-tab="deductionsTab">
       Deductions
      </button>
      <!-- New sub-tab for manual adjustments -->
      <button class="tab-btn" data-tab="adjustmentsTab">Adjustments</button>
     </div>
    </header>
    <div class="tab active" id="payrollTab">
     <div class="controls">
      <label>
       OT Multiplier
       <br/>
       <input id="otMultiplier" step="0.01" style="width:100px" type="number" value="1.50"/>
      </label>
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisor">
        <option value="1">
         1
        </option>
        <option value="2">
         2
        </option>
        <option value="3">
         3
        </option>
        <option value="4">
         4
        </option>
        <option value="5">
         5
        </option>
       </select>
      </label>
      <div style="flex:1 1 auto">
      </div>
      <button class="primary" id="downloadPayrollCSV">
       Download Payroll CSV
      </button>
      <button id="printPayrollBtn" type="button">
       Print Report
      </button>
      <button id="printAllPayslipsBtn" type="button">
       Print Payslips
      </button>
     </div>
     <!-- Contribution formula note with dynamic rates updated via script -->
     <div id="contribNote" class="section note">
      Pag-IBIG = Regular Pay × 2% (not divided), PhilHealth = Regular Pay × 2.5% (not divided),
    SSS = (Employee Share by Monthly Income) ÷ Divisor. SSS Loan and Pag‑IBIG Loan are divided by the Divisor. Vales are manual (not divided).
     </div>
     <table id="payrollTable">
      <thead>
       <tr>
        <th>
         ID
        </th>
        <th>
         Name
        </th>
        <th>
         Hourly Rate
        </th>
        <th>
         Regular Hours
        </th>
        <th>
         OT Hours
        </th>
        <th>
         Adjustment Hrs
        </th>
        
        <th>Total Hours</th>
        <th>
         Regular Pay
        </th>
        <th>
         OT Pay
        </th>
        <th>
         Adjustments
        </th>
        <th>
         Bantay
        </th>
        <th>
         Gross Pay
        </th>
        <th>
         Pag-IBIG
        </th>
        <th>
         PhilHealth
        </th>
        <th>
         SSS
        </th>
        <th>
         SSS Loan
        </th>
        <th>
         Pag-IBIG Loan
        </th>
        <th>
         Account
        </th>
        <th>
         Wed Vale
        </th>
        <th>
         Total Deductions
        </th>
        <th>
         Net Pay
        </th>
       <th>
        Payslip
       </th>
      </tr>
     </thead>
      <tbody>
       <tr><td class="totalDed">100</td></tr>
       <tr><td class="totalDed">200</td></tr>
       <tr><td class="totalDed">50</td></tr>
      </tbody>
      <tfoot id="payrollTotalsFoot">
  <tr>
    <td colspan="2" class="label-cell">Grand Total</td>
    <td class="num" data-col="rate"></td>
    <td class="num" data-col="regHrs">0.00</td>
    <td class="num" data-col="otHrs">0.00</td>
    <td class="num" data-col="adjHrs">0.00</td>
    <td class="num" data-col="totalHrs">0.00</td>
      <td class="num" data-col="regPay">0.00</td>
      <td class="num" data-col="otPay">0.00</td>
      <td class="num" data-col="adjAmt">0.00</td>
      <td class="num" data-col="bantay">0.00</td>
      <td class="num" data-col="grossPay">0.00</td>
    <td class="num" data-col="pagibig">0.00</td>
    <td class="num" data-col="philhealth">0.00</td>
    <td class="num" data-col="sss">0.00</td>
    <td class="num" data-col="loanSSS">0.00</td>
    <td class="num" data-col="loanPI">0.00</td>
      <td class="num" data-col="vale">0.00</td>
      <td class="num" data-col="valeWed">0.00</td>
      <td class="num" data-col="totalDed">0.00</td>
      <td class="num" data-col="netPay">0.00</td>
    <td></td>
  </tr>
</tfoot>

     </table>
     <div class="section note">
      Reads employees from localStorage key
      <code>
       att_employees_v2
      </code>
      (id&rarr;{name}). If none found, shows a sample row.
     </div>
    </div>
    <!-- Renamed SSS tab to Contributions for clarity -->
    <div class="tab" id="contributionsTab">
     <div class="controls">
      <button id="addSssRow">
       Add Row
      </button>
      <button class="primary" id="resetSss">
       Reset to Defaults (Custom)
      </button>
      <button class="danger" id="clearSss">
       Clear SSS Table
      </button>
      <button id="exportSss">
       Export CSV
      </button>
      <label>
       Import CSV (min,max,employeeShare)
       <br/>
       <input accept=".csv,text/csv" id="importSss" type="file"/>
      </label>
     </div>
     <table id="sssTable">
      <thead>
       <tr>
        <th>
         Range From (â‚±)
        </th>
        <th>
         Range To (â‚±)
        </th>
        <th>
         Employee Share (â‚±)
        </th>
        <th>
         Actions
        </th>
       </tr>
      </thead>
      <tbody>
      </tbody>
     </table>
     <div class="section note">
      Monthly Income = Hourly Rate &times; 8 &times; 24. We pick the row where
      <i>
       min &le; income &le; max
      </i>
      and use the Employee Share.
     </div>
    <!-- Editable Pagâ€‘IBIG and PhilHealth tables (employee rates).  Each table allows
         defining income ranges and the corresponding employee rate (as a decimal).
         The rate is applied to regular pay to compute the contribution. -->
    <h4>Pagâ€‘IBIG Table (Employee Rate)</h4>
    <div class="controls">
      <button id="addPagibigRow">
       Add Row
      </button>
      <button class="primary" id="resetPagibig">
       Reset to Defaults
      </button>
      <button class="danger" id="clearPagibig">
       Clear Pag-IBIG Table
      </button>
    </div>
    <table id="pagibigTable">
      <thead>
        <tr>
          <th>Range From (â‚±)</th>
          <th>Range To (â‚±)</th>
          <th>Rate (decimal)</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <div class="section note">
      Rate is decimal (e.g. 0.02 = 2% employee share). Employer share is assumed to match the employee share but is not used in calculations.
    </div>
    <h4>PhilHealth Table (Employee Rate)</h4>
    <div class="controls">
      <button id="addPhilRow">
       Add Row
      </button>
      <button class="primary" id="resetPhil">
       Reset to Defaults
      </button>
      <button class="danger" id="clearPhil">
       Clear PhilHealth Table
      </button>
    </div>
    <table id="philhealthTable">
      <thead>
        <tr>
          <th>Range From (â‚±)</th>
          <th>Range To (â‚±)</th>
          <th>Rate (decimal)</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
    <div class="section note">
      Rate is decimal (e.g. 0.025 = 2.5% employee share). Employer share is assumed to match the employee share but is not used in calculations.
    </div>
    </div>
    <div class="tab" id="deductionsTab">
     <!-- Sub-tab navigation for Deductions.  Users can switch between the main
          deductions table and the cash advance tracker.  We reuse the
          existing tab button styles by including the `tab-btn` class. -->
     <div class="subtab-nav">
      <button class="tab-btn subtab-btn active" data-subtab="dedMainSection">Deductions Table</button>
      <button class="tab-btn subtab-btn" data-subtab="cashAdvanceSection">Cash Advance Tracker</button>
     </div>
     <!-- Main deductions content wrapper.  All of the existing controls,
          informational notes and the deductions table reside inside this
          wrapper so that it can be toggled independently from the cash
          advance tracker. -->
     <div id="dedMainSection" class="subtab-panel active">
     <div class="controls">
      <label>
       Upload Excel/CSV (ID, Pag-IBIG Loan, SSS Loan, Vale, Wed Vale):
       <br/>
       <input accept=".xlsx,.xls,.csv" id="deductionsFileInput" type="file"/>
      </label>
      <button id="exportDeductionsCSV">Export CSV</button>

      <!-- Divisor selector for splitting deductions across pay periods (Deductions tab) -->
      <label>
       Divide Deductions By
       <br/>
       <select id="deductionDivisorDeds">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
       </select>
      </label>
     </div>
     <div class="section note">
      <strong>File Format:</strong> Use the exported CSV from this table, then edit only these columns:
      <br/>â€¢ <strong>Column 6:</strong> SSS Loan (edit this value)
      <br/>â€¢ <strong>Column 7:</strong> Pag-IBIG Loan (edit this value)  
      <br/>â€¢ <strong>Column 8:</strong> Vale (edit this value)
      <br/>â€¢ <strong>Column 9:</strong> Wed Vale (edit this value)
      <br/><strong>Important:</strong> Don't change columns 1-5 or 10 (they're calculated automatically)
      <br/><strong>Note:</strong> If employee names are split into 2 columns, the system automatically adjusts
     </div>
     <table id="deductionsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Pag-IBIG</th>
        <th>PhilHealth</th>
        <th>SSS</th>
        <th>SSS Loan</th>
        <th>Pag-IBIG Loan</th>
        <th>Account</th>
        <th>Wed Vale</th>
        <th>Total Deductions</th>
       </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="deductionsTable_foot">
        <tr>
          <td class="label-cell" colspan="2">Grand Total</td>
          <td class="num" data-col="pagibig">0.00</td>
          <td class="num" data-col="philhealth">0.00</td>
          <td class="num" data-col="sss">0.00</td>
          <td class="num" data-col="loanSSS">0.00</td>
          <td class="num" data-col="loanPI">0.00</td>
          <td class="num" data-col="vale">0.00</td>
          <td class="num" data-col="valeWed">0.00</td>
          <td class="num" data-col="total">0.00</td>
        </tr>
      </tfoot>

     </table>
     </div><!-- close dedMainSection -->
     <!-- Cash Advance Tracker section.  Initially hidden; toggled via the subtab buttons. -->
     <div id="cashAdvanceSection" class="subtab-panel" style="display:none;">
      <table id="cashAdvanceTable">
        <thead>
         <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Original Amount</th>
          <th>Deduction</th>
          <th>Balance</th>
          <th>Action</th>
         </tr>
        </thead>
        <tbody></tbody>
      </table>
     </div>
    </div>

    <!-- Manual Adjustments Tab -->
    <div class="tab" id="adjustmentsTab">
     <div class="section note">
      Enter positive or negative adjustments for each employee. These values will be added (or subtracted if negative) to the net pay. Adjustments are saved automatically.
     </div>
     <table id="adjustmentsTable">
      <thead>
       <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Adjustment Amount</th>
        <th>Adjustment Hrs</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot id="adjustmentsTableFoot">
       <tr>
        <td colspan="2" class="label-cell">Total Adjustments</td>
        <td class="num" data-col="adjAmt">0.00</td>
        <td class="num" data-col="adjHrs">0.00</td>
       </tr>
      </tfoot>
     </table>
    </div>

    <script>
const LS_RATES='payroll_rates', LS_REG_HRS='payroll_reg_hours', LS_OT_HRS='payroll_ot_hours';
const LS_OTMULT='payroll_ot_multiplier', LS_WEEKSTART='payroll_week_start', LS_WEEKEND='payroll_week_end';
const LS_DIVISOR='payroll_deduction_divisor', LS_SSS_TABLE='payroll_sss_table';
const LS_LOAN_SSS='payroll_loan_sss', LS_LOAN_PI='payroll_loan_pagibig';
const LS_VALE='payroll_vale', LS_VALE_WED='payroll_vale_wed';
// LocalStorage key for per-employee payroll adjustments
const LS_ADJ='payroll_adjustments';
// LocalStorage key for per-employee adjustment hours (OT adjustments)
const LS_ADJ_HRS='payroll_adjustment_hours';
// LocalStorage keys for dynamic Pagâ€‘IBIG and PhilHealth contribution rates (employee share)
const LS_PAGIBIG_RATE='payroll_pagibig_rate';
const LS_PHILHEALTH_RATE='payroll_philhealth_rate';
// LocalStorage keys for dynamic Pagâ€‘IBIG and PhilHealth contribution tables
const LS_PAGIBIG_TABLE='payroll_pagibig_table';
const LS_PHILHEALTH_TABLE='payroll_philhealth_table';
// LocalStorage key for per-employee Bantay allowance
const LS_BANTAY='payroll_bantay';
// Supabase-only key for per-employee Bantayâ†’Project assignment map
const LS_BANTAY_PROJ='payroll_bantay_proj';
let bantayProj = {};
;(async function(){
  try{
    let v = await readKV(LS_BANTAY_PROJ);
    if (!v) {
      try { v = JSON.parse(localStorage.getItem(LS_BANTAY_PROJ) || '{}'); } catch(_){}
    }
    if (v && typeof v==='object') bantayProj = v;
    try { localStorage.setItem(LS_BANTAY_PROJ, JSON.stringify(bantayProj)); } catch(_){ }
    try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
  }catch(e){}
})();
// LocalStorage key for per-employee contribution flags (Pag-IBIG, PhilHealth, SSS)
const LS_CONTRIB_FLAGS='payroll_contrib_flags';

// Current employee contribution rates (decimal form).  Defaults: 0.02 (2%) for Pagâ€‘IBIG and 0.025 (2.5%) for PhilHealth.
let pagibigRate = parseFloat(localStorage.getItem(LS_PAGIBIG_RATE) ?? '0.02');
if (isNaN(pagibigRate)) pagibigRate = 0.02;
let philhealthRate = parseFloat(localStorage.getItem(LS_PHILHEALTH_RATE) ?? '0.025');
if (isNaN(philhealthRate)) philhealthRate = 0.025;
const SSS_SEED_2025 = [
  [1, 5249.99, 250],
  [5250, 5749.99, 275],
  [5750, 6249.99, 300],
  [6250, 6749.99, 325],
  [6750, 7249.99, 350],
  [7250, 7749.99, 375],
  [7750, 8249.99, 400],
  [8250, 8749.99, 425],
  [8750, 9249.99, 450],
  [9250, 9749.99, 475],
  [9750, 10249.99, 500],
  [10250, 10749.99, 525],
  [10750, 11249.99, 550],
  [11250, 11749.99, 575],
  [11750, 12249.99, 600],
  [12250, 12749.99, 625],
  [12750, 13249.99, 650],
  [13250, 13749.99, 675],
  [13750, 14249.99, 700],
  [14250, 14749.99, 725],
  [14750, 15249.99, 750],
  [15250, 15749.99, 775],
  [15750, 16249.99, 800],
  [16250, 16749.99, 825],
  [16750, 17249.99, 850],
  [17250, 17749.99, 875],
  [17750, 18249.99, 900],
  [18250, 18749.99, 925],
  [18750, 19249.99, 950],
  [19250, 19749.99, 975],
  [19750, 20249.99, 1000],
  [20250, 20749.99, 1025],
  [20750, 21249.99, 1050],
  [21250, 21749.99, 1075],
  [21750, 22249.99, 1100],
  [22250, 22749.99, 1125],
  [22750, 23249.99, 1150],
  [23250, 23749.99, 1175],
  [23750, 24249.99, 1200],
  [24250, 24749.99, 1225],
  [24750, 25249.99, 1250],
  [25250, 25749.99, 1275],
  [25750, 26249.99, 1300],
  [26250, 26749.99, 1325],
  [26750, 27249.99, 1350],
  [27250, 27749.99, 1375],
  [27750, 28249.99, 1400],
  [28250, 28749.99, 1425],
  [28750, 29249.99, 1450],
  [29250, 29749.99, 1475],
  [29750, 30249.99, 1500],
  [30250, 30749.99, 1525],
  [30750, 31249.99, 1550],
  [31250, 31749.99, 1575],
  [31750, 32249.99, 1600],
  [32250, 32749.99, 1625],
  [32750, 33249.99, 1650],
  [33250, 33749.99, 1675],
  [33750, 34249.99, 1700],
  [34250, 34749.99, 1725],
  [34750, 100000000, 1750]
];

function ensureSeededSSS() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
      localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    localStorage.setItem(LS_SSS_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededSSS();
// Seed the Pagâ€‘IBIG and PhilHealth tables with default rates if empty.  These tables
// define income ranges and the corresponding employee contribution rate (decimal).
const PAGIBIG_SEED = [
  [0, 100000000, 0.02]
];
const PHILHEALTH_SEED = [
  [0, 100000000, 0.025]
];

function ensureSeededPagibig() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(mapped));
  }
}

function ensureSeededPhilhealth() {
  try {
    const cur = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
    if (!Array.isArray(cur) || cur.length === 0) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
    }
  } catch (e) {
    const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
    localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(mapped));
  }
}
ensureSeededPagibig();
ensureSeededPhilhealth();
let payrollRates = JSON.parse(localStorage.getItem(LS_RATES) || '{}');
let regHours = JSON.parse(localStorage.getItem(LS_REG_HRS) || '{}');
let otHours = JSON.parse(localStorage.getItem(LS_OT_HRS) || '{}');

// Per-employee contribution deduction flags. Each entry keyed by employee ID holds booleans {pagibig, philhealth, sss}
let contribFlags = JSON.parse(localStorage.getItem(LS_CONTRIB_FLAGS) || '{}');

// Cash advance localStorage keys and in-memory objects.  These store per-employee
// original cash advance amounts, per-payroll deductions and the current
// outstanding balance.  Each key is persisted to localStorage (and
// mirrored to Supabase via the auto-sync adapter) under its own
// namespace.  The objects are keyed by employee ID.  See the cash
// advance tracker script at the bottom of the document for usage.
const LS_CASH_ORIG = 'payroll_cashAdvanceOrig',
      LS_CASH_DED  = 'payroll_cashAdvanceDed',
      LS_CASH_BAL  = 'payroll_cashAdvanceBal';
let cashOrig = JSON.parse(localStorage.getItem(LS_CASH_ORIG) || '{}');
let cashDed  = JSON.parse(localStorage.getItem(LS_CASH_DED)  || '{}');
let cashBal  = JSON.parse(localStorage.getItem(LS_CASH_BAL)  || '{}');

let otMultiplier = parseFloat(localStorage.getItem(LS_OTMULT)) || 1.50;
let weekStartSaved = localStorage.getItem(LS_WEEKSTART) || '';
let weekEndSaved = localStorage.getItem(LS_WEEKEND) || '';
let divisor = parseInt(localStorage.getItem(LS_DIVISOR) || '1', 10);
const weekStartEl = document.getElementById('weekStart');
const weekEndEl = document.getElementById('weekEnd');
const otMultiplierEl = document.getElementById('otMultiplier');
const divisorEl = document.getElementById('deductionDivisor');
const divisorDedsEl = document.getElementById('deductionDivisorDeds');
const tbody = document.querySelector('#payrollTable tbody');
document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('#panelPayroll .tabs .tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('#panelPayroll .tab').forEach(t=>t.classList.remove('active'));
    btn.classList.add('active');
    const panel = document.querySelector('#panelPayroll #' + btn.dataset.tab);
    if (panel) panel.classList.add('active');
  });
});
otMultiplierEl.value = otMultiplier;
weekStartEl.value = weekStartSaved;
weekEndEl.value = weekEndSaved;
divisorEl.value = divisor;

function periodKey(){return (weekStartEl.value||'')+'_'+(weekEndEl.value||'');}
const PERIOD_META_KEY='__meta';
const PERIOD_DEFAULT_KEY='__default';
function isPlainObject(val){ return !!val && typeof val === 'object' && !Array.isArray(val); }
function clonePeriodData(src){
  if(!isPlainObject(src)) return {};
  try { return JSON.parse(JSON.stringify(src)); } catch (e) {
    const out = {};
    Object.keys(src || {}).forEach(k => { out[k] = src[k]; });
    return out;
  }
}
function splitPeriodKey(key){
  if (typeof key !== 'string') return { start: '', end: '' };
  const parts = key.split('_');
  return { start: parts[0] || '', end: parts[1] || '' };
}
function comparePeriodKeys(a, b){
  if (a === b) return 0;
  const pa = splitPeriodKey(a);
  const pb = splitPeriodKey(b);
  if (pa.start && pb.start && pa.start !== pb.start) return pa.start < pb.start ? -1 : 1;
  if (pa.start && !pb.start) return 1;
  if (!pa.start && pb.start) return -1;
  if (pa.end && pb.end && pa.end !== pb.end) return pa.end < pb.end ? -1 : 1;
  if (pa.end && !pb.end) return 1;
  if (!pa.end && pb.end) return -1;
  const aStr = typeof a === 'string' ? a : '';
  const bStr = typeof b === 'string' ? b : '';
  if (aStr === bStr) return 0;
  return aStr < bStr ? -1 : 1;
}
function sortedPeriodKeys(map){
  return Object.keys(map || {})
    .filter(k => k !== PERIOD_META_KEY && k !== PERIOD_DEFAULT_KEY)
    .sort(comparePeriodKeys);
}
function ensurePeriodMeta(map){
  if (!isPlainObject(map)) return { periodScoped: true, latestKey: '' };
  const meta = isPlainObject(map[PERIOD_META_KEY]) ? map[PERIOD_META_KEY] : {};
  meta.periodScoped = true;
  if (typeof meta.latestKey !== 'string') meta.latestKey = '';
  map[PERIOD_META_KEY] = meta;
  return meta;
}
function loadPeriodScopedMap(lsKey){
  let parsed;
  try { parsed = JSON.parse(localStorage.getItem(lsKey) || '{}'); }
  catch(e){ parsed = {}; }
  if (!isPlainObject(parsed)) parsed = {};
  const meta = parsed[PERIOD_META_KEY];
  if (!isPlainObject(meta) || meta.periodScoped !== true) {
    const legacy = parsed;
    parsed = {};
    parsed[PERIOD_META_KEY] = { periodScoped: true, latestKey: '' };
    parsed[PERIOD_DEFAULT_KEY] = isPlainObject(legacy) ? legacy : {};
  } else {
    parsed[PERIOD_META_KEY] = Object.assign({}, meta, { periodScoped: true });
  }
  const ensuredMeta = ensurePeriodMeta(parsed);
  const keys = sortedPeriodKeys(parsed);
  if (!ensuredMeta.latestKey && keys.length) {
    ensuredMeta.latestKey = keys[keys.length - 1];
  }
  if (!isPlainObject(parsed[PERIOD_DEFAULT_KEY]) && ensuredMeta.latestKey && isPlainObject(parsed[ensuredMeta.latestKey])) {
    parsed[PERIOD_DEFAULT_KEY] = clonePeriodData(parsed[ensuredMeta.latestKey]);
  }
  return parsed;
}
function findCarryTemplate(map, key, fallbackKey){
  const keys = sortedPeriodKeys(map);
  if (!keys.length) return null;
  let candidate = null;
  for (const existing of keys){
    if (comparePeriodKeys(existing, key) <= 0) {
      candidate = existing;
    } else {
      break;
    }
  }
  if (candidate && isPlainObject(map[candidate])) return map[candidate];
  if (fallbackKey && comparePeriodKeys(fallbackKey, key) <= 0 && isPlainObject(map[fallbackKey])) {
    return map[fallbackKey];
  }
  return null;
}
function ensurePeriodData(map, key, template, options){
  if (!isPlainObject(map)) return {};
  const allowDefault = !options || options.allowDefault !== false;
  if (!isPlainObject(map[key])) {
    let base = {};
    if (isPlainObject(template)) base = template;
    else if (allowDefault && isPlainObject(map[PERIOD_DEFAULT_KEY])) base = map[PERIOD_DEFAULT_KEY];
    map[key] = clonePeriodData(base);
  }
  return map[key];
}
function updatePeriodLatest(map, key, data){
  if (!isPlainObject(map) || !key) return;
  const meta = ensurePeriodMeta(map);
  if (!meta.latestKey || comparePeriodKeys(key, meta.latestKey) >= 0) {
    meta.latestKey = key;
    if (isPlainObject(data)) {
      map[PERIOD_DEFAULT_KEY] = clonePeriodData(data);
    }
  }
}
function persistPeriodScopedMap(lsKey, map){
  if (!isPlainObject(map)) return;
  ensurePeriodMeta(map);
  try {
    if (isPlainObject(map.__meta)) map.__meta.lastUpdatedAt = Date.now();
  } catch(_){}
  try { localStorage.setItem(lsKey, JSON.stringify(map)); } catch(e){}
  try { if (typeof writeKV === 'function') writeKV(lsKey, map); } catch(_){}
}
let currentPeriodKey = periodKey();
const allLoanSSS = loadPeriodScopedMap(LS_LOAN_SSS);
const allLoanPI = loadPeriodScopedMap(LS_LOAN_PI);
const allVale = loadPeriodScopedMap(LS_VALE);
const allValeWed = loadPeriodScopedMap(LS_VALE_WED);
let loanSSS = ensurePeriodData(allLoanSSS, currentPeriodKey);
let loanPI = ensurePeriodData(allLoanPI, currentPeriodKey);
let vale = ensurePeriodData(allVale, currentPeriodKey);
let valeWed = ensurePeriodData(allValeWed, currentPeriodKey);
function saveCurrentPeriodDeductions(){
  if (!currentPeriodKey) return;
  allLoanSSS[currentPeriodKey] = loanSSS || {};
  allLoanPI[currentPeriodKey] = loanPI || {};
  allVale[currentPeriodKey] = vale || {};
  allValeWed[currentPeriodKey] = valeWed || {};
  updatePeriodLatest(allLoanSSS, currentPeriodKey, loanSSS);
  updatePeriodLatest(allLoanPI, currentPeriodKey, loanPI);
  updatePeriodLatest(allVale, currentPeriodKey, vale);
  updatePeriodLatest(allValeWed, currentPeriodKey, valeWed);
  persistPeriodScopedMap(LS_LOAN_SSS, allLoanSSS);
  persistPeriodScopedMap(LS_LOAN_PI, allLoanPI);
  persistPeriodScopedMap(LS_VALE, allVale);
  persistPeriodScopedMap(LS_VALE_WED, allValeWed);
  try {
    window.loanSSS = loanSSS;
    window.loanPI = loanPI;
    window.vale = vale;
    window.valeWed = valeWed;
  } catch(e){}
}
saveCurrentPeriodDeductions();
let allAdjustments = JSON.parse(localStorage.getItem(LS_ADJ) || '{}');
let adjustments = allAdjustments[currentPeriodKey] || {};
let allAdjHrs = JSON.parse(localStorage.getItem(LS_ADJ_HRS) || '{}');
let adjHrs = allAdjHrs[currentPeriodKey] || {};
let allBantay = JSON.parse(localStorage.getItem(LS_BANTAY) || '{}');
let bantay = allBantay[currentPeriodKey] || {};
function syncPeriodScopedData(){
  const pk = periodKey();
  if (pk === currentPeriodKey) return false;
  const prevKey = currentPeriodKey;
  saveCurrentPeriodDeductions();
  const direction = comparePeriodKeys(pk, prevKey);
  const carryForward = direction >= 0;
  const tplSSS = carryForward ? findCarryTemplate(allLoanSSS, pk, prevKey) : null;
  const tplPI = carryForward ? findCarryTemplate(allLoanPI, pk, prevKey) : null;
  const tplVale = carryForward ? findCarryTemplate(allVale, pk, prevKey) : null;
  const tplValeWed = carryForward ? findCarryTemplate(allValeWed, pk, prevKey) : null;
  loanSSS = ensurePeriodData(allLoanSSS, pk, tplSSS, { allowDefault: carryForward });
  loanPI = ensurePeriodData(allLoanPI, pk, tplPI, { allowDefault: carryForward });
  vale = ensurePeriodData(allVale, pk, tplVale, { allowDefault: carryForward });
  valeWed = ensurePeriodData(allValeWed, pk, tplValeWed, { allowDefault: carryForward });
  adjustments = allAdjustments[pk] || {};
  adjHrs = allAdjHrs[pk] || {};
  bantay = allBantay[pk] || {};
  currentPeriodKey = pk;
  saveCurrentPeriodDeductions();
  return true;
}
;(async function(){
  try{
    let v = await readKV(LS_BANTAY);
    if (!v) {
      try { v = JSON.parse(localStorage.getItem(LS_BANTAY) || '{}'); } catch(_){ }
    }
    if (v && typeof v === 'object') {
      allBantay = v;
      bantay = allBantay[currentPeriodKey] || {};
    }
    try { localStorage.setItem(LS_BANTAY, JSON.stringify(allBantay)); } catch(_){ }
    try{ if (typeof renderSssTable==='function') renderSssTable(); }catch(_){ }
    try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
  }catch(e){}
})();
// Sync the Deductions tab divisor select with the stored divisor value and attach event listener
if (divisorDedsEl) {
  divisorDedsEl.value = String(divisor);
  divisorDedsEl.addEventListener('change', () => {
    divisor = parseInt(divisorDedsEl.value, 10) || 1;
    divisorEl.value = String(divisor);
    localStorage.setItem(LS_DIVISOR, String(divisor));
    calculateAll();
  });
}

otMultiplierEl.addEventListener('input', ()=>{ otMultiplier = parseFloat(otMultiplierEl.value)||0; localStorage.setItem(LS_OTMULT, otMultiplier); calculateAll(); });
weekStartEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKSTART, weekStartEl.value));
weekEndEl.addEventListener('input', ()=> localStorage.setItem(LS_WEEKEND, weekEndEl.value));
divisorEl.addEventListener('change', () => {
  divisor = parseInt(divisorEl.value, 10) || 1;
  localStorage.setItem(LS_DIVISOR, String(divisor));
  // Sync the Deductions tab divisor select if it exists
  if (typeof divisorDedsEl !== 'undefined' && divisorDedsEl) {
    divisorDedsEl.value = String(divisor);
  }
  calculateAll();
});
function loadEmployees() {
  const stored = JSON.parse(localStorage.getItem('att_employees_v2') || '{}');
  let list = Object.keys(stored).map(id=>({id, name: stored[id]?.name || ''}));
  if (list.length === 0) list = [{id:'001', name:'Sample Employee'}];
  list.sort((a,b)=> (a.name||'').localeCompare(b.name||''));
  return list;
}
const employeeList = loadEmployees();
function getSssTable(){
  let arr = [];
  try { arr = JSON.parse(localStorage.getItem(LS_SSS_TABLE) || '[]'); }
  catch(e){ arr = []; }
  if (!Array.isArray(arr)) arr = [];
  arr = arr.map(r=>({min:Number(r.min)||0, max:Number(r.max)||0, employee:Number(r.employee)||0}))
           .sort((a,b)=> a.min - b.min);
  return arr;
}
function setSssTable(rows){
  localStorage.setItem(LS_SSS_TABLE, JSON.stringify(rows));
}

function renderDeductionsTable(){
  syncPeriodScopedData();
  const dtbody = document.querySelector('#deductionsTable tbody');
  if (!dtbody) return;
  dtbody.innerHTML = '';
  employeeList.forEach(emp => {
    const rH = Number(regHours[emp.id] ?? 0);
    const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
    payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
const lSSS = Number(loanSSS[emp.id] ?? 0);
    const lPI = Number(loanPI[emp.id] ?? 0);
    const v = Number(vale[emp.id] ?? 0);
    const vW = Number(valeWed[emp.id] ?? 0);
    const regPay = +(rH * rate).toFixed(2);
    // Use dynamic contribution tables for Pagâ€‘IBIG and PhilHealth.  Determine the
    // applicable rate based on monthly income and multiply by regular pay.
    const monthly = rate * 8 * 24;
    const piRate = pagibigRateByMonthly(monthly);
    const phRate = philhealthRateByMonthly(monthly);
    const div = Number(divisor) || 1;
    const pagibig = +((regPay * piRate)).toFixed(2);
    const philhealth = +((regPay * phRate)).toFixed(2);
    const sssFull = sssShareByMonthly(monthly);
    const sss = +(sssFull / div).toFixed(2);
    const sssLoan = +(lSSS / div).toFixed(2);
    const piLoan = +(lPI / div).toFixed(2);
    const total = +(pagibig + philhealth + sss + sssLoan + piLoan + v + vW).toFixed(2);
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${emp.id}</td><td class="wrap">${emp.name}</td>
      <td class="num">${pagibig.toFixed(2)}</td>
      <td class="num">${philhealth.toFixed(2)}</td>
      <td class="num">${sss.toFixed(2)}</td>
      <td class="num">${sssLoan.toFixed(2)}</td>
      <td class="num">${piLoan.toFixed(2)}</td>
      <td class="num">${v.toFixed(2)}</td>
      <td class="num">${vW.toFixed(2)}</td>
      <td class="num">${total.toFixed(2)}</td>`;
    dtbody.appendChild(tr);
  });
}
document.addEventListener('click', (e)=>{
  if(e.target && e.target.id === 'exportDeductionsCSV'){
    try {
      const header = ['ID','Name','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Account','Wed Vale','Total Deductions'];
      const rows = [header];

      const div = Number(typeof divisor !== 'undefined' ? divisor : 1) || 1;

      (employeeList || []).forEach(emp => {
        const id = emp.id;
        const name = (typeof storedEmployees !== 'undefined' && storedEmployees && storedEmployees[id] && storedEmployees[id].name) ? storedEmployees[id].name : (emp.name || '');

        const rate = Number((typeof storedEmployees !== 'undefined' && storedEmployees?.[id]?.hourlyRate) ?? (typeof payrollRates !== 'undefined' ? payrollRates?.[id] : 0)) || 0;
        const rH   = Number((typeof regHours !== 'undefined' ? regHours?.[id] : 0)) || 0;
        const regPay = +(rH * rate).toFixed(2);

        const monthly  = rate * 8 * 24;
        const piRate   = (typeof pagibigRateByMonthly === 'function') ? pagibigRateByMonthly(monthly) : 0;
        const phRate   = (typeof philhealthRateByMonthly === 'function') ? philhealthRateByMonthly(monthly) : 0;
        const sssFull  = (typeof sssShareByMonthly === 'function') ? sssShareByMonthly(monthly) : 0;

        const pagibig    = +(regPay * piRate).toFixed(2);
        const philhealth = +(regPay * phRate).toFixed(2);
        const sssPer     = +(sssFull / div).toFixed(2);

        // RAW totals from storage (NOT divided) for editable columns
        const sssLoanRaw = +(Number((typeof loanSSS !== 'undefined' ? loanSSS?.[id] : 0)) || 0).toFixed(2);
        const piLoanRaw  = +(Number((typeof loanPI  !== 'undefined' ? loanPI?.[id]  : 0)) || 0).toFixed(2);
        const valeRaw    = +(Number((typeof vale   !== 'undefined' ? vale?.[id]   : 0)) || 0).toFixed(2);
        const wedValeRaw = +(Number((typeof valeWed!== 'undefined' ? valeWed?.[id]: 0)) || 0).toFixed(2);

        // Total per-period (loans contribute their per-period share here)
        const totalPer  = +(pagibig + philhealth + sssPer + (sssLoanRaw/div) + (piLoanRaw/div) + valeRaw + wedValeRaw).toFixed(2);

        rows.push([
          id, name,
          pagibig.toFixed(2),
          philhealth.toFixed(2),
          sssPer.toFixed(2),
          sssLoanRaw.toFixed(2),
          piLoanRaw.toFixed(2),
          valeRaw.toFixed(2),
          wedValeRaw.toFixed(2),
          totalPer.toFixed(2)
        ]);
      });

      const csv = rows.map(r => r.map(s => {
        s = String(s ?? '');
        return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
      }).join(',')).join('\n');

      const blob = new Blob([csv], {type:'text/csv'});
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'deductions.csv';
      document.body.appendChild(a); a.click(); a.remove();
    } catch(err){
      console.error('Export (Deductions) failed:', err);
      alert('Export failed. Please try again.');
    }
  }
});document.addEventListener('change', (e)=>{
  if(e.target && e.target.id === 'deductionsFileInput'){
    const file = e.target.files && e.target.files[0]; 
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        let rows = [];
        
        // Check if employeeList is available
        if (!employeeList || employeeList.length === 0) {
          alert('No employees found. Please add employees first in the Employees tab.');
          return;
        }
        
        console.log('Available employees:', employeeList.map(e => e.id));
        
        if (file.name.toLowerCase().endsWith('.csv')) {
          // Handle CSV files
          
          const text = String(e.target.result || '');
          // Robust CSV parsing with quoted field support
          rows = text.split(/\r?\n/).filter(line => line.trim().length>0).map(line => {
            const out = []; let cur = ''; let inQ = false;
            for (let i=0;i<line.length;i++){
              const ch = line[i]; const nx = line[i+1];
              if (ch === '"'){
                if (inQ && nx === '"'){ cur += '"'; i++; } 
                else { inQ = !inQ; }
              } else if (ch === ',' && !inQ){
                out.push(cur); cur = '';
              } else {
                cur += ch;
              }
            }
            out.push(cur);
            return out.map(cell => cell.trim());
          });
    } else {
          // Handle Excel files
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        }
        
        if (rows.length < 2) {
          alert('File must have at least a header row and one data row.');
          return;
        }
        
        // Process the data
        let updated = 0;
        let errors = [];
        
        console.log('Processing file with rows:', rows.length);
        console.log('First row (headers):', rows[0]);
        console.log('Second row (sample data):', rows[1]);
        
        
        // Map column indexes by header names to tolerate column reordering
        const header = rows[0].map(h => String(h).trim().toLowerCase());
        const idxId = header.indexOf('id');
        const idxName = header.indexOf('name');
        const idxSSSLoan = header.indexOf('sss loan');
        const idxPagibigLoan = header.indexOf('pag-ibig loan');
        const idxVale = header.indexOf('vale');
        const idxAccount = header.indexOf('account');
        const idxWedVale = header.indexOf('wed vale');
        const IDX = {
          id: idxId,
          name: idxName,
          sssloan: idxSSSLoan,
          pagibigloan: idxPagibigLoan,
          vale: (idxAccount >= 0 ? idxAccount : idxVale),
          wedvale: idxWedVale
        };
        if (IDX.id < 0) { alert('Upload missing column: id'); return; }
        if (IDX.sssloan < 0) { alert('Upload missing column: sss loan'); return; }
        if (IDX.pagibigloan < 0) { alert('Upload missing column: pag-ibig loan'); return; }
        if (IDX.vale < 0) { alert('Upload missing column: account (or vale)'); return; }
        if (IDX.wedvale < 0) { alert('Upload missing column: wed vale'); return; }
for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (row.length < 10) {
            console.log(`Row ${i} too short (${row.length} columns):`, row);
            continue;
          }
          
          const empId = String(row[0] || '').trim();
          
          // Only read the specific columns we need for loans and vales
          // Skip the calculated fields (Pag-IBIG, PhilHealth, SSS, Total Deductions)
          // Note: If name is split into 2 columns, adjust accordingly
          const sssLoan = parseFloat(row[IDX.sssloan]) || 0; const pagibigLoan = parseFloat(row[IDX.pagibigloan]) || 0; const valeVal = parseFloat(row[IDX.vale]) || 0; const wedValeVal = parseFloat(row[IDX.wedvale]) || 0;       // Column 9: Wed Vale (was 8)
          
          console.log(`Row ${i}: ID=${empId}, SSS Loan=${sssLoan}, Pag-IBIG Loan=${pagibigLoan}, Vale=${valeVal}, Wed Vale=${wedValeVal}`);
          
          if (!empId) continue;
          
          // Check if employee exists in employeeList
          const employeeExists = employeeList.some(emp => emp.id === empId);
          if (employeeExists) {
            // Update the loan and vale amounts
            loanPI[empId] = pagibigLoan;
            loanSSS[empId] = sssLoan;
            vale[empId] = valeVal;
            valeWed[empId] = wedValeVal;
            updated++;
            console.log(`Updated employee ${empId}:`, { pagibigLoan, sssLoan, vale: valeVal, wedVale: wedValeVal });
          } else {
            errors.push(`Employee ID ${empId} not found`);
            console.log(`Employee ${empId} not found in:`, employeeList.map(e => e.id));
          }
        }
        
        // Save to localStorage
        saveCurrentPeriodDeductions();
        
        // Refresh displays
        if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
        if (typeof renderTable === 'function') renderTable();
        
        // Show results
        let message = `Updated ${updated} employees.`;
        if (errors.length > 0) {
          message += `\n\nErrors:\n${errors.slice(0, 5).join('\n')}`;
          if (errors.length > 5) message += `\n...and ${errors.length - 5} more.`;
        }
        alert(message);
        
      } catch (err) { 
        console.error(err); 
        alert('Error reading file. Please check the file format.'); 
      } finally { 
        e.target.value = ''; 
      }
    };
    
    if (file.name.toLowerCase().endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  }
});
function renderTable(){
  syncPeriodScopedData();
  // Batch DOM updates to avoid MutationObserver thrash
  window.__suspendTotals = true;
  try {
    const frag = document.createDocumentFragment();
    tbody.innerHTML = '';
    employeeList.forEach(emp=>{
      const tr = document.createElement('tr');
      const rH = Number(regHours[emp.id] ?? 0);
      const oH = Number(otHours[emp.id] ?? 0);
      // Adjustment hours for this employee (default to 0 if undefined)
      const aH = Number(adjHrs[emp.id] ?? 0);
      const rate = Number((storedEmployees[emp.id]?.hourlyRate) ?? (payrollRates[emp.id] ?? 0));
      payrollRates[emp.id] = isNaN(rate) ? 0 : rate;
      const lSSS = Number(loanSSS[emp.id] ?? 0);
      const lPI = Number(loanPI[emp.id] ?? 0);
      const v = Number(vale[emp.id] ?? 0);
      const vW = Number(valeWed[emp.id] ?? 0);
      // Load stored Bantay allowance for this employee or default to empty string
      const bVal = bantay[emp.id] ?? '';
      tr.innerHTML = `
        <td>${emp.id}</td>
        <td class="wrap">${emp.name}</td>
        
        <td><input class="cell rate" title="Non-editable in Payroll" type="number" step="0.01" value="${rate}" disabled></td>
        <td><input class="cell regHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${rH}" disabled></td>
        <td><input class="cell otHrs" title="Non-editable in Payroll" type="number" step="0.01" value="${oH}" disabled></td>
        <td class="adjHrs num">${aH ? aH.toFixed(2) : '0.00'}</td><td class="totalHrs num">0.00</td><td class="regPay num">0.00</td>
        <td class="otPay num">0.00</td>
        <td class="adjAmt num">0.00</td>
        <td><input class="cell bantay" type="number" step="0.01" value="${bVal}"></td>
        <td class="grossPay num">0.00</td>
        <td class="pagibig num">0.00</td>
        <td class="philhealth num">0.00</td>
        <td class="sss num">0.00</td>
        <td><input class="cell loanSSS" type="number" step="0.01" value="${lSSS}"></td>
        <td><input class="cell loanPI" type="number" step="0.01" value="${lPI}"></td>
        <td><input class="cell vale" type="number" step="0.01" value="${v}"></td>
        <td class="valeWed num">${vW}</td>
        <td class="totalDed num">0.00</td>
        <td class="netPay num">0.00</td>
        <td><button type="button" class="payslipBtn">Payslip</button></td>`;
      frag.appendChild(tr);
    });
    tbody.appendChild(frag);
    attachRowEvents();
    // Compute all rows in one pass without updating totals each mutation
    calculateAll();
  } finally {
    // Resume totals and request one totals update after batch render
    window.__suspendTotals = false;
    try { (window.scheduleTotals || window.updatePayrollGrandTotals || function(){})(); } catch(e){}
    try { (window.scheduleTotals || window.updateDeductionsGrandTotals || function(){})(); } catch(e){}
  }
}



// Quick project picker for Bantay assignment (Supabase-backed) â€“ compact dropdown
// Shows only project names, auto-saves on selection, then closes.
function chooseBantayProject(empId, anchorEl){
  try{
    // Remove any existing picker first
    const old = document.getElementById('bantayProjPicker');
    if (old) old.remove();

    // Build overlay container
    const box = document.createElement('div');
    box.id = 'bantayProjPicker';
    box.style.position = 'absolute';
    box.style.zIndex = '99999';
    box.style.background = '#ffffff';
    box.style.border = '1px solid #e5e7eb';
    box.style.borderRadius = '8px';
    box.style.boxShadow = '0 8px 24px rgba(0,0,0,0.12)';
    box.style.padding = '6px';
    box.style.display = 'flex';
    box.style.gap = '6px';
    box.style.alignItems = 'center';

    // Position near the input
    const rect = (anchorEl && anchorEl.getBoundingClientRect) ? anchorEl.getBoundingClientRect() : {left:100, top:100, width:0, height:0};
    const scrollX = window.scrollX || document.documentElement.scrollLeft || 0;
    const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
    box.style.left = (rect.left + scrollX) + 'px';
    box.style.top  = (rect.top  + scrollY + rect.height + 6) + 'px';

    // Build <select> with project options (compact)
    const sel = document.createElement('select');
    sel.style.minWidth = '160px';
    sel.style.padding = '4px';
    sel.style.border = '1px solid #d1d5db';
    sel.style.borderRadius = '6px';

    // Placeholder + clear option
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = 'Select project';
    sel.appendChild(opt0);
    const optClear = document.createElement('option');
    optClear.value = '__clear__';
    optClear.textContent = '— Clear assignment —';
    sel.appendChild(optClear);

    // storedProjects: { [pid]: {name, ...} }
    const entries = Object.entries(storedProjects || {}).sort((a,b)=>{
      const A = (a[1]?.name || a[0]).toUpperCase();
      const B = (b[1]?.name || b[0]).toUpperCase();
      return A.localeCompare(B);
    });
    entries.forEach(([pid, proj])=>{
      const o = document.createElement('option');
      o.value = pid;
      o.textContent = (proj?.name || pid);
      sel.appendChild(o);
    });

    // Set current value if any (default to project id key)
    try { sel.value = (bantayProj && bantayProj[empId]) || ''; } catch(e){}

    box.appendChild(sel);
    document.body.appendChild(box);

    const close = ()=>{ try{ box.remove(); }catch(e){} };

    // Auto-save on selection and close; refresh report if available
    sel.addEventListener('change', async ()=>{
      const v = sel.value;
      bantayProj = bantayProj || {};
      if (!v || v === '__clear__'){
        // Clear assignment
        try { delete bantayProj[empId]; } catch(e){}
        try { await writeKV(LS_BANTAY_PROJ, bantayProj); } catch(e){}
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
        close();
        return;
      }
      if (storedProjects && storedProjects[v]){
        bantayProj[empId] = v;
        try { await writeKV(LS_BANTAY_PROJ, bantayProj); } catch(e){}
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
      }
      close();
    });

    // Close on outside click
    setTimeout(()=>{
      const handler = (e)=>{
        if (!box.contains(e.target)) {
          document.removeEventListener('mousedown', handler, true);
          close();
        }
      };
      document.addEventListener('mousedown', handler, true);
    }, 0);

  }catch(e){
    console.warn('chooseBantayProject failed', e);
  }
}
function attachRowEvents(){
  tbody.querySelectorAll('tr').forEach(row=>{
    const id = row.cells[0].textContent.trim();
    const regI = row.querySelector('.regHrs');
    const otI = row.querySelector('.otHrs');
    const rateI = row.querySelector('.rate');
    const lSSSI = row.querySelector('.loanSSS');
    const lPII = row.querySelector('.loanPI');
    const vI = row.querySelector('.vale');
    const vWI = row.querySelector('.valeWed');
    [regI, otI, rateI, lSSSI, lPII, vI, vWI].forEach(inp=>{
      inp.addEventListener('input', ()=>{
        regHours[id] = +(Number(regI.value)||0).toFixed(2);
        otHours[id] = +(Number(otI.value)||0).toFixed(2);
        payrollRates[id] = +(Number(rateI.value)||0).toFixed(2);
        loanSSS[id] = +(Number(lSSSI.value)||0).toFixed(2);
        loanPI[id] = +(Number(lPII.value)||0).toFixed(2);
        vale[id] = +(Number(vI.value)||0).toFixed(2);
        valeWed[id] = +(Number(vWI.value)||0).toFixed(2);
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
        localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
        saveCurrentPeriodDeductions();
        calculateRow(row);
      });
    });

    // Add event listener for Bantay allowance input. Store to cloud and recalc net pay.
    const bantayI = row.querySelector('.bantay');
      if (bantayI) {
        bantayI.addEventListener('input', async () => {
        bantay[id] = bantayI.value;
        allBantay[currentPeriodKey] = bantay;
        try { localStorage.setItem(LS_BANTAY, JSON.stringify(allBantay)); } catch(_){ }
        await writeKV(LS_BANTAY, allBantay);
        calculateRow(row);
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
        // Auto-open project picker when entering a positive amount and no assignment yet
        const val = parseFloat(bantayI.value) || 0;
        const hasPicker = !!document.getElementById('bantayProjPicker');
        if (val > 0 && !bantayProj[id] && !hasPicker) {
          chooseBantayProject(id, bantayI);
        }
        // Auto-clear assignment when reset to zero or blank
        if (!(val > 0) && bantayProj[id]) {
          try { delete bantayProj[id]; } catch(_){ }
          try { await writeKV(LS_BANTAY_PROJ, bantayProj); } catch(_){ }
          try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(_){ }
        }
      });
      // Also prompt on change if user typed and then blurs
      bantayI.addEventListener('change', () => {
        const val = parseFloat(bantayI.value) || 0;
        if (val > 0) chooseBantayProject(id, bantayI);
        try { if (typeof window.rebuildReports === 'function') window.rebuildReports(); } catch(e){}
      });
      // Allow quick reassign on dblclick
      bantayI.title = 'Double-click to assign Bantay to a project';
      bantayI.addEventListener('dblclick', () => chooseBantayProject(id, bantayI));
    }
  });
}
function renderSssTable(){
  const tbodyS = document.querySelector('#sssTable tbody');
  tbodyS.innerHTML='';
  const rows = getSssTable();
  rows.forEach((r, i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell sssMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell sssMax" value="${r.max}"></td>
      <td><input type="number" step="0.01" class="cell sssEmp" value="${r.employee}"></td>
      <td><button class="delRow">Delete</button></td>`;
    tbodyS.appendChild(tr);
    const minI = tr.querySelector('.sssMin');
    const maxI = tr.querySelector('.sssMax');
    const empI = tr.querySelector('.sssEmp');
    minI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    maxI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    empI.addEventListener('input', ()=>{ updateRow(i, minI, maxI, empI); });
    tr.querySelector('.delRow').addEventListener('click', ()=>{
      const cur = getSssTable();
      cur.splice(i,1);
      setSssTable(cur);
      renderSssTable();
      calculateAll();
    });
  });
}
function updateRow(i, minI, maxI, empI){
  const cur = getSssTable();
  cur[i] = {min:Number(minI.value)||0, max:Number(maxI.value)||0, employee:Number(empI.value)||0};
  setSssTable(cur);
  calculateAll();
}

document.getElementById('addSssRow').addEventListener('click', ()=>{
  const cur = getSssTable(); cur.push({min:0,max:0,employee:0}); setSssTable(cur); renderSssTable();
});
document.getElementById('resetSss').addEventListener('click', ()=>{
  if(confirm('Reset SSS table to 2025 defaults?')){
    const mapped = SSS_SEED_2025.map(r=>({min:r[0], max:r[1], employee:r[2]}));
    setSssTable(mapped);
    renderSssTable();
    calculateAll();
  }
});
document.getElementById('clearSss').addEventListener('click', ()=>{
  if(confirm('Clear all SSS ranges?')){ setSssTable([]); renderSssTable(); calculateAll(); }
});
document.getElementById('exportSss').addEventListener('click', ()=>{
  const rows = getSssTable();
  const csv = ['min,max,employeeShare'].concat(rows.map(r=>[r.min,r.max,r.employee].join(','))).join('\n');
  const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='sss_table.csv'; document.body.appendChild(a); a.click(); a.remove();
});
document.getElementById('importSss').addEventListener('change', ev=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const text = e.target.result;
    const lines = text.split(/\r?\n/).filter(Boolean);
    const out=[];
    for(let i=0;i<lines.length;i++){ const line = lines[i].trim();
      if(i===0 && /min/i.test(line) && /max/i.test(line)) continue;
      const p = line.split(',');
      if(p.length>=3) out.push({min:Number(p[0])||0,max:Number(p[1])||0,employee:Number(p[2])||0});
    }
    setSssTable(out); renderSssTable(); calculateAll();
  };
  reader.readAsText(f);
});

// === Begin Pagâ€‘IBIG and PhilHealth Table Management ===
// Pagâ€‘IBIG dynamic table helpers.  Defines helper functions for retrieving and
// setting the table in localStorage, rendering the table in the UI, and applying
// the employee share rate based on income ranges.
function getPagibigTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PAGIBIG_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPagibigTable(rows){
  localStorage.setItem(LS_PAGIBIG_TABLE, JSON.stringify(rows));
}
function renderPagibigTable(){
  const tbodyP = document.querySelector('#pagibigTable tbody');
  if(!tbodyP) return;
  tbodyP.innerHTML = '';
  const rows = getPagibigTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell pagibigMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell pagibigMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell pagibigRate" value="${r.rate}"></td>
      <td><button class="delPagibigRow">Delete</button></td>`;
    tbodyP.appendChild(tr);
    const minI = tr.querySelector('.pagibigMin');
    const maxI = tr.querySelector('.pagibigMax');
    const rateI = tr.querySelector('.pagibigRate');
    function update(i){
      const cur = getPagibigTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPagibigTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPagibigRow').addEventListener('click', () => {
      const cur = getPagibigTable();
      cur.splice(idx, 1);
      setPagibigTable(cur);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
function getPhilhealthTable(){
  let arr = [];
  try {
    arr = JSON.parse(localStorage.getItem(LS_PHILHEALTH_TABLE) || '[]');
  } catch(e) { arr = []; }
  if (!Array.isArray(arr)) arr = [];
  return arr.map(r => ({
    min: Number(r.min) || 0,
    max: Number(r.max) || 0,
    rate: Number(r.rate) || 0
  })).sort((a,b) => a.min - b.min);
}
function setPhilhealthTable(rows){
  localStorage.setItem(LS_PHILHEALTH_TABLE, JSON.stringify(rows));
}
function renderPhilhealthTable(){
  const tbodyPh = document.querySelector('#philhealthTable tbody');
  if(!tbodyPh) return;
  tbodyPh.innerHTML = '';
  const rows = getPhilhealthTable();
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.01" class="cell philMin" value="${r.min}"></td>
      <td><input type="number" step="0.01" class="cell philMax" value="${r.max}"></td>
      <td><input type="number" step="0.0001" class="cell philRate" value="${r.rate}"></td>
      <td><button class="delPhilRow">Delete</button></td>`;
    tbodyPh.appendChild(tr);
    const minI = tr.querySelector('.philMin');
    const maxI = tr.querySelector('.philMax');
    const rateI = tr.querySelector('.philRate');
    function update(i){
      const cur = getPhilhealthTable();
      cur[i] = {min: Number(minI.value) || 0, max: Number(maxI.value) || 0, rate: Number(rateI.value) || 0};
      setPhilhealthTable(cur);
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
    minI.addEventListener('input', () => update(idx));
    maxI.addEventListener('input', () => update(idx));
    rateI.addEventListener('input', () => update(idx));
    tr.querySelector('.delPhilRow').addEventListener('click', () => {
      const cur = getPhilhealthTable();
      cur.splice(idx, 1);
      setPhilhealthTable(cur);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    });
  });
}
// Click handler for adding, resetting and clearing rows in Pagâ€‘IBIG and PhilHealth tables.
document.addEventListener('click', (e) => {
  if (e.target && e.target.id === 'addPagibigRow') {
    const cur = getPagibigTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPagibigTable(cur);
    renderPagibigTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPagibig') {
    if (confirm('Reset Pag-IBIG table to defaults?')) {
      const mapped = PAGIBIG_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPagibigTable(mapped);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPagibig') {
    if (confirm('Clear all Pag-IBIG ranges?')) {
      setPagibigTable([]);
      renderPagibigTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'addPhilRow') {
    const cur = getPhilhealthTable();
    cur.push({min: 0, max: 0, rate: 0});
    setPhilhealthTable(cur);
    renderPhilhealthTable();
    calculateAll();
    if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
  } else if (e.target && e.target.id === 'resetPhil') {
    if (confirm('Reset PhilHealth table to defaults?')) {
      const mapped = PHILHEALTH_SEED.map(r => ({min: r[0], max: r[1], rate: r[2]}));
      setPhilhealthTable(mapped);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  } else if (e.target && e.target.id === 'clearPhil') {
    if (confirm('Clear all PhilHealth ranges?')) {
      setPhilhealthTable([]);
      renderPhilhealthTable();
      calculateAll();
      if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
    }
  }
});
// === End Pagâ€‘IBIG and PhilHealth Table Management ===
function sssShareByMonthly(monthly){
  const rows = getSssTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].employee)||0;
  for(const r of rows){ if(monthly >= r.min && monthly <= r.max) return Number(r.employee)||0; }
  return Number(rows[rows.length-1].employee)||0;
}

// Determine Pagâ€‘IBIG contribution rate based on the monthly income.  Uses the
// editable Pagâ€‘IBIG table; returns a decimal rate (e.g. 0.02).  If no matching
// range is found, returns the last row's rate.
function pagibigRateByMonthly(monthly){
  const rows = getPagibigTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

// Determine PhilHealth contribution rate based on the monthly income.  Uses the
// editable PhilHealth table; returns a decimal rate.  If no matching range is found,
// returns the last row's rate.
function philhealthRateByMonthly(monthly){
  const rows = getPhilhealthTable();
  if(rows.length===0) return 0;
  rows.sort((a,b)=>a.min-b.min);
  if(monthly <= rows[0].min) return Number(rows[0].rate)||0;
  for(const r of rows){
    if(monthly >= r.min && monthly <= r.max){
      return Number(r.rate)||0;
    }
  }
  return Number(rows[rows.length-1].rate)||0;
}

function calculateRow(tr){  const readNum = sel => { const el = tr.querySelector(sel); if (!el) return 0; const v = (typeof el.value !== 'undefined' ? el.value : el.textContent); const n = parseFloat(String(v).replace(/,/g,'')); return isNaN(n)?0:n; };
  const w = (sel, val) => { const el = tr.querySelector(sel); if (!el) return; el.textContent = (val===0 ? '-' : (+val).toFixed(2)); };


  const id = tr.cells[0].textContent.trim();
  const reg = Number(tr.querySelector('.regHrs').value)||0;
  const ot = Number(tr.querySelector('.otHrs').value)||0;
  // Adjustment hours from the adjHrs object (if any)
  const adjHours = Number(adjHrs[id] || 0);
  // Combined OT hours including adjustments
  const otTotal = ot + adjHours;
  const totalHrs = reg + ot + adjHours;
  const rate = Number(tr.querySelector('.rate').value)||0;
  const lSSS = Number(tr.querySelector('.loanSSS').value)||0;
  const lPI = Number(tr.querySelector('.loanPI').value)||0;
  const v = Number(tr.querySelector('.vale').value)||0;
  const vW = Number(readNum('.valeWed'))||0;

  // Adjustment amount for this employee (may be positive or negative)
  const adj = Number(adjustments[id] || 0);
  // Bantay allowance (treated as positive allowance).  Parse numeric value from bantay input.
  const bVal = parseFloat((tr.querySelector('.bantay')?.value || '').trim()) || 0;

  const regPay = +(reg * rate).toFixed(2);
  tr.querySelector('.totalHrs').textContent = totalHrs.toFixed(2);
  const otPay = +(otTotal * rate * (Number(otMultiplier)||0)).toFixed(2);
  const gross = +(regPay + otPay + adj + bVal).toFixed(2);
  // Compute contributions using dynamic tables (employee share).  Determine the
  // appropriate rate based on the monthly income and multiply by regular pay.
  const monthly = rate * 8 * 24;
  const piRate = pagibigRateByMonthly(monthly);
  const phRate = philhealthRateByMonthly(monthly);
  // Check per-employee contribution deduction flags; default to true if not set
  const flags = contribFlags[id] || {};
  const div = Number(divisor) || 1;
  const pagibig = (flags.pagibig !== false ? +((regPay * piRate)).toFixed(2) : 0);
  const philhealth = (flags.philhealth !== false ? +((regPay * phRate)).toFixed(2) : 0);
  const sssFull = sssShareByMonthly(monthly);
  const sss = (flags.sss !== false ? +(sssFull / div).toFixed(2) : 0);
  const sssLoan = +(lSSS / div).toFixed(2);
  const piLoan = +(lPI / div).toFixed(2);
  const valeAmt = v;
  const wedValeAmt = vW;

  const total = pagibig + philhealth + sss + sssLoan + piLoan + valeAmt + wedValeAmt;
  const net = gross - total;

  w('.regPay', regPay);
  w('.otPay', otPay);
  w('.grossPay', gross);
  w('.pagibig', pagibig);
  w('.philhealth', philhealth);
  w('.sss', sss);
  w('.totalDed', total);
  // Populate adjustment cell (if exists) and net pay
  if (tr.querySelector('.adjAmt')) {
    w('.adjAmt', adj);
  }
  // Update the displayed adjustment hours cell if present
  const adjHrsCell = tr.querySelector('.adjHrs'); if (adjHrsCell) { adjHrsCell.textContent = (adjHours===0 ? '-' : adjHours.toFixed(2)); }
  w('.netPay', net);
}

function calculateAll(){
  syncPeriodScopedData();
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=> calculateRow(tr));
  renderDeductionsTable();
}

// === Adjustments Tab ===
// Render the adjustments table listing all employees with an input field for manual adjustment amounts.
function renderAdjustmentsTable() {
  syncPeriodScopedData();
  const atbody = document.querySelector('#adjustmentsTable tbody');
  if (!atbody) return;
  atbody.innerHTML = '';
  employeeList.forEach(emp => {
    const id = emp.id;
    const name = emp.name;
    // Use existing adjustment amount (monetary) or empty string for display
    const val = adjustments[id] !== undefined ? adjustments[id] : '';
    // Use existing adjustment hours or empty string for display
    const hrs = adjHrs[id] !== undefined ? adjHrs[id] : '';
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${id}</td>
      <td class="wrap">${name}</td>
      <td><input type="number" step="0.01" class="adjInput" data-id="${id}" value="${val}" /></td>
      <td><input type="number" step="0.01" class="adjHrsInput" data-id="${id}" value="${hrs}" /></td>
    `;
    atbody.appendChild(tr);
  });
  // Attach input event listeners to persist changes and recalculate payroll
  // Monetary adjustments
  atbody.querySelectorAll('.adjInput').forEach(inp => {
    inp.addEventListener('input', () => {
      const empId = inp.getAttribute('data-id');
      const n = parseFloat(inp.value);
      if (!isNaN(n) && n !== 0) {
        // Round to 2 decimal places and store
        adjustments[empId] = +(n.toFixed(2));
      } else {
        // Remove the entry when zero or invalid
        delete adjustments[empId];
      }
      allAdjustments[currentPeriodKey] = adjustments;
      localStorage.setItem(LS_ADJ, JSON.stringify(allAdjustments));
      calculateAll();
      renderAdjustmentsFoot();
    });
  });
  // Adjustment hours
  atbody.querySelectorAll('.adjHrsInput').forEach(inp => {
    inp.addEventListener('input', () => {
      const empId = inp.getAttribute('data-id');
      const n = parseFloat(inp.value);
      if (!isNaN(n) && n !== 0) {
        // Round to 2 decimal places and store
        adjHrs[empId] = +(n.toFixed(2));
      } else {
        // Remove the entry when zero or invalid
        delete adjHrs[empId];
      }
      allAdjHrs[currentPeriodKey] = adjHrs;
      localStorage.setItem(LS_ADJ_HRS, JSON.stringify(allAdjHrs));
      calculateAll();
      renderAdjustmentsFoot();
    });
  });
  // Initialize totals for adjustments (amount and hours)
  renderAdjustmentsFoot();
}

// Compute and display the total of all adjustment amounts in the adjustments table footer.
function renderAdjustmentsFoot() {
  const amtCell = document.querySelector('#adjustmentsTableFoot [data-col="adjAmt"]');
  const hrsCell = document.querySelector('#adjustmentsTableFoot [data-col="adjHrs"]');
  if (!amtCell) return;
  // Sum monetary adjustments
  let totAmt = 0;
  Object.keys(adjustments || {}).forEach(k => {
    const v = Number(adjustments[k]) || 0;
    totAmt += v;
  });
  amtCell.textContent = totAmt.toFixed(2);
  // Sum adjustment hours
  if (hrsCell) {
    let totHrs = 0;
    Object.keys(adjHrs || {}).forEach(k => {
      const v = Number(adjHrs[k]) || 0;
      totHrs += v;
    });
    hrsCell.textContent = totHrs.toFixed(2);
  }
}

// Initialize the dynamic Pagâ€‘IBIG and PhilHealth rate input fields.  This function
// sets their values from the current global variables and attaches input
// listeners to persist changes to localStorage and recalculate payroll.
function initializeContributionRates() {
  const pagibigInput = document.getElementById('pagibigRateInput');
  if (pagibigInput) {
    // Set current value; show as decimal with 3 decimals
    pagibigInput.value = typeof pagibigRate === 'number' ? pagibigRate.toFixed(3) : '';
    pagibigInput.addEventListener('change', function() {
      let val = parseFloat(pagibigInput.value);
      if (!isNaN(val)) {
        // If user enters percent (e.g. 2), convert to decimal
        if (val > 1) val = val / 100;
        // Bound to 0â€“1
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        pagibigRate = val;
        localStorage.setItem(LS_PAGIBIG_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
  const philInput = document.getElementById('philhealthRateInput');
  if (philInput) {
    philInput.value = typeof philhealthRate === 'number' ? philhealthRate.toFixed(3) : '';
    philInput.addEventListener('change', function() {
      let val = parseFloat(philInput.value);
      if (!isNaN(val)) {
        if (val > 1) val = val / 100;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        philhealthRate = val;
        localStorage.setItem(LS_PHILHEALTH_RATE, String(val));
        calculateAll();
        updateContributionNote();
      }
    });
  }
}

// Update the contribution note in the payroll tab to reflect current rates.  It
// calculates percentages and updates the HTML of the element with id
// 'contribNote'.  Called after rate changes and on initial load.
function updateContributionNote() {
  const noteEl = document.getElementById('contribNote');
  if (!noteEl) return;
  const piPct = (pagibigRate * 100).toFixed(2);
  const phPct = (philhealthRate * 100).toFixed(2);
  noteEl.innerHTML = 'Pag-IBIG = Regular Pay &times; ' + piPct + '% (not divided), ' +
    'PhilHealth = Regular Pay &times; ' + phPct + '% (not divided), ' +
    'SSS = (Employee Share by Monthly Income) &divide; Divisor. SSS Loan and Pag-IBIG Loan are divided by the Divisor. Vales are manual (not divided).';
}
  document.getElementById('downloadPayrollCSV').addEventListener('click', ()=>{
  // Include Adjustments column before Bantay in payroll CSV export
  const header = ['Week Start','Week End','OT Multiplier','Divisor','ID','Name','Regular Hours','OT Hours','Hourly Rate','Regular Pay','OT Pay','Adjustments','Bantay','Gross Pay','Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Account','Wed Vale','Total Deductions','Net Pay'];
  const rows=[header];
  const ws = weekStartEl.value||''; const we = weekEndEl.value||''; const otm = String(otMultiplierEl.value||''); const div = String(divisorEl.value||'1');
  document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
    const tds = tr.querySelectorAll('td');
    const id = tds[0].textContent.trim(); const name = tds[1].textContent.trim();
    const regI = tr.querySelector('.regHrs'); const otI = tr.querySelector('.otHrs'); const rateI = tr.querySelector('.rate');
    const regPay = tr.querySelector('.regPay').textContent.trim();
    const otPay = tr.querySelector('.otPay').textContent.trim();
    const adj   = tr.querySelector('.adjAmt') ? tr.querySelector('.adjAmt').textContent.trim() : '';
    const bantayVal = tr.querySelector('.bantay').value;
    const grossPay = tr.querySelector('.grossPay').textContent.trim();
    const pagibig = tr.querySelector('.pagibig').textContent.trim();
    const philhealth = tr.querySelector('.philhealth').textContent.trim();
    const sss = tr.querySelector('.sss').textContent.trim();
    const lSSS = tr.querySelector('.loanSSS').value; const lPI = tr.querySelector('.loanPI').value;
    const v = tr.querySelector('.vale').value; const vW = tr.querySelector('.valeWed').value;
    const total = tr.querySelector('.totalDed').textContent.trim();
    const net   = tr.querySelector('.netPay').textContent.trim();
    rows.push([ws,we,otm,div,id,name,regI.value,otI.value,rateI.value,regPay,otPay,adj,bantayVal,grossPay,pagibig,philhealth,sss,lSSS,lPI,v,vW,total,net]);
  });
  const csv = rows.map(r=>r.map(s=>{
    s = String(s ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='payroll.csv'; document.body.appendChild(a); a.click(); a.remove();
});
renderTable();
renderSssTable();
renderAdjustmentsTable();
// Render new contribution tables and update the note
renderPagibigTable();
renderPhilhealthTable();
updateContributionNote();
    
  // Wire Project Totals CSV download button (global)
  if (document.getElementById('downloadProjectTotalsCSV')) {
    document.getElementById('downloadProjectTotalsCSV').addEventListener('click', exportProjectTotalsCSV);
  }
</script>

<!-- Modal report functionality for project totals -->
<script>
// Display a modal dialog with a detailed breakdown of a single project's totals.
// Takes a row object (result of computeProjectTotals) and builds a table of
// per-day hours per employee along with grand totals for regular hours, OT,
// total hours and gross pay. Uses the global weekStart/weekEnd inputs to
// construct the day labels. The modal is hidden by default and can be
// dismissed by clicking on the close button or outside the modal.
function showProjectReport(row) {
  if (!row || !row.breakdown || !row.breakdown.length) return;
  const modal = document.getElementById('projectReportModal');
  const content = document.getElementById('projectReportContent');
  if (!modal || !content) return;
  const wsEl = document.getElementById('weekStart');
  const weEl = document.getElementById('weekEnd');
  const startDate = wsEl && wsEl.value ? wsEl.value : '';
  const endDate = weEl && weEl.value ? weEl.value : '';
  // Helper to build a list of dates between start and end inclusive
  function dateRangeList(s, e) {
    const out = [];
    if (!s || !e) return out;
    const sd = new Date(s);
    const ed = new Date(e);
    for (let d = new Date(sd); d <= ed; d.setDate(d.getDate() + 1)) {
      out.push(new Date(d));
    }
    return out;
  }
  const days = dateRangeList(startDate, endDate);
  let html = '';
  html += '<h3 style="margin-top:0;">' + (row.project || 'Project') + ' (' + (startDate || '') + ' to ' + (endDate || '') + ')</h3>';
  html += '<div style="overflow-x:auto;">';
  html += '<table style="width:100%;border-collapse:collapse;margin-bottom:12px;">';
  html += '<thead><tr>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">ID</th>';
  html += '<th style="text-align:left;border:1px solid #e2e8f0;padding:4px;">Name</th>';
  days.forEach(function(dt) {
    const label = (dt.getMonth() + 1) + '/' + dt.getDate();
    html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + label + '</th>';
  });
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Hrs</th>';
  html += '<th style="text-align:right;border:1px solid #e2e8f0;padding:4px;">Total Amount</th>';
  html += '</tr></thead><tbody>';
  row.breakdown.forEach(function(emp) {
    html += '<tr>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.id || '') + '</td>';
    html += '<td style="text-align:left;border:1px solid #e2e8f0;padding:4px;">' + (emp.name || '') + '</td>';
    days.forEach(function(dt) {
      const key = dt.toISOString().slice(0, 10);
      const val = parseFloat((emp.perDay && emp.perDay[key]) || 0).toFixed(2);
      html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + val + '</td>';
    });
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.total || 0).toFixed(2)) + '</td>';
    html += '<td style="text-align:right;border:1px solid #e2e8f0;padding:4px;">' + (Number(emp.gross || 0).toFixed(2)) + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  html += '</div>';
  // Grand totals section
  html += '<div style="font-weight:600;">Grand Totals:</div>';
  html += '<table style="border-collapse:collapse;margin-top:4px;">';
  html += '<tr><td style="padding:4px;">Regular Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.reg || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">OT Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.ot || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Total Hours:</td><td style="padding:4px;text-align:right;">' + (Number(row.total || 0).toFixed(2)) + '</td></tr>';
  html += '<tr><td style="padding:4px;">Gross Amount:</td><td style="padding:4px;text-align:right;">' + ((row.gross != null) ? Number(row.gross).toFixed(2) : '0.00') + '</td></tr>';
  html += '</table>';
  content.innerHTML = html;
  modal.style.display = 'flex';
}
// Attach close handlers once DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('projectReportModal');
  const closeBtn = document.getElementById('closeProjectReport');
  if (closeBtn) closeBtn.addEventListener('click', function() { if (modal) modal.style.display = 'none'; });
  if (modal) modal.addEventListener('click', function(e) { if (e.target === modal) modal.style.display = 'none'; });
});
</script>

<!--
  Dashboard functionality
  This script defines utilities for managing payroll history snapshots. It is intentionally
  separated from the existing payroll logic to avoid altering core calculations.
  The dashboard allows users to select a date range, generate a snapshot of the current payroll table,
  lock it to prevent further edits, view past snapshots, download CSV versions, and compare (diff) two snapshots.
-->
<script>
// Print Payroll Report: generate a print-friendly view of the payroll table and open
// a new window for printing. Inputs are converted to plain text and the final
// payslip column is removed to preserve confidentiality.
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('printPayrollBtn');
  if (btn) btn.addEventListener('click', function(){
    const srcTable = document.getElementById('payrollTable');
    if (!srcTable) {
      alert('Payroll table is missing or empty.');
      return;
    }
    // Clone table so we can modify it without affecting the live DOM
    const clone = srcTable.cloneNode(true);
    // Remove the last column (Payslip) from thead, tbody and tfoot
    const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
    clone.querySelectorAll('thead tr').forEach(removeLastCell);
    clone.querySelectorAll('tbody tr').forEach(removeLastCell);
    clone.querySelectorAll('tfoot tr').forEach(removeLastCell);
    // Convert input fields to plain text within the cloned table
    // For loan inputs, show per-period share (divided by the divisor)
    clone.querySelectorAll('input').forEach(inp => {
      const td = inp.parentElement;
      const cls = inp.classList || { contains: () => false };
      const key = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
      const div = (typeof window !== 'undefined' && typeof window.divisor !== 'undefined' && Number(window.divisor)) || parseInt((localStorage && localStorage.getItem(key)) || '1', 10) || 1;
      if (cls.contains('loanSSS') || cls.contains('loanPI')) {
        const raw = parseFloat((inp.value || '').toString().replace(/,/g,'')) || 0;
        td.textContent = (raw / div).toFixed(2);
      } else {
        const val = (inp.value || inp.textContent || '').toString();
        td.textContent = val;
      }
    });
    // Replace numeric zeros with dashes in clone
    clone.querySelectorAll('td').forEach(function(td){
      if (td.querySelector('input')) return;
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (!raw) return;
      var num = parseFloat(raw);
      if (!isNaN(num) && num === 0) td.textContent = '-';
    });
    // Rename selected header labels for print-only
    (function(){
      function norm(s){ return String(s||'').replace(/\s+/g,' ').trim().toLowerCase(); }
      var map = new Map([
        ['regular hours','REG HRS'],
        ['ot hours','OT HRS'],
        ['adjustment hrs','ADJ HRS'],
        ['adjustments','ADJ'],
        ['total deductions','TOTAL DEDUC.']
      ]);
      clone.querySelectorAll('thead th').forEach(function(th){
        var key = norm(th.textContent);
        if (map.has(key)) th.textContent = map.get(key);
      });
    })();
    // Build a new window for printing
    const w = window.open('', '', 'width=900,height=700');
    if (!w) return;
    w.document.write('<html><head><meta charset="utf-8"><title>Payroll Report</title>');
    // Basic styles: borders and alignment
    w.document.write('<style>@page{size:letter landscape;margin:10mm} html,body{-webkit-print-color-adjust:exact;print-color-adjust:exact;width:11in;height:8.5in;margin:0} body{font-family:Arial,Helvetica,sans-serif;margin:0;} h2{margin:0 0 6px;font-size:16px} table{border-collapse:collapse;width:100%;table-layout:fixed} thead{display:table-header-group} tfoot{display:table-footer-group} th,td{border:1pt solid #000!important;border-style:solid!important;padding:4px;font-size:11px} table,th,td{border-color:#000!important;border-style:solid!important} th{background:#f1f5f9} td.num{text-align:right} th:nth-child(1),td:nth-child(1),th:nth-child(2),td:nth-child(2){text-align:left} tfoot td{font-weight:700;background:#fff7ed;border-top:2pt solid #000!important} #payrollTable{page-break-inside:auto} #payrollTable tr{page-break-inside:avoid;break-inside:avoid-page} #payrollTable th, #payrollTable td { white-space: nowrap !important; page-break-inside: avoid; } #payrollTable th:nth-child(1), #payrollTable td:nth-child(1) { width:30px; min-width:30px; } #payrollTable th:nth-child(2), #payrollTable td:nth-child(2) { width:150px; min-width:150px; } #payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width:60px; min-width:60px; } #payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width:60px; min-width:60px; } #payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width:60px; min-width:60px; } #payrollTable th:nth-child(6), #payrollTable td:nth-child(6) { width:60px; min-width:60px; } #payrollTable th:nth-child(7), #payrollTable td:nth-child(7) { width:60px; min-width:60px; } #payrollTable th:nth-child(8), #payrollTable td:nth-child(8) { width:60px; min-width:60px; } #payrollTable th:nth-child(9), #payrollTable td:nth-child(9) { width:60px; min-width:60px; } #payrollTable th:nth-child(10), #payrollTable td:nth-child(10) { width:60px; min-width:60px; } #payrollTable th:nth-child(11), #payrollTable td:nth-child(11) { width:60px; min-width:60px; } #payrollTable th:nth-child(12), #payrollTable td:nth-child(12) { width:60px; min-width:60px; } #payrollTable th:nth-child(13), #payrollTable td:nth-child(13) { width:60px; min-width:60px; } #payrollTable th:nth-child(14), #payrollTable td:nth-child(14) { width:60px; min-width:60px; } #payrollTable th:nth-child(15), #payrollTable td:nth-child(15) { width:60px; min-width:60px; } #payrollTable th:nth-child(16), #payrollTable td:nth-child(16) { width:60px; min-width:60px; } #payrollTable th:nth-child(17), #payrollTable td:nth-child(17) { width:60px; min-width:60px; } #payrollTable th:nth-child(18), #payrollTable td:nth-child(18) { width:60px; min-width:60px; } #payrollTable th:nth-child(19), #payrollTable td:nth-child(19) { width:60px; min-width:60px; } #payrollTable th:nth-child(20), #payrollTable td:nth-child(20) { width:50px; min-width:50px; } #payrollTable th:nth-child(21), #payrollTable td:nth-child(21) { width:75px; min-width:75px; }</style>');
    w.document.write('</head><body>');
    // Header with date range if available
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const startDate = ws && ws.value ? ws.value : '';
    const endDate = we && we.value ? we.value : '';
    if (startDate && endDate) {
      w.document.write('<div id="printWrap"><h2>Payroll Report (' + startDate + ' to ' + endDate + ')</h2>');
    } else {
      w.document.write('<div id="printWrap"><h2>Payroll Report</h2>');
    }
    w.document.write(clone.outerHTML);
    w.document.write('</div></body></html>');
    w.document.close();
    // Print without auto-scaling
    try {
      w.addEventListener('load', function(){
        try { safePrint(w); } catch(e){}
      }, { once: true });
    } catch(e) { try { safePrint(w); } catch(_){} }
    // Optionally close after printing (comment out if you don't want auto-close)
    // w.close();
  });
});
document.addEventListener('DOMContentLoaded', () => {
  // Key used to persist payroll history snapshots in localStorage
  const PAYROLL_HIST_KEY = 'payroll_hist';
  // Load existing history from localStorage or default to an empty array
  let payrollHistory;
  try {
    payrollHistory = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
    if (!Array.isArray(payrollHistory)) payrollHistory = [];
  } catch (err) {
    payrollHistory = [];
  }
  // Expose payrollHistory on the window so other scripts (like the Active Payroll dropdown) can
  // append to it directly. Without this, new snapshots added via custom UI would only update
  // localStorage and would not appear in the current session until a full page reload.
  window.payrollHistory = payrollHistory;
  // Grab references to dashboard elements
  // Use the global weekStart/weekEnd inputs instead of the removed dashStartDate/dashEndDate fields.
  const dashStart = document.getElementById('weekStart');
  const dashEnd = document.getElementById('weekEnd');
  const dashGenerateBtn = document.getElementById('dashGenerate');
  // The global lock button has been removed; per-row lock buttons are provided in the Active Payrolls table.
  const dashLockBtn = document.getElementById('dashLock');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const snapshotView = document.getElementById('snapshotView');
  const diffBtn = document.getElementById('diffBtn');

  // Reference to the Active Payrolls table body
  const activeTableBody = document.querySelector('#activePayrollTable tbody');

  /**
   * Render the active payrolls table.
   * Lists snapshots that are not yet locked with Edit and Lock actions.
   */
  window.renderActivePayrolls = function renderActivePayrolls() {
    if (!activeTableBody) return;
    activeTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      if (snap.locked) return;
      const tr = document.createElement('tr');
      // Build the Active Payroll row. Include Edit, Lock and Delete actions. Deleting
      // prompts confirmation and removes the snapshot from payrollHistory.
      tr.innerHTML = `
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>
          <button type="button" class="editActive" data-index="${index}">Edit</button>
          <button type="button" class="lockActive" data-index="${index}">Lock</button>
          <button type="button" class="deleteActive" data-index="${index}">Delete</button>
        </td>
      `;
      activeTableBody.appendChild(tr);
    });
  };

  // Delegate edit/lock actions on the Active Payrolls table
  activeTableBody && activeTableBody.addEventListener('click', async (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('editActive')) {
      // Set the global date range to the snapshot dates and switch to Payroll tab
      const wsEl = document.getElementById('weekStart');
      const weEl = document.getElementById('weekEnd');
      if (wsEl) wsEl.value = snap.startDate || '';
      if (weEl) weEl.value = snap.endDate || '';
      try {
        if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
        else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
      } catch (err) {}
      // Show the payroll panel
      try { showTab('payroll'); } catch (err) {}
    } else if (target.classList.contains('lockActive')) {
      // Lock this active payroll: update its snapshot and mark locked
      const startDate = snap.startDate;
      const endDate = snap.endDate;
      if (!startDate || !endDate) {
        alert('Invalid snapshot dates.');
        return;
      }
      const newSnap = await buildSnapshot(startDate, endDate);
      if (!newSnap) {
        alert('Payroll table is missing or empty.');
        return;
      }
      const json = JSON.stringify(newSnap);
      const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      const now = new Date().toISOString();
      snap.rows = newSnap.rows;
      snap.totals = newSnap.totals;
      snap.hash = hashHex;
      snap.lockedAt = now;
      snap.locked = true;
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      // Disable payroll and DTR editing via helper until date range changes
      disablePayrollInputs();
      const wsEl2 = document.getElementById('weekStart');
      const weEl2 = document.getElementById('weekEnd');
      // Mark date inputs as forced to prevent showTab from re-enabling prematurely
      if (wsEl2) wsEl2.dataset.forced = 'true';
      if (weEl2) weEl2.dataset.forced = 'true';
      function enableOnChange() {
        if (wsEl2) wsEl2.removeEventListener('change', enableOnChange);
        if (weEl2) weEl2.removeEventListener('change', enableOnChange);
        // Determine if the newly selected period is locked. If locked, keep
        // editing disabled; otherwise enable editing and clear forced flags.
        if (typeof checkAndToggleEditState === 'function') {
          checkAndToggleEditState();
        } else {
          enablePayrollInputs();
        }
      }
      if (wsEl2) wsEl2.addEventListener('change', enableOnChange);
      if (weEl2) weEl2.addEventListener('change', enableOnChange);
    } else if (target.classList.contains('deleteActive')) {
      // Delete active (unlocked) snapshot after confirmation
      if (!snap) return;
      const ok = confirm('Are you sure you want to delete this payroll snapshot? This action cannot be undone.');
      if (!ok) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
  });

  /**
   * Render the payroll history table.
   * Each snapshot row contains a checkbox for diffing, start/end dates, lock timestamp,
   * truncated hash, and action buttons for opening and downloading the snapshot.
   */
  window.renderHistory = function renderHistory() {
    if (!historyTableBody) return;
    historyTableBody.innerHTML = '';
    payrollHistory.forEach((snap, index) => {
      const tr = document.createElement('tr');
      // Build row HTML; note small hash display for brevity
      // Build the actions column depending on lock status. Only locked snapshots show Open/Unlock buttons.
      const actions = [];
      if (snap.locked) {
        actions.push(`<button type="button" class="openSnapshot" data-index="${index}">Open</button>`);
        actions.push(`<button type="button" class="exportAllTabs" data-index="${index}">Excel (All Tabs)</button>`);
        actions.push(`<button type="button" class="unlockSnapshot" data-index="${index}">Unlock</button>`);
        // For locked snapshots, show a disabled delete button to indicate it cannot be removed
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}" disabled>Delete</button>`);
      } else {
        // For unlocked snapshots, allow deletion
        actions.push(`<button type="button" class="deleteSnapshot" data-index="${index}">Delete</button>`);
      }
      // Always provide a download button
      actions.push(`<button type="button" class="downloadSnapshot" data-index="${index}">Download CSV</button>`);
      tr.innerHTML = `
        <td><input type="checkbox" class="diff-select" data-index="${index}"></td>
        <td>${snap.startDate || ''}</td>
        <td>${snap.endDate || ''}</td>
        <td>${snap.lockedAt ? new Date(snap.lockedAt).toLocaleString() : ''}</td>
        <td><span style="font-size:10px;">${snap.hash ? snap.hash.slice(0, 12) + '...' : ''}</span></td>
        <td>${actions.join(' ')}</td>
      `;
      historyTableBody.appendChild(tr);
    });
  };

  // Post-lock automation: print DTR, download Employees CSV, print Payroll, export Reports Excel
  window.runPostLockOutputs = function runPostLockOutputs(){
    // Only export one Excel workbook with all tabs (no prints or CSVs)
    try {
      if (typeof window.rebuildReports === 'function') window.rebuildReports();
      setTimeout(function(){ try { if (typeof window.exportExcelAllTabs === 'function') window.exportExcelAllTabs(); } catch(e){} }, 600);
    } catch(e){}
  };

  /**
   * Build a snapshot from the current payroll table. This captures all row values
   * and totals in a structured JSON object for persistence.
   */
  async function buildSnapshot(startDate, endDate) {
    const table = document.getElementById('payrollTable');
    if (!table) return null;
    const rows = [];
    table.querySelectorAll('tbody tr').forEach(row => {
      const data = {};
      data.id = (row.cells[0]?.textContent || '').trim();
      data.name = (row.cells[1]?.textContent || '').trim();
      // Helper to read numeric input or fallback text
      function readNum(sel, cellIndex) {
        const el = row.querySelector(sel);
        if (el) {
          // Prefer form control .value when available, else textContent
          const v = (typeof el.value !== 'undefined' && el.matches('input,select,textarea')) ? el.value : el.textContent;
          const num = parseFloat(String(v).replace(/,/g,''));
          if (!isNaN(num)) return num;
        }
        // Fallback to cell index text if selector not found or not numeric
        const cellVal = row.cells[cellIndex] && row.cells[cellIndex].textContent;
        const num2 = parseFloat(String(cellVal).replace(/,/g,''));
        return isNaN(num2) ? 0 : num2;
    }
      // Column index fallbacks aligned with current payrollTable structure
      // 0:ID, 1:Name, 2:Rate, 3:RegHrs, 4:OTHrs, 5:AdjHrs, 6:TotalHrs, 7:RegPay, 8:OTPay, 9:Adjustments,
      // 10:Bantay, 11:Gross, 12:Pag-IBIG, 13:PhilHealth, 14:SSS, 15:SSS Loan, 16:Pag-IBIG Loan,
      // 17:Vale, 18:Wed Vale, 19:Total Ded, 20:Net Pay, 21:Payslip
      data.rate = readNum('.rate', 2);
      data.regHrs = readNum('.regHrs', 3);
      data.otHrs = readNum('.otHrs', 4);
      data.adjHrs = readNum('.adjHrs', 5);
      data.totalHrs = readNum('.totalHrs', 6);
      data.regPay = readNum('.regPay', 7);
      data.otPay = readNum('.otPay', 8);
      data.adjAmt = readNum('.adjAmt', 9);
      data.bantay = readNum('.bantay', 10);
      data.grossPay = readNum('.grossPay', 11);
      data.pagibig = readNum('.pagibig', 12);
      data.philhealth = readNum('.philhealth', 13);
      data.sss = readNum('.sss', 14);
      data.loanSSS = readNum('.loanSSS', 15);
      data.loanPI = readNum('.loanPI', 16);
      data.vale = readNum('.vale', 17);
      data.valeWed = readNum('.valeWed', 18);
      data.totalDed = readNum('.totalDed', 19);
      data.netPay = readNum('.netPay', 20);
      // Capture DTR records for this employee within the selected date range. Stores an array of {date, times}
      try {
        /*
         * Use the inâ€‘memory storedRecords array (populated from Supabase) to
         * derive attendance for payroll exports.  Avoid reading from
         * localStorage so that stale browser caches do not leak into
         * crossâ€‘device exports.  The records array is filtered by the
         * current employee and date range, grouped by date, and then
         * converted into { date, times } objects for export.
         */
        const recs = Array.isArray(storedRecords) ? storedRecords : [];
        const start = startDate || '';
        const end = endDate || '';
        const empRecs = recs.filter(r => r && String(r.empId) === String(data.id) && (!start || r.date >= start) && (!end || r.date <= end));
        const grouped = {};
        empRecs.forEach(r => {
          if (!r || !r.date) return;
          const d = r.date;
          if (!grouped[d]) grouped[d] = [];
          if (r.time && !grouped[d].includes(r.time)) grouped[d].push(r.time);
        });
        const arr = [];
        Object.keys(grouped).sort().forEach(dateKey => {
          const times = grouped[dateKey].sort();
          arr.push({ date: dateKey, times });
        });
        data.dtrs = arr;
      } catch (e) {
        // ignore parse errors
      }
      rows.push(data);
    });
    // Read totals from footer
    const totals = {};
    const footRow = document.querySelector('#payrollTable tfoot tr');
    if (footRow) {
      footRow.querySelectorAll('[data-col]').forEach(td => {
        const key = td.dataset.col;
        totals[key] = parseFloat(td.textContent.trim()) || 0;
      });
    }
    return { startDate, endDate, rows, totals };
  }
  // Expose buildSnapshot globally so it can be called from other scripts
  window.buildSnapshot = buildSnapshot;

  /**
   * Disable payroll and DTR editing across the application. Once a payroll
   * period is locked, users should not be able to adjust hours, rates, or
   * manually enter or delete DTR entries for that period. This helper
   * centralizes the logic so both global and per-row lock actions can reuse
   * it. Date range controls and Generate/Lock buttons are also disabled.
   */
  function disablePayrollInputs() {
    // Disable all editable fields in the payroll table
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = true;
    });
    // Disable DTR inputs, buttons and selects (manual DTR, delete buttons, filters, etc.)
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = true;
    });
    // Additionally disable key DTR controls explicitly by ID. While the generic selector above
    // should catch most elements, some dynamically inserted controls (or those outside
    // #panelMain) may escape. Explicitly disabling them ensures search fields, date filters,
    // project dropdowns and import/export buttons cannot be used once locked. These IDs
    // correspond to the manual DTR workflow and DTR filtering controls.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','downloadCSV','fileInput','manualDtrBtn','printDtrBtn','clearData','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = true;
    });
    // Disable all select elements within the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = true;
    });
    // Disable any DTR delete buttons that may have been added
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = true;
    });

    // Add a locked class to the DTR panel to disable pointer events. This is a
    // visual and functional safeguard for cases where individual inputs might
    // get re-enabled by other scripts. The CSS defined above ensures
    // #panelMain.locked blocks all interaction with its contents.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.add('locked');
    // Also disable inputs and buttons within the manual DTR modal if it exists. The modal is not
    // nested under #panelMain, so we need to explicitly target it. Without this, users could
    // potentially enter a manual record even after locking by using the modal fields directly.
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = true;
    });
    // Disable dashboard date range inputs and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    const lockBtn = document.getElementById('dashLock');
    if (ws) ws.disabled = true;
    if (we) we.disabled = true;
    if (genBtn) genBtn.disabled = true;
    if (lockBtn) lockBtn.disabled = true;
  }
  // Expose helper globally so other scripts can disable editing
  window.disablePayrollInputs = disablePayrollInputs;

  /**
   * Re-enable payroll and DTR editing across the application. This should be
   * called when the user changes the date range after locking, or when a
   * snapshot is unlocked. It resets disabled fields and action buttons.
   */
  function enablePayrollInputs() {
    // Re-enable payroll table inputs
    document.querySelectorAll('#payrollTable input').forEach(inp => {
      inp.disabled = false;
    });
    // Re-enable DTR inputs, buttons and selects
    document.querySelectorAll('#panelMain input, #panelMain button, #panelMain select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable specific DTR controls by ID that were explicitly disabled in
    // disablePayrollInputs(). This ensures search, date filters, project filter,
    // and import/export controls become usable again when the payroll is unlocked
    // or the date range is changed.
    ['dtrSearchName','dtrDateFrom','dtrDateTo','dtrDateClear','filterProject','downloadCSV','fileInput','manualDtrBtn','printDtrBtn','clearData','dtrDateRangeFrom','dtrDateRangeTo'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = false;
    });
    // Re-enable selects in the results table (project and schedule selectors)
    document.querySelectorAll('#resultsTable select').forEach(sel => {
      sel.disabled = false;
    });
    // Re-enable any DTR delete buttons
    document.querySelectorAll('.dtr-del-btn').forEach(btn => {
      btn.disabled = false;
    });

    // Remove the locked class from the DTR panel so pointer events and
    // interaction are restored. When the user switches to an unlocked period or
    // explicitly unlocks a snapshot, this class must be removed.
    const pm = document.getElementById('panelMain');
    if (pm) pm.classList.remove('locked');
    // Re-enable manual DTR modal fields and buttons. When a payroll is unlocked or the date
    // range changes, users should be able to enter manual DTR entries again. This undoes the
    // disablement applied in disablePayrollInputs().
    document.querySelectorAll('#manualDtrModal input, #manualDtrModal button, #manualDtrModal select').forEach(el => {
      el.disabled = false;
    });
    // Re-enable dashboard date range and action buttons
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const genBtn = document.getElementById('dashGenerate');
    const lockBtn = document.getElementById('dashLock');
    if (ws) ws.disabled = false;
    if (we) we.disabled = false;
    if (genBtn) genBtn.disabled = false;
    if (lockBtn) lockBtn.disabled = false;
  }
  // Expose helper globally so other scripts can enable editing
  window.enablePayrollInputs = enablePayrollInputs;

  /**
   * Determine whether the currently selected payroll period (weekStart/weekEnd values)
   * corresponds to a locked snapshot. This reads from the global payrollHistory
   * array if available, otherwise loads history from localStorage. It returns
   * true if a matching snapshot exists and its `locked` property is truthy.
   */
  function isSelectedPeriodLocked() {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (!wsEl || !weEl) return false;
    const start = wsEl.value;
    const end = weEl.value;
    // Helper to parse either ISO (yyyy-mm-dd) or US (m/d/yyyy) date strings
    function parseDateStr(str) {
      if (!str) return null;
      // If contains dash, assume ISO format yyyy-mm-dd or yyyy-m-d
      if (str.includes('-')) {
        const isoParts = str.split('-');
        if (isoParts.length === 3) {
          const y = parseInt(isoParts[0], 10);
          const m = parseInt(isoParts[1], 10);
          const d = parseInt(isoParts[2], 10);
          if (!isNaN(y) && !isNaN(m) && !isNaN(d)) {
            return new Date(y, m - 1, d);
          }
        }
        // Fallback: let Date constructor try parsing
        const dt = new Date(str);
        return isNaN(dt.getTime()) ? null : dt;
      }
      // If contains slash, assume m/d/yyyy or mm/dd/yyyy
      if (str.includes('/')) {
        const parts = str.split('/');
        if (parts.length === 3) {
          const m = parseInt(parts[0], 10);
          const d = parseInt(parts[1], 10);
          const y = parseInt(parts[2], 10);
          if (!isNaN(m) && !isNaN(d) && !isNaN(y)) {
            return new Date(y, m - 1, d);
          }
        }
      }
      // Final attempt: parse using Date constructor
      const dt2 = new Date(str);
      return isNaN(dt2.getTime()) ? null : dt2;
    }
    const startDateObj = parseDateStr(start);
    const endDateObj = parseDateStr(end);
    if (!startDateObj || !endDateObj) return false;
    // Use the in-memory payrollHistory if available; else load from storage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : (typeof loadHistory === 'function' ? loadHistory() : []);
    if (!Array.isArray(hist)) return false;
    return hist.some(s => {
      if (!s || !s.startDate || !s.endDate) return false;
      // Parse snapshot dates similarly; handle leading zero differences
      const sStart = parseDateStr(s.startDate);
      const sEnd = parseDateStr(s.endDate);
      if (!sStart || !sEnd) return false;
      return s.locked && sStart.getTime() === startDateObj.getTime() && sEnd.getTime() === endDateObj.getTime();
    });
  }
  window.isSelectedPeriodLocked = isSelectedPeriodLocked;

  /**
   * Check the current payroll period and toggle editing state accordingly. If the
   * selected period is locked, all payroll/DTR inputs are disabled and the
   * date inputs are marked as forced. If the period is not locked, editing is
   * enabled and the forced flags are removed. This helper centralizes the
   * logic of determining lock status and applying the appropriate UI state.
   */
  function checkAndToggleEditState() {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (!wsEl || !weEl) return;
    const locked = isSelectedPeriodLocked();
    if (locked) {
      disablePayrollInputs();
      // Mark inputs as forced so other logic (showTab) doesn't re-enable them
      wsEl.dataset.forced = 'true';
      weEl.dataset.forced = 'true';
    } else {
      enablePayrollInputs();
      if (wsEl.dataset) delete wsEl.dataset.forced;
      if (weEl.dataset) delete weEl.dataset.forced;
    }
  }
  window.checkAndToggleEditState = checkAndToggleEditState;

  /**
   * Convert a snapshot into a CSV string. Header names correspond to payroll columns.
   */
  function snapshotToCSV(snap) {
    // Mirror the payroll grid ordering, including adjustment/total hours and Bantay
    const header = [
      'ID','Name','Hourly Rate','Regular Hours','OT Hours','Adjustment Hours','Total Hours',
      'Regular Pay','OT Pay','Adjustments','Bantay','Gross Pay',
      'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale',
      'Total Deductions','Net Pay'
    ];
    const lines = [header.join(',')];
    snap.rows.forEach(row => {
      const values = [
        row.id, row.name,
        row.rate, row.regHrs, row.otHrs, row.adjHrs, row.totalHrs,
        row.regPay, row.otPay, row.adjAmt, row.bantay, row.grossPay,
        row.pagibig, row.philhealth, row.sss,
        row.loanSSS, row.loanPI, row.vale, row.valeWed,
        row.totalDed, row.netPay
      ];
      lines.push(values.map(v => {
        const s = String(v ?? '');
        return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
      }).join(','));
    });
    return lines.join('\n');
  }

  // Persist payrollHistory to localStorage
  function saveHistory() {
    localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(payrollHistory));
  }
  // Expose saveHistory globally so it can be called from other scripts
  window.saveHistory = saveHistory;

  // Handler for Generate button: build and save a snapshot without locking
  dashGenerateBtn && dashGenerateBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Prevent duplicate snapshots for the same date range. If any snapshot (locked or active)
    // already exists with this start/end, alert the user and skip creation. This avoids
    // doubleâ€‘entry payroll for the same period.
    const exists = Array.isArray(payrollHistory) && payrollHistory.some(snap =>
      snap && snap.startDate === start && snap.endDate === end);
    if (exists) {
      alert('A payroll snapshot for this date range already exists. Please choose a different range or delete the existing entry.');
      return;
    }
    // Ensure all payroll values are recalculated before taking a snapshot for generation
    try {
      if (typeof calculateAll === 'function') {
        calculateAll();
      }
    } catch (e) {
      // Suppress errors from calculateAll; snapshot will reflect current cell values
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false });
    saveHistory();
    // Update both history and active payroll tables after creating a new snapshot
    renderHistory();
    if (typeof renderActivePayrolls === 'function') renderActivePayrolls();
  });

  // Handler for Lock button: build snapshot, mark locked and disable payroll editing
  dashLockBtn && dashLockBtn.addEventListener('click', async () => {
    const start = dashStart && dashStart.value;
    const end = dashEnd && dashEnd.value;
    if (!start || !end) {
      alert('Please select both start and end dates.');
      return;
    }
    // Recompute all payroll row values prior to building the snapshot. Without this
    // call, some columns (e.g. contributions, total deductions, adjustments and
    // net pay) may not be up to date if the user has edited values but not
    // triggered a recalculation. Ensuring calculateAll() runs here fills all
    // numeric columns before locking.
    try {
      if (typeof calculateAll === 'function') {
        calculateAll();
      }
    } catch (e) {
      // Ignore errors in calculation; snapshot will still be built from current cells
    }
    const snap = await buildSnapshot(start, end);
    if (!snap) {
      alert('Payroll table is missing or empty.');
      return;
    }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    payrollHistory.push({ startDate: start, endDate: end, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: true });
    saveHistory();
    renderHistory();
    // Disable payroll and DTR editing via helper until date range changes
    disablePayrollInputs();
    // Mark date inputs as forced so showTab logic doesn't re-enable them prematurely
    if (dashStart) dashStart.dataset.forced = 'true';
    if (dashEnd) dashEnd.dataset.forced = 'true';
    // Listener to re-enable controls on date change
    function enableOnChange() {
      if (dashStart) dashStart.removeEventListener('change', enableOnChange);
      if (dashEnd) dashEnd.removeEventListener('change', enableOnChange);
      // Check the new period and toggle edit state accordingly. If the new
      // selection is locked, keep editing disabled; otherwise enable it.
      if (typeof checkAndToggleEditState === 'function') {
        checkAndToggleEditState();
      } else {
        enablePayrollInputs();
        if (dashStart && dashStart.dataset) delete dashStart.dataset.forced;
        if (dashEnd && dashEnd.dataset) delete dashEnd.dataset.forced;
      }
    }
    if (dashStart) dashStart.addEventListener('change', enableOnChange);
    if (dashEnd) dashEnd.addEventListener('change', enableOnChange);
  });

  // Delegate open/download actions on history table
  historyTableBody && historyTableBody.addEventListener('click', (e) => {
    const target = e.target;
    if (!target) return;
    const idxStr = target.dataset.index;
    if (typeof idxStr === 'undefined') return;
    const idx = parseInt(idxStr, 10);
    const snap = payrollHistory[idx];
    if (!snap) return;
    if (target.classList.contains('openSnapshot')) {
      // Only allow opening locked snapshots
      if (!snap.locked) return;
      // Render the snapshot in a dedicated detail view with DTR breakdown
      if (typeof showSnapshotDetails === 'function') {
        showSnapshotDetails(idx);
      }
    }
    if (target.classList.contains('exportAllTabs')) {
      // Export the All Tabs Excel for this snapshot's date range
      try {
        if (typeof window.exportExcelAllTabsForRange === 'function') {
          window.exportExcelAllTabsForRange(snap.startDate, snap.endDate);
        } else if (typeof window.exportExcelAllTabs === 'function') {
          // Fallback: set range, rebuild, then export
          const ws = document.getElementById('weekStart');
          const we = document.getElementById('weekEnd');
          const prevS = ws && ws.value; const prevE = we && we.value;
          if (ws) ws.value = snap.startDate || prevS; if (we) we.value = snap.endDate || prevE;
          try{ if (typeof calculatePayrollFromResultsTable==='function') calculatePayrollFromResultsTable(); else if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); }catch(e){}
          try{ if (typeof window.rebuildReports === 'function') window.rebuildReports(); }catch(e){}
          setTimeout(function(){
            try{ window.exportExcelAllTabs(); }catch(e){}
            // Restore previous range and rebuild
            setTimeout(function(){
              try{ if (ws) ws.value = prevS; if (we) we.value = prevE; if (typeof window.rebuildReports==='function') window.rebuildReports(); }catch(e){}
            }, 0);
          }, 300);
        }
      } catch(e){}
      return;
    }
    if (target.classList.contains('deleteSnapshot')) {
      // Delete a snapshot from history if it is not locked
      if (snap.locked) return; // Skip deletion for locked snapshots
      const confirmDel = confirm('Are you sure you want to delete this payroll record? This cannot be undone.');
      if (!confirmDel) return;
      payrollHistory.splice(idx, 1);
      saveHistory();
      renderHistory();
      renderActivePayrolls();
      return;
    }
    if (target.classList.contains('unlockSnapshot')) {
      // Unlock this locked snapshot: mark as unlocked and remove timestamp
      if (!snap.locked) return;
      snap.locked = false;
      snap.lockedAt = '';
      saveHistory();
      renderHistory();
      renderActivePayrolls();
    }
    if (target.classList.contains('downloadSnapshot')) {
      const csv = snapshotToCSV(snap);
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `payroll_${snap.startDate}_${snap.endDate}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  });

  // Compare two snapshots and display net pay differences
  diffBtn && diffBtn.addEventListener('click', () => {
    const selected = Array.from(document.querySelectorAll('.diff-select')).filter(cb => cb.checked);
    if (selected.length !== 2) {
      alert('Please select exactly two snapshots to compare.');
      return;
    }
    const idx1 = parseInt(selected[0].dataset.index, 10);
    const idx2 = parseInt(selected[1].dataset.index, 10);
    const s1 = payrollHistory[idx1];
    const s2 = payrollHistory[idx2];
    if (!s1 || !s2) return;
    const map1 = {};
    s1.rows.forEach(r => { map1[r.id] = r; });
    const map2 = {};
    s2.rows.forEach(r => { map2[r.id] = r; });
    const allIds = new Set([...Object.keys(map1), ...Object.keys(map2)]);
    if (snapshotView) snapshotView.innerHTML = '';
    const table = document.createElement('table');
    table.style.borderCollapse = 'collapse';
    table.style.width = '100%';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['ID','Name',`Net (${s1.startDate} - ${s1.endDate})`,`Net (${s2.startDate} - ${s2.endDate})`,'Difference'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    allIds.forEach(id => {
      const r1 = map1[id] || {};
      const r2 = map2[id] || {};
      const name = r2.name || r1.name || '';
      const net1 = parseFloat(r1.netPay) || 0;
      const net2 = parseFloat(r2.netPay) || 0;
      const diff = (net2 - net1).toFixed(2);
      const tr = document.createElement('tr');
      [id, name, net1.toFixed(2), net2.toFixed(2), diff].forEach((val, i) => {
        const td = document.createElement('td');
        td.textContent = val;
        td.style.border = '1px solid #e2e8f0';
        td.style.padding = '4px';
        if (i >= 2) td.style.textAlign = 'right';
        tr.appendChild(td);
      });
      // Highlight difference cell
      const diffVal = parseFloat(diff);
      const diffCell = tr.children[4];
      if (diffVal > 0) diffCell.style.background = '#dcfce7';
      else if (diffVal < 0) diffCell.style.background = '#fee2e2';
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    if (snapshotView) snapshotView.appendChild(table);
  });

  // Initial render on page load
  renderHistory();
  if (typeof renderActivePayrolls === 'function') renderActivePayrolls();

  /**
   * Display a locked payroll snapshot in a dedicated detail view. This hides the dashboard
   * tables and shows a new section with a summary of the payroll and a breakdown of the
   * DTR (time entries) per employee for the period. A Back button restores the dashboard.
   * @param {number} index Index of the snapshot in payrollHistory
   */
  window.showSnapshotDetails = function showSnapshotDetails(index) {
    const snap = Array.isArray(payrollHistory) ? payrollHistory[index] : null;
    if (!snap) return;
    // Grab key dashboard elements
    const activeTable = document.getElementById('activePayrollTable');
    const historyTable = document.getElementById('historyTable');
    const diffButton = document.getElementById('diffBtn');
    const snapshotViewEl = document.getElementById('snapshotView');
    const detailScreen = document.getElementById('snapshotDetailsScreen');
    const backBtn = document.getElementById('snapshotBackButton');
    const titleEl = document.getElementById('snapshotDetailTitle');
    const payrollContainer = document.getElementById('snapshotPayrollContainer');
    const dtrContainer = document.getElementById('snapshotDTRContainer');
    if (!detailScreen || !payrollContainer || !dtrContainer) return;
    // Determine headers for hiding/showing (h4 elements preceding tables)
    const activeHeader = activeTable && activeTable.previousElementSibling;
    const histHeader = historyTable && historyTable.previousElementSibling;
    // Set title with lock info
    if (titleEl) {
      const lockedInfo = snap.lockedAt ? ` (Locked ${new Date(snap.lockedAt).toLocaleString()})` : '';
      titleEl.textContent = `Payroll Details: ${snap.startDate || ''} - ${snap.endDate || ''}${lockedInfo}`;
    }
    // Hide dashboard tables and controls
    if (activeTable) activeTable.style.display = 'none';
    if (activeHeader && activeHeader.tagName === 'H4') activeHeader.style.display = 'none';
    if (historyTable) historyTable.style.display = 'none';
    if (histHeader && histHeader.tagName === 'H4') histHeader.style.display = 'none';
    if (diffButton) diffButton.style.display = 'none';
    if (snapshotViewEl) snapshotViewEl.style.display = 'none';
    // Build payroll summary table
    payrollContainer.innerHTML = '';
    const payTable = document.createElement('table');
    payTable.style.borderCollapse = 'collapse';
    payTable.style.width = '100%';
    const pHead = document.createElement('thead');
    const pRow = document.createElement('tr');
    // Define the headers for the payroll summary table. Include an Adjustments
    // column so that any manual adjustments saved in the snapshot are visible
    // when viewing a locked payroll. This keeps the summary in sync with the
    // CSV export and ensures the net pay is clearly explained.
    // Display columns similar to the live payroll grid (omit Total Deductions per request)
      const headers = [
        'ID','Name','Hourly Rate','Regular Hrs','OT Hrs','Adjustment Hrs','Total Hours',
        'Reg Pay','OT Pay','Adjustments','Bantay','Gross',
        'Pag-IBIG','PhilHealth','SSS','SSS Loan','Pag-IBIG Loan','Vale','Wed Vale',
        'Net Pay'
      ];
    headers.forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      pRow.appendChild(th);
    });
    pHead.appendChild(pRow);
    payTable.appendChild(pHead);
    const pBody = document.createElement('tbody');
    // Running grand totals (match Payroll semantics; loans are per-period shares)
      let GT = {
        regHrs:0, otHrs:0, adjHrs:0, totalHrs:0,
        regPay:0, otPay:0, adjAmt:0, bantay:0, gross:0,
        pagibig:0, philhealth:0, sss:0,
        loanSSS:0, loanPI:0, vale:0, wedVale:0,
        netPay:0
      };
    // Each employee row in the snapshot may include an adjAmt property
    // representing manual adjustments. Build the table row accordingly.
    (snap.rows || []).forEach(r => {
      const tr = document.createElement('tr');
      const num = (x)=>{ const n = parseFloat(String(x??'').replace(/,/g,'')); return isNaN(n)?0:n; };
      // Current divisor and OT multiplier
      const keyDiv = (typeof LS_DIVISOR !== 'undefined' ? LS_DIVISOR : 'payroll_deduction_divisor');
      const curDiv = (typeof window !== 'undefined' && typeof window.divisor !== 'undefined' && Number(window.divisor)) || parseInt((localStorage && localStorage.getItem(keyDiv)) || '1', 10) || 1;
      const otMultLS = parseFloat((typeof LS_OTMULT !== 'undefined' && localStorage && localStorage.getItem(LS_OTMULT)) || '1.5') || 1.5;
      const otMult = num(document.getElementById('otMultiplier')?.value || otMultLS) || 1.5;
      // Raw fields from snapshot
      const id = r.id;
      const rate = num(r.rate);
      const regHrs = num(r.regHrs);
      const otHrs = num(r.otHrs);
      const adjHrs = num(r.adjHrs);
      const totalHrs = num(r.totalHrs) || (regHrs + otHrs + adjHrs);
      // Recompute pays from hours/rate using current OT multiplier to match Payroll tab exactly
      let regPay = +(regHrs * rate).toFixed(2);
      const otTotal = otHrs + adjHrs;
      let otPay  = +(otTotal * rate * otMult).toFixed(2);
      let gross  = +(regPay + otPay).toFixed(2);
      let pagibig = num(r.pagibig);
      let philhealth = num(r.philhealth);
      let sss = num(r.sss);
      const loanSSSRaw = num(r.loanSSS);
      const loanPIRaw  = num(r.loanPI);
      const vale = num(r.vale);
      const wedVale = num(r.valeWed);
      const adjAmt = num(r.adjAmt);
      const bantay = num(r.bantay);

      // Heuristic: if snapshot has truncated values (e.g., 2.00 due to commas), recompute using current rules
      // 'looksWrong' heuristic no longer needed since we recompute unconditionally

      // Always recompute contributions with current tables (apply divisor only to SSS)
      try{
        const monthly = rate * 8 * 24;
        const flags = (typeof contribFlags !== 'undefined' && contribFlags[id]) || {};
        const piRate = (typeof pagibigRateByMonthly==='function') ? pagibigRateByMonthly(monthly) : 0;
        const phRate = (typeof philhealthRateByMonthly==='function') ? philhealthRateByMonthly(monthly) : 0;
        pagibig    = (flags.pagibig !== false   ? +((regPay * piRate)).toFixed(2) : 0);
        philhealth = (flags.philhealth !== false? +((regPay * phRate)).toFixed(2) : 0);
        const sssFull = (typeof sssShareByMonthly==='function') ? sssShareByMonthly(monthly) : 0;
        sss = (flags.sss !== false ? +(sssFull / curDiv).toFixed(2) : 0);
      }catch(e){}

      // Loans in snapshot view should reflect per-period share per user request
      const loanSSSPer = +(loanSSSRaw / curDiv).toFixed(2);
      const loanPIPer  = +(loanPIRaw  / curDiv).toFixed(2);

      // Compute net pay consistent with Payroll tab
      const totalDeds = pagibig + philhealth + sss + loanSSSPer + loanPIPer + vale + wedVale;
      const netPay = +(gross - totalDeds + adjAmt + bantay).toFixed(2);

        const vals = [
          id, r.name, rate, regHrs, otHrs, adjHrs, totalHrs,
          regPay, otPay, adjAmt, bantay, gross,
          pagibig, philhealth, sss,
          loanSSSPer, loanPIPer, vale, wedVale,
          netPay
        ];
      // Accumulate grand totals
      GT.regHrs     += regHrs;
      GT.otHrs      += otHrs;
      GT.adjHrs     += adjHrs;
      GT.totalHrs   += totalHrs;
        GT.regPay     += regPay;
        GT.otPay      += otPay;
        GT.adjAmt     += adjAmt;
        GT.bantay     += bantay;
        GT.gross      += gross;
      GT.pagibig    += pagibig;
      GT.philhealth += philhealth;
      GT.sss        += sss;
      GT.loanSSS    += loanSSSPer;
      GT.loanPI     += loanPIPer;
      GT.vale       += vale;
        GT.wedVale    += wedVale;
        GT.netPay     += netPay;

      vals.forEach(v => {
        const td = document.createElement('td');
        let text = '';
        if (v != null && v !== '') {
          const n = parseFloat(String(v).replace(/,/g,''));
          if (!isNaN(n) && isFinite(n)) {
            text = n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          } else {
            text = v;
          }
        }
        td.textContent = text;
        td.style.border = '1px solid #e2e8f0';
        td.style.padding = '4px';
        const nTest = parseFloat(String(text).replace(/,/g,''));
        td.style.textAlign = (!isNaN(nTest) && isFinite(nTest)) ? 'right' : 'left';
        tr.appendChild(td);
      });
      pBody.appendChild(tr);
    });
    payTable.appendChild(pBody);
    // Add Grand Totals footer row
    const pFoot = document.createElement('tfoot');
    const ft = document.createElement('tr');
    const label = document.createElement('td');
    label.colSpan = 3; // ID + Name + Hourly Rate
    label.textContent = 'Grand Total';
    label.style.fontWeight = '700';
    label.style.border = '1px solid #e2e8f0';
    label.style.padding = '4px';
    ft.appendChild(label);
      const cells = [
        GT.regHrs, GT.otHrs, GT.adjHrs, GT.totalHrs,
        GT.regPay, GT.otPay, GT.adjAmt, GT.bantay, GT.gross,
        GT.pagibig, GT.philhealth, GT.sss,
        GT.loanSSS, GT.loanPI, GT.vale, GT.wedVale,
        GT.netPay
      ];
    cells.forEach(n => {
      const td = document.createElement('td');
      const val = Number(n) || 0;
      td.textContent = val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      td.style.border = '1px solid #e2e8f0';
      td.style.padding = '4px';
      td.style.textAlign = 'right';
      ft.appendChild(td);
    });
    pFoot.appendChild(ft);
    payTable.appendChild(pFoot);
    payrollContainer.appendChild(payTable);
    // Build DTR breakdown
    dtrContainer.innerHTML = '';
    // Build DTR data for display. If the snapshot rows include a dtrs array
    // (captured when the payroll was locked), use it directly so that the
    // attendance shown reflects the state at locking time. Otherwise, fall
    // back to reading the current att_records_v2 from localStorage for
    // backward compatibility with snapshots created before this feature was
    // implemented.
    let dtrRows = [];
    let useSnapDtrs = false;
    (snap.rows || []).forEach(empRow => {
      if (Array.isArray(empRow.dtrs) && empRow.dtrs.length) {
        useSnapDtrs = true;
      }
    });
    if (useSnapDtrs) {
      // Use the stored dtrs directly from each employee row
      (snap.rows || []).forEach(empRow => {
        const id = empRow.id;
        const name = empRow.name || '';
        (empRow.dtrs || []).forEach(d => {
          dtrRows.push({ id, name, date: d.date, times: d.times || [] });
        });
      });
    } else {
      // Fallback: derive from live attendance records within the snapshot date range
      // Use the inâ€‘memory storedRecords array rather than localStorage.  If no
      // remote data exists the array will be empty, which is preferable to
      // reading stale cache entries.
      let records = Array.isArray(storedRecords) ? storedRecords : [];
      const start = snap.startDate || '';
      const end = snap.endDate || '';
      function inRange(dateStr) {
        if (!dateStr) return false;
        return (!start || dateStr >= start) && (!end || dateStr <= end);
      }
      (snap.rows || []).forEach(empRow => {
        const id = empRow.id;
        const name = empRow.name || '';
        const recs = records.filter(r => r && String(r.empId) === String(id) && inRange(r.date));
        const dateGroups = {};
        recs.forEach(r => {
          const d = r.date;
          if (!dateGroups[d]) dateGroups[d] = [];
          if (r.time && !dateGroups[d].includes(r.time)) dateGroups[d].push(r.time);
        });
        Object.keys(dateGroups).sort().forEach(dateKey => {
          const times = dateGroups[dateKey].sort();
          dtrRows.push({ id, name, date: dateKey, times });
        });
      });
    }
    const dtrTable = document.createElement('table');
    dtrTable.style.borderCollapse = 'collapse';
    dtrTable.style.width = '100%';
    const dtrHead = document.createElement('thead');
    const dr = document.createElement('tr');
    ['ID','Name','Date','Times'].forEach(h => {
      const th = document.createElement('th');
      th.textContent = h;
      th.style.border = '1px solid #e2e8f0';
      th.style.background = '#f1f5f9';
      th.style.padding = '4px';
      dr.appendChild(th);
    });
    dtrHead.appendChild(dr);
    dtrTable.appendChild(dtrHead);
    const dtrBody = document.createElement('tbody');
    dtrRows.forEach(row => {
      const tr = document.createElement('tr');
      const idCell = document.createElement('td');
      idCell.textContent = row.id;
      idCell.style.border = '1px solid #e2e8f0';
      idCell.style.padding = '4px';
      tr.appendChild(idCell);
      const nameCell = document.createElement('td');
      nameCell.textContent = row.name;
      nameCell.style.border = '1px solid #e2e8f0';
      nameCell.style.padding = '4px';
      tr.appendChild(nameCell);
      const dateCell = document.createElement('td');
      dateCell.textContent = row.date;
      dateCell.style.border = '1px solid #e2e8f0';
      dateCell.style.padding = '4px';
      tr.appendChild(dateCell);
      const timesCell = document.createElement('td');
      timesCell.textContent = (row.times || []).join(', ');
      timesCell.style.border = '1px solid #e2e8f0';
      timesCell.style.padding = '4px';
      tr.appendChild(timesCell);
      dtrBody.appendChild(tr);
    });
    dtrTable.appendChild(dtrBody);
    if (dtrRows.length) {
      dtrContainer.appendChild(dtrTable);
    } else {
      const p = document.createElement('p');
      p.textContent = 'No DTR records found for this period.';
      dtrContainer.appendChild(p);
    }
    // Show the detail screen
    detailScreen.style.display = 'block';
    // Disable editing across the app
    if (typeof disablePayrollInputs === 'function') {
      disablePayrollInputs();
    }
    // Mark date range inputs as forced and disabled
    const wsInput = document.getElementById('weekStart');
    const weInput = document.getElementById('weekEnd');
    if (wsInput) {
      wsInput.disabled = true;
      wsInput.dataset.forced = 'true';
    }
    if (weInput) {
      weInput.disabled = true;
      weInput.dataset.forced = 'true';
    }
    // Back button: restore previous view
    if (backBtn) {
      backBtn.onclick = () => {
        detailScreen.style.display = 'none';
        if (activeTable) activeTable.style.display = '';
        if (activeHeader && activeHeader.tagName === 'H4') activeHeader.style.display = '';
        if (historyTable) historyTable.style.display = '';
        if (histHeader && histHeader.tagName === 'H4') histHeader.style.display = '';
        if (diffButton) diffButton.style.display = '';
        if (snapshotViewEl) snapshotViewEl.style.display = '';
        payrollContainer.innerHTML = '';
        dtrContainer.innerHTML = '';
        // Remove forced flags and re-enable date inputs
        if (wsInput) {
          delete wsInput.dataset.forced;
          wsInput.disabled = false;
        }
        if (weInput) {
          delete weInput.dataset.forced;
          weInput.disabled = false;
        }
        // Re-enable editing
        if (typeof enablePayrollInputs === 'function') {
          enablePayrollInputs();
        }
        // Re-check lock status for selected period
        try {
          if (typeof checkAndToggleEditState === 'function') {
            checkAndToggleEditState();
          }
        } catch (_) {}
      };
    }
  };
});
</script>
   </div>
  </section>
  <section class="panel" id="panelProjectTotals">
  <style>
    #panelProjectTotals .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:18px;box-shadow:0 4px 18px rgba(0,0,0,.06)}
    #panelProjectTotals .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
    #panelProjectTotals table{border-collapse:collapse;width:100%}
    #panelProjectTotals th,#panelProjectTotals td{border:1px solid #dbe3ef;padding:6px 8px;font-size:12px;text-align:center;white-space:nowrap}
    #panelProjectTotals thead th{background:#eef4fb;font-weight:700}
    #panelProjectTotals tr.proj-break td{background:#b9f2ff;font-weight:700;text-align:left}
    #panelProjectTotals .totals{background:#fff7ed;font-weight:700}
    #panelProjectTotals .left{text-align:left}
    #panelProjectTotals .num{text-align:right}
    /* Match Payroll sub-tab look-and-feel for any Reports subtabs */
    #panelProjectTotals, #panelReports { --border:#e2e8f0; --accent:#FFD700 }
    #panelProjectTotals .subtab-nav, #panelReports .subtab-nav { display:flex; gap:6px; flex-wrap:wrap; margin-bottom:10px }
    #panelProjectTotals .tab-btn, #panelProjectTotals .subtab-btn,
    #panelReports .tab-btn, #panelReports .subtab-btn { padding:8px 12px; border:1px solid var(--border); background:#fff; border-radius:8px; cursor:pointer }
    #panelProjectTotals .tab-btn.active, #panelProjectTotals .subtab-btn.active,
    #panelReports .tab-btn.active, #panelReports .subtab-btn.active { background:var(--accent); color:#fff; border-color:var(--accent) }
    #panelProjectTotals .subtab-panel{ display:none }
    #panelProjectTotals .subtab-panel.active{ display:block }
    /* Master Report table styling */
    #panelProjectTotals .mr h2{ text-align:center; margin:8px 0 14px 0; font-size:20px }
    #panelProjectTotals .mr h4{ margin:10px 0 6px 0 }
    #panelProjectTotals .mr-table{ width:100%; border-collapse:collapse; font-size:12px }
    #panelProjectTotals .mr-table th, #panelProjectTotals .mr-table td{ border:1px solid #dbe3ef; padding:6px 8px; text-align:right }
    #panelProjectTotals .mr-table th.left, #panelProjectTotals .mr-table td.left{ text-align:left }
    #panelProjectTotals .mr-table tfoot td{ font-weight:700; background:#fff7ed }
    /* Print: one sheet per project, repeat header; hide grand total (redundant) */
    @media print{
      header,.header,.controls{display:none!important}
      .card{box-shadow:none;border:0;padding:0}
      #r_table thead{display:table-header-group}
      #r_table tfoot{display:none!important}
      #r_table tbody.proj-page{display:table-row-group;break-inside:avoid;page-break-inside:avoid}
      #r_table tbody.proj-page{break-before:page;page-break-before:always}
      #r_table tbody.proj-page:first-of-type{break-before:auto;page-break-before:auto}
      /* Master report print tweaks */
      #masterReportContainer .mr-table thead{display:table-header-group}
    }
  </style>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Reports</h3>
    <div class="subtab-nav">
      <button class="tab-btn subtab-btn active" data-subtab="reportsDetailedTab" id="btnReportsDetailed">Detailed</button>
      <button class="tab-btn subtab-btn" data-subtab="masterReportTab" id="btnMasterReport">Master Report</button>
    </div>

    <!-- Detailed (existing) reports view -->
    <div id="reportsDetailedTab" class="subtab-panel active">
      <div class="controls">
        <button id="r_print">Print</button>
        <button id="r_csv">CSV (All)</button>
        <span id="r_range_hint" style="font-size:12px;color:#64748b;margin-left:auto;"></span>
      </div>
      <div id="r_msg" style="font-size:13px;color:#64748b;display:none;"></div>
      <table id="r_table" aria-live="polite"></table>
    </div>

    <!-- New Master Report view -->
    <div id="masterReportTab" class="subtab-panel">
      <div class="controls">
        <button id="mr_print">Print</button>
      </div>
      <div id="masterReportContainer" class="mr"></div>
    </div>
  </div>

  <script>
  (function(){
    let __report = null;

    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
    const toNum = v => { const n = parseFloat(String(v||'').replace(/,/g,'')); return isNaN(n)?0:n; };
    const f2  = n => { const x = Number(n)||0; return x===0 ? '-' : x.toLocaleString('en-US',{minimumFractionDigits:2, maximumFractionDigits:2}); };
    const showMsg = (t)=>{ const m=$('#r_msg'); if(m){ m.textContent=t; m.style.display=t?'block':'none'; } };

    const isRealProject = (p)=>{
      if (!p) return false;
      const s = String(p).trim().toLowerCase();
      return s && !['(none)','none','-','null','undefined',''].includes(s);
    };

    function cssEscape(val){ return String(val).replace(/["\\\\]/g, '\\\\$&'); }

    function getPayrollRange(){
      try{
        const ws = document.getElementById('weekStart')?.value;
        const we = document.getElementById('weekEnd')?.value;
        if (ws && we) return [ws,we];
      }catch(e){}
      try{
        const ls_ws = localStorage.getItem('payroll_week_start');
        const ls_we = localStorage.getItem('payroll_week_end');
        if (ls_ws && ls_we) return [String(ls_ws).replace(/\"/g,''), String(ls_we).replace(/\"/g,'')];
      }catch(e){}
      try{
        const sel = document.getElementById('activePayrollSelect');
        const txt = sel && sel.options && sel.selectedIndex>=0 ? sel.options[sel.selectedIndex].textContent : '';
        const m = txt && txt.match(/(\d{4}-\d{2}-\d{2}).*?(\d{4}-\d{2}-\d{2})/);
        if (m) return [m[1], m[2]];
      }catch(e){}
      const trs = $$('#resultsTable tbody tr');
      let minD=1e20, maxD=-1e20;
      trs.forEach(tr=>{
        const d = tr.cells[4]?.textContent?.trim();
        if(!d) return;
        const t = new Date(d).setHours(0,0,0,0);
        if (!isNaN(t)){ minD = Math.min(minD,t); maxD = Math.max(maxD,t); }
      });
      if (maxD < minD) {
        const today = new Date().toISOString().slice(0,10);
        return [today,today];
      }
      return [new Date(minD).toISOString().slice(0,10), new Date(maxD).toISOString().slice(0,10)];
    }

    function eachDate(fromMS,toMS){
      const out=[]; let t=fromMS;
      while(t<=toMS){ out.push(new Date(t)); t += 86400000; }
      return out;
    }

    // --- Robust rate lookup ---
    function getRateById(id){
      try{
        const se = (window.storedEmployees||{})[id];
        if (se){
          const r = toNum(se.hourlyRate ?? se.rate ?? se.hourly_rate ?? se.payRate ?? se.wage);
          if (r) return r;
        }
      }catch(e){}
      try{
        const pr = (window.payrollRates||{})[id];
        if (pr) return toNum(pr);
      }catch(e){}
      const inp = document.querySelector(`.emp-rate-input[data-id="${cssEscape(id)}"]`);
      if (inp) return toNum(inp.value || inp.textContent);
      return 0;
    }
    function getRateByName(name){
      if (!name) return 0;
      const target = String(name).toUpperCase();
      try{
        const se = window.storedEmployees||{};
        for (const [id, e] of Object.entries(se)){
          if ((e?.name||'').toUpperCase() === target){
            const r = toNum(e.hourlyRate ?? e.rate ?? e.hourly_rate ?? e.payRate ?? e.wage);
            if (r) return r;
          }
        }
      }catch(e){}
      const rows = $$('#employeesTable tbody tr');
      for (const tr of rows){
        const nm = (tr.querySelector('.emp-name-input')?.value || tr.cells[1]?.textContent || '').trim().toUpperCase();
        if (nm === target){
          const inp = tr.querySelector('.emp-rate-input');
          if (inp) return toNum(inp.value || inp.textContent);
        }
      }
      return 0;
    }
    function getRate(id, name){ return getRateById(id) || getRateByName(name); }

    function readProjectFromRow(tr){
      const sel = tr.cells[2]?.querySelector('select');
      if (sel){
        const opt = sel.options[sel.selectedIndex];
        const txt = (opt && (opt.textContent||opt.label)) || sel.value;
        return (txt||'').trim();
      }
      const dp = tr.cells[2]?.dataset?.project;
      if (dp) return String(dp).trim();
      return (tr.cells[2]?.textContent||'').trim();
    }

    function collect(fromStr, toStr){
      const M = {};
      const trs = $$('#resultsTable tbody tr');
      trs.forEach(tr=>{
        const id   = (tr.cells[0]?.textContent||'').trim();
        const name = (tr.cells[1]?.textContent||'').trim();
        const proj = readProjectFromRow(tr);
        const date = (tr.cells[4]?.textContent||'').trim();
        const rwh = toNum(tr.cells[11]?.textContent) || toNum(tr.querySelector('.regHrs')?.value);
        const oth = toNum(tr.cells[12]?.textContent) || toNum(tr.querySelector('.otHrs')?.value);
        if(!id || !date) return;
        if(!isRealProject(proj)) return;

        const d = new Date(date).setHours(0,0,0,0);
        if(fromStr){ const f = new Date(fromStr).setHours(0,0,0,0); if(d < f) return; }
        if(toStr){ const t = new Date(toStr).setHours(0,0,0,0); if(d > t) return; }

        (M[proj] = M[proj]||{});
        (M[proj][id] = M[proj][id]||{ name, days:{} });
        const slot = M[proj][id].days[d] || { rwh:0, oth:0 };
        slot.rwh += rwh; slot.oth += oth;
        M[proj][id].days[d] = slot;
      });
      return M;
    }

    function buildTable(){
      const dtrRows = $$('#resultsTable tbody tr');
      const table = $('#r_table'); if(!table) return;
      if (dtrRows.length === 0){
        showMsg('No DTR rows found. Import DTR or open a period first.');
        table.innerHTML='';
        __report = null;
        return;
      }
      showMsg('');

      const [from, to] = getPayrollRange();
      const dates = eachDate(new Date(from).setHours(0,0,0,0), new Date(to).setHours(0,0,0,0));
      const data = collect(from, to) || {};
      // Ensure projects that only have Bantay allowance (no DTR rows) appear as their own blocks
      try {
        const bp = (typeof bantayProj !== 'undefined' && bantayProj) || {};
        const b  = (typeof bantay !== 'undefined' && bantay) || {};
        const sp = (typeof storedProjects !== 'undefined' && storedProjects) || {};
        const allowByProjName = {};
        Object.keys(b).forEach(empId => {
          const amt = parseFloat((b[empId]) || 0) || 0;
          if (amt <= 0) return;
          const assigned = bp[empId];
          if (!assigned) return;
          const projName = (sp[assigned] && sp[assigned].name) ? sp[assigned].name : assigned;
          if (!isRealProject(projName)) return;
          allowByProjName[projName] = (allowByProjName[projName] || 0) + amt;
        });
        Object.keys(allowByProjName).forEach(pn => { if (!data[pn]) data[pn] = {}; });
      } catch (e) { /* ignore */ }
      __report = { data, from, to, dates };

      const totalCols = 2 + (dates.length*2) + 4;
      const hint = $('#r_range_hint');
      if (hint) hint.textContent = `Range: ${from} - ${to}`;

      // THEAD
      let thead1 = `<tr><th class="left" rowspan="2">PERSONNEL</th><th rowspan="2">RATE</th>`;
      dates.forEach(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        thead1 += `<th colspan="2">${lbl}</th>`;
      });
      thead1 += `<th rowspan="2">TOTAL REG HRS</th><th rowspan="2">TOTAL OT HRS</th><th rowspan="2">GRAND TOTAL HOURS</th><th rowspan="2">GROSS</th></tr>`;
      let thead2 = `<tr>${dates.map(()=>`<th>RWH</th><th>OTH</th>`).join('')}</tr>`;

      // Per-project TBODY blocks
      const tbodies = [];
      let gReg=0,gOT=0,gGross=0;
      const gDayTotals = dates.map(() => ({ rwh: 0, oth: 0 }));
      const projects = Object.keys(data).sort();

      projects.forEach(proj=>{
        const empMap = data[proj];
        let pReg=0,pOT=0,pGross=0;
        const dayTotals = dates.map(() => ({ rwh: 0, oth: 0 }));
        let rows='';

        rows += `<tr class="proj-break"><td colspan="${totalCols}">${proj}</td></tr>`;

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;
          const rate = getRate(empId, display);
          let rReg=0,rOT=0;

          const cells = dates.map((d,i)=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
            return `<td class="num">${f2(v.rwh)}</td><td class="num">${f2(v.oth)}</td>`;
          }).join('');

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows += `<tr>
            <td class="left">${display}</td>
            <td class="num">${f2(rate)}</td>
            ${cells}
            <td class="num">${f2(rReg)}</td>
            <td class="num">${f2(rOT)}</td>
            <td class="num">${f2(rReg + rOT)}</td>
            <td class="num">${f2(gross)}</td>
          </tr>`;
        });

// Compute per-project Bantay allowance (Supabase-backed)
const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
  const assigned = (bantayProj || {})[empId];
  if (!assigned) return sum;
  const matchesById   = (assigned === proj);
  const matchesByName = ((storedProjects && storedProjects[assigned]?.name) === proj);
  return (matchesById || matchesByName) ? sum + (parseFloat(bantay[empId]) || 0) : sum;
}, 0);

// Render Allowance row (amount in Gross column)
rows += `<tr class="allowance">
  <td class="left">Allowance</td>
  <td class="num">-</td>
  ${dates.map(()=>`<td class="num">-</td><td class="num">-</td>`).join('')}
  <td class="num">-</td>
  <td class="num">-</td>
  <td class="num">-</td>
  <td class="num">${f2(allow)}</td>
</tr>`;

  // Include allowance in project gross
  pGross += allow;

  rows += `<tr class="totals">
            <td class="left">Project Total</td>
            <td class="num">-</td>
            ${dayTotals.map(dt => `<td class="num">${f2(dt.rwh)}</td><td class="num">${f2(dt.oth)}</td>`).join('')}
            <td class="num">${f2(pReg)}</td>
            <td class="num">${f2(pOT)}</td>
            <td class="num">${f2(pReg + pOT)}</td>
            <td class="num">${f2(pGross)}</td>
          </tr>`;

          gReg += pReg; gOT += pOT; gGross += pGross;
          dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });

          tbodies.push(`<tbody class="proj-page">${rows}</tbody>`);
        });

        const foot = `<tr class="totals">
          <td class="left">Grand Total</td>
          <td class="num">-</td>
          ${gDayTotals.map(dt => `<td class="num">${f2(dt.rwh)}</td><td class="num">${f2(dt.oth)}</td>`).join('')}
          <td class="num">${f2(gReg)}</td>
          <td class="num">${f2(gOT)}</td>
          <td class="num">${f2(gReg + gOT)}</td>
          <td class="num">${f2(gGross)}</td>
        </tr>`;

      $('#r_table').innerHTML = `<thead>${thead1}${thead2}</thead>${tbodies.join('')}<tfoot>${foot}</tfoot>`;

      // Commas for numeric cells
      (function applyCommas(){
        const fmt = (v)=>{
          const n = parseFloat(String(v||'').replace(/,/g,''));
          if (isNaN(n)) return v;
          return n.toLocaleString('en-US',{minimumFractionDigits:2, maximumFractionDigits:2});
        };
        const cells = Array.from(document.querySelectorAll('#r_table td.num, #r_table tfoot td.num'));
        cells.forEach(td=>{ td.textContent = fmt(td.textContent); });
      })();
    }

    function csvEscape(s){
      if (s == null) return '';
      s = String(s);
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }
    function to2(n){ n = parseFloat(String(n).replace(/,/g,'')); if (isNaN(n)) n = 0; return (Math.round(n*100)/100).toFixed(2); }

    function exportCSVAll(){
      if (!__report){ alert('No report to export yet.'); return; }
      const { data, dates, from, to } = __report;

      const dayHeader = dates.map(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        return [`RWH ${lbl}`, `OTH ${lbl}`];
      }).flat();

      const header = ['PROJECT','PERSONNEL','RATE']
        .concat(dayHeader)
        .concat(['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);
      const rows = [header];

      const projects = Object.keys(data).sort();
      let gReg=0,gOT=0,gGross=0;
      const gDayTotals = dates.map(() => ({ rwh:0, oth:0 }));

      projects.forEach(proj=>{
        const empMap = data[proj];
        let pReg=0,pOT=0,pGross=0;
        const dayTotals = dates.map(() => ({ rwh:0, oth:0 }));

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;

          const rate = getRate(empId, display);

          let rReg=0,rOT=0;
          const dayCells = [];
          dates.forEach((d,i)=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
            dayCells.push(to2(v.rwh), to2(v.oth));
          });

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows.push([proj, display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg + rOT), to2(gross)]));
        });

        // Add per-project Allowance row (amount placed in GROSS column)
        try {
          const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
            const assigned = (bantayProj || {})[empId];
            if (!assigned) return sum;
            const matchesById   = (assigned === proj);
            const matchesByName = ((typeof storedProjects !== 'undefined' && storedProjects && storedProjects[assigned]?.name) === proj);
            const amt = parseFloat((bantay && bantay[empId]) || 0) || 0;
            return (matchesById || matchesByName) ? (sum + amt) : sum;
          }, 0);
          // Push a CSV row for Allowance with zero hours and gross = allowance
          const zeroCells = new Array(dates.length*2).fill('0.00');
          rows.push([proj, 'Allowance', ''].concat(zeroCells, ['0.00','0.00','0.00', to2(allow)]));
          // Include allowance in project gross before rolling into grand totals
          pGross += allow;
        } catch (e) { /* no-op if allowance data missing */ }

        gReg += pReg; gOT += pOT; gGross += pGross;
        dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });
        const dayTotalsCells = dayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
        rows.push([proj, 'Project Total', ''].concat(
          dayTotalsCells,
          [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]
        ));
      });

      const gDayTotalsCells = gDayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
      rows.push(['', 'Grand Total', ''].concat(
        gDayTotalsCells,
        [to2(gReg), to2(gOT), to2(gReg+gOT), to2(gGross)]
      ));

      const csv = rows.map(r=>r.map(csvEscape).join(',')).join('\n');
      const a=document.createElement('a');
      a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
      a.download=`reports_all_${from}_to_${to}.csv`;
      a.click(); URL.revokeObjectURL(a.href);
    }

    // Export an Excel workbook with one sheet per project
    function exportExcelAllSheets(){
      try{
        if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) { alert('Excel library not available'); return; }
        if (!__report) { if (typeof window.rebuildReports==='function') window.rebuildReports(); }
        if (!__report) { alert('No report to export yet.'); return; }
        const { data, dates, from, to } = __report;
        const wb = XLSX.utils.book_new();
        // Helper: build headers
        const dayHeader = dates.map(d=>{
          const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
          return [`RWH ${lbl}`, `OTH ${lbl}`];
        }).flat();
        const header = ['PERSONNEL','RATE'].concat(dayHeader, ['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);
        // Build one sheet per project
        const projects = Object.keys(data).sort();
        let gReg=0,gOT=0,gGross=0;
        const gDayTotals = dates.map(()=>({ rwh:0, oth:0 }));
        const summaryRows = [['PROJECT'].concat(header)];
        projects.forEach(proj=>{
          const empMap = data[proj];
          const rows = [header.slice()];
          let pReg=0,pOT=0,pGross=0;
          const dayTotals = dates.map(()=>({ rwh:0, oth:0 }));
          Object.keys(empMap).sort((a,b)=>{
            const A = (empMap[a].name||a).toUpperCase();
            const B = (empMap[b].name||b).toUpperCase();
            return A.localeCompare(B);
          }).forEach(empId=>{
            const rec = empMap[empId];
            const display = rec.name || empId;
            const rate = getRate(empId, display);
            let rReg=0,rOT=0;
            const dayCells = [];
            dates.forEach((d,i)=>{
              const key = d.setHours(0,0,0,0);
              const v = rec.days[key] || { rwh:0, oth:0 };
              rReg += v.rwh; rOT += v.oth;
              dayTotals[i].rwh += v.rwh; dayTotals[i].oth += v.oth;
              dayCells.push(to2(v.rwh), to2(v.oth));
            });
            const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
            const gross = (rReg * rate) + (rOT * rate * otMult);
            pReg += rReg; pOT += rOT; pGross += gross;
            rows.push([display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
            summaryRows.push([proj, display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
          });
          // Allowance-only row from on-screen report logic
          try{
            const allow = Object.keys(bantay || {}).reduce((sum, empId) => {
              const assigned = (bantayProj || {})[empId];
              if (!assigned) return sum;
              const matchesById   = (assigned === proj);
              const matchesByName = ((typeof storedProjects !== 'undefined' && storedProjects && storedProjects[assigned]?.name) === proj);
              const amt = parseFloat((bantay && bantay[empId]) || 0) || 0;
              return (matchesById || matchesByName) ? (sum + amt) : sum;
            }, 0);
            if (allow && allow > 0){
              const zeros = new Array(dates.length*2).fill('0.00');
              rows.push(['Allowance',''].concat(zeros, ['0.00','0.00','0.00', to2(allow)]));
              summaryRows.push([proj, 'Allowance',''].concat(zeros, ['0.00','0.00','0.00', to2(allow)]));
              pGross += allow;
            }
          }catch(e){}
          gReg += pReg; gOT += pOT; gGross += pGross;
          dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });
          const dayTotalsCells = dayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
          rows.push(['Project Total',''].concat(dayTotalsCells, [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]));
          summaryRows.push([proj,'Project Total',''].concat(dayTotalsCells,[to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]));
          const ws = XLSX.utils.aoa_to_sheet(rows);
          XLSX.utils.book_append_sheet(wb, ws, (proj || 'Project').toString().substring(0,31));
        });
        // Summary sheet with grand totals
        const gDayTotalsCells = gDayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
        summaryRows.push(['','Grand Total',''].concat(gDayTotalsCells, [to2(gReg), to2(gOT), to2(gReg+gOT), to2(gGross)]));
        const wsSummary = XLSX.utils.aoa_to_sheet(summaryRows);
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
        const fname = `reports_all_${from}_to_${to}.xlsx`;
        XLSX.writeFile(wb, fname);
      }catch(e){ console.warn('Excel export failed', e); alert('Excel export failed.'); }
    }

    // Expose for external triggers (lock automation)
    try { window.exportExcelAllSheets = exportExcelAllSheets; } catch(e){}

    // Export a single workbook that includes sheets for: DTR, Employees, Payroll,
    // and per-project Reports (plus Summary)
    function exportExcelAllTabs(){
      try{
        if (typeof XLSX === 'undefined' || !XLSX || !XLSX.utils) { alert('Excel library not available'); return; }
        if (typeof window.rebuildReports === 'function') window.rebuildReports();
        if (!__report) { alert('No report to export yet.'); return; }
        const { data, dates, from, to } = __report;
        const wb = XLSX.utils.book_new();

        // 1) DTR sheet from #resultsTable (excluding actions)
        try{
          const tbl = document.getElementById('resultsTable');
          const head = Array.from(tbl.querySelectorAll('thead th')).map(th=> (th.textContent||'').trim()).filter(t=>t.toLowerCase()!=='actions' && t.toLowerCase()!=='split');
          const rows = [head];
          Array.from(tbl.querySelectorAll('tbody tr')).forEach(tr=>{
            const tds = Array.from(tr.querySelectorAll('td')).filter(td=>!td.classList.contains('actions-cell'));
            const row = tds.map(td=>{
              const sel = td.querySelector && td.querySelector('select');
              if (sel && sel.options && sel.selectedIndex>=0){ const opt=sel.options[sel.selectedIndex]; return (opt && (opt.textContent||opt.innerText||opt.value))||''; }
              return (td.textContent||'').trim();
            });
            rows.push(row);
          });
          XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(rows), 'DTR');
        }catch(e){}

        // 2) Employees sheet from store
        try{
          const header = ['ID','Name','Hourly Rate','Bank Account','Schedule Name','Schedule ID','Project Name','Project ID','Deduct Pag-IBIG','Deduct PhilHealth','Deduct SSS'];
          const rows = [header];
          const flagsAll = (typeof contribFlags!=='undefined' && contribFlags) || {};
          Object.keys(storedEmployees||{}).forEach(id=>{
            const emp = (storedEmployees||{})[id]||{};
            const schedId = emp.scheduleId || '';
            const schedName = (storedSchedules && storedSchedules[schedId]?.name) || '';
            const projId = emp.projectId || '';
            const projName = (storedProjects && storedProjects[projId]?.name) || '';
            const bank = emp.bankAccount || '';
            const fl = flagsAll[id] || {};
            const fPI = (fl.pagibig !== false) ? 'Yes' : 'No';
            const fPH = (fl.philhealth !== false) ? 'Yes' : 'No';
            const fSSS= (fl.sss !== false) ? 'Yes' : 'No';
            rows.push([id, emp.name||'', emp.hourlyRate||'', bank, schedName, schedId, projName, projId, fPI, fPH, fSSS]);
          });
          XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(rows), 'Employees');
        }catch(e){}

        // 3) Payroll sheet from #payrollTable (inputs → values, drop Payslip)
        try{
          const src = document.getElementById('payrollTable');
          const clone = src.cloneNode(true);
          // Remove Payslip last column
          const removeLastCell = row => { if (row && row.lastElementChild) row.removeChild(row.lastElementChild); };
          clone.querySelectorAll('thead tr').forEach(removeLastCell);
          clone.querySelectorAll('tbody tr').forEach(removeLastCell);
          clone.querySelectorAll('tfoot tr').forEach(removeLastCell);
          // Convert inputs to text
          clone.querySelectorAll('input').forEach(inp=>{ const td=inp.parentElement; td.textContent = (inp.value||inp.textContent||''); });
          const head = [Array.from(clone.querySelectorAll('thead th')).map(th=> (th.textContent||'').trim())];
          const body = Array.from(clone.querySelectorAll('tbody tr')).map(tr=> Array.from(tr.querySelectorAll('td')).map(td=> (td.textContent||'').trim()));
          const foot = [];
          const tfr = clone.querySelector('tfoot tr'); if (tfr){ foot.push(Array.from(tfr.querySelectorAll('td')).map(td=> (td.textContent||'').trim())); }
          const aoa = head.concat(body).concat(foot);
          XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(aoa), 'Payroll');
        }catch(e){}

        // 4) Reports: reuse per-project builder to append sheets + Summary
        try{
          // Build using existing function by temporarily overriding writeFile
          // but here we inline the same logic as exportExcelAllSheets to append to wb
          const addReportSheets = (wb2)=>{
            const dayHeader = dates.map(d=>{ const lbl=d.toLocaleDateString(undefined,{day:'2-digit',month:'short'}); return [`RWH ${lbl}`, `OTH ${lbl}`]; }).flat();
            const header = ['PERSONNEL','RATE'].concat(dayHeader, ['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);
            const projects = Object.keys(data).sort();
            let gReg=0,gOT=0,gGross=0;
            const gDayTotals = dates.map(()=>({rwh:0, oth:0}));
            const summaryRows = [['PROJECT'].concat(header)];
            projects.forEach(proj=>{
              const empMap = data[proj];
              const rows = [header.slice()];
              let pReg=0,pOT=0,pGross=0;
              const dayTotals = dates.map(()=>({rwh:0, oth:0}));
              Object.keys(empMap).sort((a,b)=>{ const A=(empMap[a].name||a).toUpperCase(); const B=(empMap[b].name||b).toUpperCase(); return A.localeCompare(B); }).forEach(empId=>{
                const rec = empMap[empId]; const display = rec.name || empId; const rate = getRate(empId, display);
                let rReg=0,rOT=0; const dayCells=[]; dates.forEach((d,i)=>{ const key=d.setHours(0,0,0,0); const v=rec.days[key]||{rwh:0,oth:0}; rReg+=v.rwh; rOT+=v.oth; dayTotals[i].rwh+=v.rwh; dayTotals[i].oth+=v.oth; dayCells.push(to2(v.rwh), to2(v.oth)); });
                const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
                const gross = (rReg*rate) + (rOT*rate*otMult); pReg+=rReg; pOT+=rOT; pGross+=gross;
                rows.push([display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
                summaryRows.push([proj, display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg+rOT), to2(gross)]));
              });
              // Allowance row
              try{
                const allow = Object.keys(bantay||{}).reduce((sum, empId)=>{ const assigned=(bantayProj||{})[empId]; if(!assigned) return sum; const matchesById=(assigned===proj); const matchesByName=((typeof storedProjects!=='undefined'&&storedProjects&&storedProjects[assigned]?.name)===proj); const amt=parseFloat((bantay&&bantay[empId])||0)||0; return (matchesById||matchesByName)?(sum+amt):sum; },0);
                if(allow>0){ const zeros=new Array(dates.length*2).fill('0.00'); rows.push(['Allowance',''].concat(zeros,['0.00','0.00','0.00', to2(allow)])); summaryRows.push([proj,'Allowance',''].concat(zeros,['0.00','0.00','0.00', to2(allow)])); pGross+=allow; }
              }catch(e){}
              gReg+=pReg; gOT+=pOT; gGross+=pGross;
              dayTotals.forEach((dt,i)=>{ gDayTotals[i].rwh += dt.rwh; gDayTotals[i].oth += dt.oth; });
              const dayTotalsCells = dayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
              rows.push(['Project Total',''].concat(dayTotalsCells, [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]));
              XLSX.utils.book_append_sheet(wb2, XLSX.utils.aoa_to_sheet(rows), (proj||'Project').toString().substring(0,31));
            });
            const gDayTotalsCells = gDayTotals.flatMap(dt=>[to2(dt.rwh), to2(dt.oth)]);
            summaryRows.push(['','Grand Total',''].concat(gDayTotalsCells, [to2(gReg), to2(gOT), to2(gReg+gOT), to2(gGross)]));
            XLSX.utils.book_append_sheet(wb2, XLSX.utils.aoa_to_sheet(summaryRows), 'Summary');
          };
          addReportSheets(wb);
        }catch(e){}

        const fname = `all_tabs_${from}_to_${to}.xlsx`;
        XLSX.writeFile(wb, fname);
      }catch(e){ console.warn('Excel export failed', e); alert('Excel export failed'); }
    }

    try { window.exportExcelAllTabs = exportExcelAllTabs; } catch(e){}
    // Bind UI button for Excel (All Tabs)
    try {
      var xBtn = document.getElementById('r_xlsx');
      if (xBtn && !xBtn.__xlsxBound){ xBtn.addEventListener('click', function(ev){ ev.preventDefault(); exportExcelAllTabs(); }); xBtn.__xlsxBound = true; }
    } catch(e){}

    // Export for a specific date range (used by Payroll History actions)
    function exportExcelAllTabsForRange(from, to){
      try{
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        const prevS = ws && ws.value; const prevE = we && we.value;
        if (ws) ws.value = from || prevS; if (we) we.value = to || prevE;
        try{ if (typeof calculatePayrollFromResultsTable==='function') calculatePayrollFromResultsTable(); else if (typeof calculatePayrollFromRecords==='function') calculatePayrollFromRecords(); }catch(e){}
        try{ if (typeof window.rebuildReports==='function') window.rebuildReports(); }catch(e){}
        setTimeout(function(){ try{ exportExcelAllTabs(); } finally { try{ if (ws) ws.value = prevS; if (we) we.value = prevE; if (typeof window.rebuildReports==='function') window.rebuildReports(); }catch(e){} } }, 300);
      }catch(e){ console.warn('Export for range failed', e); }
    }
    try { window.exportExcelAllTabsForRange = exportExcelAllTabsForRange; } catch(e){}

    function exportCSVPerProject(){
      if (!__report){ alert('No report to export yet.'); return; }
      const { data, dates, from, to } = __report;

      const dayHeader = dates.map(d=>{
        const lbl = d.toLocaleDateString(undefined,{day:'2-digit',month:'short'});
        return [`RWH ${lbl}`, `OTH ${lbl}`];
      }).flat();
      const header = ['PERSONNEL','RATE'].concat(dayHeader, ['TOTAL REG HRS','TOTAL OT HRS','GRAND TOTAL HOURS','GROSS']);

      const projects = Object.keys(data).sort();
      projects.forEach(proj=>{
        const empMap = data[proj];
        const rows = [header];
        let pReg=0,pOT=0,pGross=0;

        Object.keys(empMap).sort((a,b)=>{
          const A = (empMap[a].name||a).toUpperCase();
          const B = (empMap[b].name||b).toUpperCase();
          return A.localeCompare(B);
        }).forEach(empId=>{
          const rec = empMap[empId];
          const display = rec.name || empId;
          const rate = getRate(empId, display);

          let rReg=0,rOT=0;
          const dayCells = [];
          dates.forEach(d=>{
            const key = d.setHours(0,0,0,0);
            const v = rec.days[key] || { rwh:0, oth:0 };
            rReg += v.rwh; rOT += v.oth;
            dayCells.push(to2(v.rwh), to2(v.oth));
          });

          const otMult = toNum(document.querySelector('#otMultiplier')?.value || 1.5);
          const gross = (rReg * rate) + (rOT * rate * otMult);
          pReg += rReg; pOT += rOT; pGross += gross;

          rows.push([display, to2(rate)].concat(dayCells, [to2(rReg), to2(rOT), to2(rReg + rOT), to2(gross)]));
        });

        rows.push(['Project Total', ''].concat(
          new Array(dates.length*2).fill(''),
          [to2(pReg), to2(pOT), to2(pReg+pOT), to2(pGross)]
        ));

        const csv = rows.map(r=>r.map(csvEscape).join(',')).join('\n');
        const a=document.createElement('a');
        const safeProj = proj.replace(/[^a-z0-9_\-]+/gi,'_');
        a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
        a.download=`report_${safeProj}_${from}_to_${to}.csv`;
        a.click(); URL.revokeObjectURL(a.href);
      });
    }

  // Use the clean per-project print handler defined later; avoid double-binding here.
  // $('#r_print')?.addEventListener('click', ()=> safePrint());
    // Subtab wiring for Detailed/Master
    (function(){
      const btns = Array.from(document.querySelectorAll('#panelProjectTotals .subtab-btn'));
      function show(id){
        btns.forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('#panelProjectTotals .subtab-panel').forEach(p=>p.classList.remove('active'));
        const target = document.getElementById(id);
        if (target) target.classList.add('active');
        const activator = document.querySelector(`#panelProjectTotals .subtab-btn[data-subtab="${id}"]`);
        if (activator) activator.classList.add('active');
        if (id === 'masterReportTab') { try{ renderMasterReport(); }catch(e){} }
      }
      btns.forEach(b=>{ if (b._wired) return; b._wired = true; b.addEventListener('click', ()=> show(b.getAttribute('data-subtab'))); });
    })();

    $('#r_csv')?.addEventListener('click', exportCSVAll);const dtr = document.getElementById('resultsTable');
    if (dtr && 'MutationObserver' in window){
      const mo = new MutationObserver(()=> { buildTable(); try{ renderMasterReport(); }catch(e){} });
      mo.observe(dtr, { childList:true, subtree:true });
    }
    // Expose a global rebuild hook so other tabs (e.g., Payroll bantay edits)
    // can refresh the report without a full page reload.
    try { window.rebuildReports = function(){ try{ buildTable(); }catch(e){} try{ renderMasterReport(); }catch(e){} }; } catch(e){}
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ buildTable(); try{ renderMasterReport(); }catch(e){} }, { once:true });
    } else { buildTable(); try{ renderMasterReport(); }catch(e){} }
  })();
  </script>
</section>
<!-- Master Report builder (contributions summary + per-project totals) -->
<script>
(function(){
  // Utilities
  function num(v){ const n=parseFloat(String(v||'').replace(/,/g,'')); return isNaN(n)?0:n; }
  function f2(n){ const x=Number(n)||0; return x.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }
  function safe(val){ return String(val==null?'':val); }

  function getPayrollRange(){
    try{
      const ws = document.getElementById('weekStart')?.value;
      const we = document.getElementById('weekEnd')?.value;
      if (ws && we) return [ws,we];
    }catch(e){}
    return ['', ''];
  }

  // Compute contribution totals across employees for the active period
  function computeContributionTotals(){
    try{ if (typeof syncPeriodScopedData==='function') syncPeriodScopedData(); }catch(e){}
    const sums = { piEE:0, piER:0, phEE:0, phER:0, sssEE:0, sssER:0, loanSSS:0, loanPI:0 };
    try{
      const list = (typeof employeeList!=='undefined' && employeeList) ? employeeList : [];
      const rates = (typeof payrollRates!=='undefined' && payrollRates) ? payrollRates : {};
      const se = (typeof storedEmployees!=='undefined' && storedEmployees) ? storedEmployees : {};
      const rHours = (typeof regHours!=='undefined' && regHours) ? regHours : {};
      const flagsAll = (typeof contribFlags!=='undefined' && contribFlags) ? contribFlags : {};
      const div = Number(typeof divisor!=='undefined' ? divisor : 1) || 1;
      const lSSS = (typeof loanSSS!=='undefined' && loanSSS) ? loanSSS : {};
      const lPI  = (typeof loanPI!=='undefined'  && loanPI ) ? loanPI  : {};
      list.forEach(emp=>{
        const id = emp.id;
        const rH = num(rHours[id]);
        const rate = num(se?.[id]?.hourlyRate ?? rates?.[id]);
        const regPay = +(rH * rate).toFixed(2);
        const monthly = rate * 8 * 24;
        const piRate = (typeof pagibigRateByMonthly==='function') ? pagibigRateByMonthly(monthly) : 0;
        const phRate = (typeof philhealthRateByMonthly==='function') ? philhealthRateByMonthly(monthly) : 0;
        const sssFull = (typeof sssShareByMonthly==='function') ? sssShareByMonthly(monthly) : 0;
        const flags = flagsAll[id] || {};
        const pi = (flags.pagibig===false) ? 0 : +(regPay * piRate).toFixed(2);
        const ph = (flags.philhealth===false) ? 0 : +(regPay * phRate).toFixed(2);
        const sss = (flags.sss===false) ? 0 : +(sssFull/div).toFixed(2);
        sums.piEE += pi; sums.piER += pi;
        sums.phEE += ph; sums.phER += ph;
        sums.sssEE += sss; sums.sssER += sss;
        sums.loanSSS += +(num(lSSS[id]) / div).toFixed(2);
        sums.loanPI  += +(num(lPI[id])  / div).toFixed(2);
      });
    }catch(e){}
    return sums;
  }

  // Read per-project totals by copying values from the Detailed reports table
  function computeProjectTotalsFromDetailed(){
    const rows = [];
    try{
      const tbl = document.getElementById('r_table');
      if (!tbl) return rows;
      const blocks = Array.from(tbl.querySelectorAll('tbody.proj-page'));
      blocks.forEach(tb => {
        const name = (tb.querySelector('.proj-break td')?.textContent || '').trim();
        let tot = tb.querySelector('tr.totals:last-child');
        if (!tot) {
          const trs = Array.from(tb.querySelectorAll('tr'));
          tot = trs.reverse().find(tr => (tr.cells[0]?.textContent||'').trim().toLowerCase() === 'project total');
        }
        if (!tot) return;
        const cells = tot.querySelectorAll('td');
        if (!cells || cells.length < 2) return;
        const gross = num(cells[cells.length-1].textContent);
        const hrs   = num(cells[cells.length-2].textContent);
        rows.push({ name, hrs, total: gross });
      });
      rows.sort((a,b)=> a.name.localeCompare(b.name));
    }catch(e){}
    return rows;
  }

  // Fallback: compute from DTR if detailed table isn’t available
  function computeProjectTotalsFromDTR(){
    const rows = [];
    try{
      const projMap = {};
      const trs = Array.from(document.querySelectorAll('#resultsTable tbody tr'));
      trs.forEach(tr=>{
        const id = (tr.cells[0]?.textContent||'').trim();
        const name = (tr.cells[1]?.textContent||'').trim();
        let proj = '';
        try{
          const sel = tr.cells[2]?.querySelector('select');
          if (sel){ const opt = sel.options[sel.selectedIndex]; proj = (opt && (opt.textContent||opt.label)) || sel.value || ''; }
          else { proj = (tr.cells[2]?.dataset?.project) || (tr.cells[2]?.textContent||''); }
        }catch(_){ proj = (tr.cells[2]?.textContent||''); }
        proj = String(proj||'').trim();
        const rwh = num(tr.cells[11]?.textContent) || num(tr.querySelector('.regHrs')?.value);
        const oth = num(tr.cells[12]?.textContent) || num(tr.querySelector('.otHrs')?.value);
        if (!proj) return;
        const rec = (projMap[proj] = projMap[proj] || { emp:{} });
        const er = (rec.emp[id] = rec.emp[id] || { name, rwh:0, oth:0 });
        er.rwh += rwh; er.oth += oth;
      });
      const otMult = num(document.getElementById('otMultiplier')?.value) || 1.5;
      const rates = (typeof payrollRates!=='undefined' && payrollRates) ? payrollRates : {};
      const se = (typeof storedEmployees!=='undefined' && storedEmployees) ? storedEmployees : {};
      Object.keys(projMap).forEach(p=>{
        const rec = projMap[p]; let hrs=0, gross=0;
        Object.keys(rec.emp).forEach(id=>{
          const e = rec.emp[id];
          const rate = num(se?.[id]?.hourlyRate ?? rates?.[id]);
          hrs += (e.rwh + e.oth);
          gross += (e.rwh * rate) + (e.oth * rate * otMult);
        });
        try{
          const allow = Object.keys((window.bantay||{})).reduce((sum, empId)=>{
            const assigned = (window.bantayProj||{})[empId]; if(!assigned) return sum;
            const sp = (typeof storedProjects!=='undefined' && storedProjects) ? storedProjects : {};
            const matchesById = (assigned === p);
            const matchesByName = (sp[assigned]?.name === p);
            const amt = num((window.bantay||{})[empId]);
            return (matchesById || matchesByName) ? (sum + amt) : sum;
          }, 0);
          gross += allow;
        }catch(_){ }
        rows.push({ name:p, hrs:hrs, total:gross });
      });
      rows.sort((a,b)=> a.name.localeCompare(b.name));
    }catch(e){}
    return rows;
  }

  function computeProjectTotals(){
    const fromDetailed = computeProjectTotalsFromDetailed();
    if (fromDetailed.length) return fromDetailed;
    return computeProjectTotalsFromDTR();
  }

  function renderMasterReport(){
    const host = document.getElementById('masterReportContainer'); if(!host) return;
    const sums = computeContributionTotals();
    const prows = computeProjectTotals();
    const g = prows.reduce((acc,r)=>{ acc.h += r.hrs; acc.t += r.total; return acc; }, {h:0,t:0});
    let html = '';
    html += '<h2>PAYROLL REPORT</h2>';
    html += '<div class="mr-section">';
    html += '<h4>SITE PAYROLL</h4>';
    html += '<table class="mr-table"><thead>'+
            '<tr><th colspan="2">PAG-IBIG</th><th colspan="2">PHILHEALTH</th><th colspan="2">SSS</th><th rowspan="2">SSS LOAN</th><th rowspan="2">PAG-IBIG LOAN</th></tr>'+
            '<tr><th>EE</th><th>ER</th><th>EE</th><th>ER</th><th>EE</th><th>ER</th></tr>'+
            '</thead><tbody>'+
            `<tr><td>${f2(sums.piEE)}</td><td>${f2(sums.piER)}</td><td>${f2(sums.phEE)}</td><td>${f2(sums.phER)}</td><td>${f2(sums.sssEE)}</td><td>${f2(sums.sssER)}</td><td>${f2(sums.loanSSS)}</td><td>${f2(sums.loanPI)}</td></tr>`+
            '</tbody></table>';
    html += '</div>';

    html += '<div class="mr-section" style="margin-top:16px;">';
    html += '<h4>PROJECT</h4>';
    html += '<table class="mr-table"><thead><tr><th class="left">NAME</th><th>HRS</th><th>GRAND TOTAL</th></tr></thead><tbody>';
    prows.forEach(r=>{ html += `<tr><td class="left">${safe(r.name)}</td><td>${f2(r.hrs)}</td><td>${f2(r.total)}</td></tr>`; });
    html += `</tbody><tfoot><tr><td class="left">Grand Total</td><td>${f2(g.h)}</td><td>${f2(g.t)}</td></tr></tfoot></table>`;
    html += '</div>';

    host.innerHTML = html;
  }

  function attachMasterPrint(){
    const btn = document.getElementById('mr_print');
    if (!btn || btn.__wired) return; btn.__wired = true;
    btn.addEventListener('click', function(ev){
      ev.preventDefault();
      try{
        const node = document.getElementById('masterReportContainer');
        if (!node) return; const html = '<!doctype html><html><head><meta charset="utf-8"><title>Master Report</title>'+
          '<style>body{font-family:Arial,Helvetica,sans-serif;padding:10px} table{width:100%;border-collapse:collapse;font-size:12px} th,td{border:0.6pt solid #000;padding:4px 6px} h2{text-align:center;margin:0 0 10px 0}</style>'+
          '</head><body>'+ node.innerHTML +'</body></html>';
        const w = window.open('', '', 'width=1024,height=768'); if (!w) return; w.document.open(); w.document.write(html); w.document.close(); w.focus(); setTimeout(()=>{ try{ w.print(); }catch(_){} }, 0);
      }catch(_){ window.print(); }
    });
  }

  function init(){ renderMasterReport(); attachMasterPrint(); }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); }
  else { init(); }

  try{
    const old = window.rebuildReports;
    window.rebuildReports = function(){ try{ old && old(); }catch(e){} try{ renderMasterReport(); }catch(e){} };
  }catch(e){}
})();
</script>
      </main>
    </div>
    <!-- Sidebar navigation behaviour -->
    <script>
    (function(){
      const ICONS = {
        dashboard: '📊',
        dtr: '🕒',
        schedules: '🗓️',
        employees: '👥',
        projects: '🚀',
        payroll: '💰',
        totals: '📈'
      };
      function setTitleFrom(btn){
        try{
          const pg = btn && (btn.dataset.page || btn.getAttribute('data-page')) || '';
          const label = (btn.textContent || '').replace(/^[^A-Za-z0-9]+/,'').trim();
          const icon = ICONS[pg] || '📊';
          const title = document.querySelector('.page-title');
          if (title){ title.innerHTML = '<span class="icon-emoji" style="font-size:32px">'+icon+'</span> ' + label; }
        }catch(_){}
      }
      document.querySelectorAll('.nav-link').forEach(function(link){
        link.addEventListener('click', function(e){
          e.preventDefault();
          document.querySelectorAll('.nav-link').forEach(function(l){ l.classList.remove('active'); });
          this.classList.add('active');
          setTitleFrom(this);
        });
      });
      // Initial set from the currently active tab
      const active = document.querySelector('.nav-link.active');
      if (active) setTitleFrom(active);
    })();
    function toggleSidebar(){
        var sidebar = document.getElementById('sidebar');
        if(sidebar) sidebar.classList.toggle('active');
    }
    document.addEventListener('click', function(e){
        var sidebar = document.getElementById('sidebar');
        var mobileBtn = document.querySelector('.mobile-menu-btn');
        if(window.innerWidth <= 768 && sidebar && sidebar.classList.contains('active') && !sidebar.contains(e.target) && mobileBtn && !mobileBtn.contains(e.target)){
            sidebar.classList.remove('active');
        }
    });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
   
const LS_RECORDS = 'att_records_v2';

const LS_SCHEDULES = 'att_schedules_v2';
const LS_SCHEDULES_DEFAULT = 'att_schedules_default';
const LS_EMPLOYEES = 'att_employees_v2';
const LS_PROJECTS = 'att_projects_v1';
const LS_FILTER_PROJECT = 'att_filter_project_v1';
const LS_OVERRIDES_SCHEDULES = 'att_overrides_schedules';
const LS_OVERRIDES_PROJECTS = 'att_overrides_projects';
const SPLIT_OVERRIDES_TABLE = 'split_overrides';

let overridesSchedules = JSON.parse(localStorage.getItem(LS_OVERRIDES_SCHEDULES) || '{}');
let overridesProjects = JSON.parse(localStorage.getItem(LS_OVERRIDES_PROJECTS) || '{}');
// Store per-date split flags for half-day display. When true for an empId+date,
// the DTR entry is rendered as two separate rows (AM and PM) rather than a
// single combined row. The split state is persisted in localStorage under
// LS_SPLITS. Keys are formatted as empId + '___' + date.
const LS_SPLITS = 'att_splits_v1';
let splits = {};
try {
  splits = JSON.parse(localStorage.getItem(LS_SPLITS) || '{}');
} catch (e) {
  splits = {};
}
function saveSplits() {
  try {
    localStorage.setItem(LS_SPLITS, JSON.stringify(splits));
  } catch (e) {
    console.warn('Saving splits failed', e);
  }
  syncSplitOverrides();
}
// Toggle split and unsplit state for a given employee/date key.  These helper
// functions are used by the DTR table buttons to avoid inline IIFEs.  They set
// the split flag in the `splits` object, persist it to localStorage via
// saveSplits(), and trigger a re-render of the results.
function splitRecord(key) {
  // When splitting, mark all three segments (AM, PM, OT) as split.  Use
  // an object so we can track split state per segment.
  splits[key] = { AM: true, PM: true, OT: true };
  saveSplits();
  renderResults();
}
function unsplitRecord(key) {
  // Group AM/PM/OT segments by their resolved project IDs.  Each group with
  // more than one segment is recombined (segment-level overrides cleared and
  // marked as unsplit).  Groups with a single segment remain split.
  const [empId] = key.split('___');
  const emp = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees[empId] : null;
  const defaultProj = emp && emp.projectId ? emp.projectId : '';
  let dayProj = overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, key)
    ? overridesProjects[key]
    : defaultProj;

  const segments = ['AM', 'PM', 'OT'];
  const groups = {};
  segments.forEach(seg => {
    const segKey = key + '___' + seg;
    const pid = (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, segKey))
      ? overridesProjects[segKey]
      : dayProj;
    const p = String(pid || '');
    if (!groups[p]) groups[p] = [];
    groups[p].push(seg);
  });

  let splitEntry = splits[key];
  if (!splitEntry || typeof splitEntry !== 'object') {
    splitEntry = { AM: true, PM: true, OT: true };
  }

  Object.keys(groups).forEach(proj => {
    const segs = groups[proj];
    if (segs.length > 1) {
      // Multiple segments share this project â†’ clear per-segment overrides and
      // mark them unsplit. Also set day-level override if needed.
      segs.forEach(seg => {
        const segKey = key + '___' + seg;
        if (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, segKey)) {
          delete overridesProjects[segKey];
        }
        if (overridesSchedules && Object.prototype.hasOwnProperty.call(overridesSchedules, segKey)) {
          delete overridesSchedules[segKey];
        }
        splitEntry[seg] = false;
      });
      const unifiedProj = proj;
      if (String(unifiedProj || '') !== String(defaultProj || '')) {
        overridesProjects[key] = unifiedProj;
      } else {
        delete overridesProjects[key];
      }
    } else {
      // Single segment â†’ keep its split flag
      segs.forEach(seg => { splitEntry[seg] = true; });
    }
  });

  // Remove split entry if no segments remain split
  const anySplit = segments.some(seg => splitEntry[seg]);
  if (anySplit) {
    splits[key] = splitEntry;
  } else {
    delete splits[key];
  }

  saveSplits();
  saveOverrides();
  renderResults();
}
function saveOverrides(){
  localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules));
  localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects));
  syncSplitOverrides();
}

function baseKey(k){
  const parts = String(k || '').split('___');
  return parts.length >= 2 ? parts[0] + '___' + parts[1] : k;
}
function collectOverridesForKey(src, key){
  const obj = {};
  if (src && Object.prototype.hasOwnProperty.call(src, key)) obj.base = src[key];
  ['AM','PM','OT'].forEach(function(seg){
    const segKey = key + '___' + seg;
    if (src && Object.prototype.hasOwnProperty.call(src, segKey)) obj[seg] = src[segKey];
  });
  return Object.keys(obj).length ? obj : null;
}
async function syncSplitOverrides(){
  if (!window.supabase) return;
  try {
    const keySet = new Set();
    Object.keys(splits || {}).forEach(k => keySet.add(baseKey(k)));
    Object.keys(overridesProjects || {}).forEach(k => keySet.add(baseKey(k)));
    Object.keys(overridesSchedules || {}).forEach(k => keySet.add(baseKey(k)));
    if (keySet.size === 0) return;
    const rows = [];
    keySet.forEach(function(k){
      const parts = k.split('___');
      rows.push({
        emp_id: parts[0],
        date: parts[1],
        splits: splits[k] || null,
        overrides_projects: collectOverridesForKey(overridesProjects, k),
        overrides_schedules: collectOverridesForKey(overridesSchedules, k)
      });
    });
    const { error } = await window.supabase
      .from(SPLIT_OVERRIDES_TABLE)
      .upsert(rows, { onConflict: 'emp_id,date' });
    if (error) console.warn('syncSplitOverrides error', error);
  } catch (e) {
    console.warn('syncSplitOverrides failed', e);
  }
}
async function hydrateSplitOverrides(){
  if (!window.supabase) return;
  try {
    const { data, error } = await window.supabase
      .from(SPLIT_OVERRIDES_TABLE)
      .select('*');
    if (error) throw error;
    (data || []).forEach(function(row){
      const key = row.emp_id + '___' + row.date;
      if (row.splits) splits[key] = row.splits;
      if (row.overrides_projects) {
        const proj = row.overrides_projects;
        if (proj.base != null) overridesProjects[key] = proj.base;
        ['AM','PM','OT'].forEach(function(seg){
          if (proj[seg] != null) overridesProjects[key + '___' + seg] = proj[seg];
        });
      }
      if (row.overrides_schedules) {
        const sch = row.overrides_schedules;
        if (sch.base != null) overridesSchedules[key] = sch.base;
        ['AM','PM','OT'].forEach(function(seg){
          if (sch[seg] != null) overridesSchedules[key + '___' + seg] = sch[seg];
        });
      }
    });
    try { localStorage.setItem(LS_SPLITS, JSON.stringify(splits)); } catch(e){}
    try { localStorage.setItem(LS_OVERRIDES_PROJECTS, JSON.stringify(overridesProjects)); } catch(e){}
    try { localStorage.setItem(LS_OVERRIDES_SCHEDULES, JSON.stringify(overridesSchedules)); } catch(e){}
  } catch (e) {
    console.warn('hydrate split_overrides failed', e);
  }
}


const DEFAULT_RANGES = {
  rng_am_in_start:"05:00", rng_am_in_end:"09:00",
  rng_am_out_start:"11:30", rng_am_out_end:"12:30",
  rng_pm_in_start:"12:30", rng_pm_in_end:"14:30",
  rng_pm_out_start:"15:00", rng_pm_out_end:"20:00",
  rng_ot_in_start:"19:00", rng_ot_in_end:"22:00",
  rng_ot_out_start:"19:00", rng_ot_out_end:"23:59",
  rng_sat_ot_start:"11:00", rng_sat_ot_end:"23:59"
};
const DEFAULT_SCHEDULE = {
  name: "Default",
  sch_am_start:"08:00", sch_am_end:"12:00",
  sch_pm_start:"13:00", sch_pm_end:"17:00",
  
  sch_sat_start:"", sch_sat_end:"",
  sch_grace:15,
  ...DEFAULT_RANGES

};

/*
 * Initialize the local storedRecords variable from the global store.  The
 * global `window.storedRecords` is set by the boot guard.  Avoid pulling
 * from localStorage here so that Supabase data is always preferred.  If
 * the global has not been defined for some reason, fall back to an empty
 * array.  This ensures the application never silently falls back to a
 * stale local cache when a remote dataset may be available.
 */
let storedRecords = (typeof window !== 'undefined' && Array.isArray(window.storedRecords))
  ? window.storedRecords
  : [];
let storedEmployees = JSON.parse(localStorage.getItem(LS_EMPLOYEES) || '{}');
let storedSchedules = JSON.parse(localStorage.getItem(LS_SCHEDULES) || 'null');
let defaultScheduleId = localStorage.getItem(LS_SCHEDULES_DEFAULT) || null;
let storedProjects = JSON.parse(localStorage.getItem(LS_PROJECTS) || '{}');
document.getElementById('downloadEmployeesCSV').addEventListener('click', () => {
  const header = ['ID','Name','Hourly Rate','Bank Account','Schedule Name','Schedule ID','Project Name','Project ID','Deduct Pag-IBIG','Deduct PhilHealth','Deduct SSS'];
  const rows = [header];
  Object.keys(storedEmployees).forEach(id => {
    const emp = storedEmployees[id] || {};
    const schedId = emp.scheduleId || '';
    const schedName = (storedSchedules && storedSchedules[schedId]?.name) || '';
    const projId = emp.projectId || '';
    const projName = (storedProjects && storedProjects[projId]?.name) || '';
    const bank = emp.bankAccount || '';
    const flags = (typeof contribFlags !== 'undefined' && contribFlags[id]) || {};
    const fPI = (flags.pagibig !== false) ? 'Yes' : 'No';
    const fPH = (flags.philhealth !== false) ? 'Yes' : 'No';
    const fSSS = (flags.sss !== false) ? 'Yes' : 'No';
    rows.push([id, emp.name || '', emp.hourlyRate || '', bank, schedName, schedId, projName, projId, fPI, fPH, fSSS]);
  });

  const csv = rows.map(r => r.map(v => {
    const s = String(v ?? '');
    return (s.includes(',') || s.includes('"') || s.includes('\n')) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'employees_backup.csv';
  a.click();
});

let currentProjectFilter = localStorage.getItem(LS_FILTER_PROJECT) || 'all';

function ensureSchedules(){
  if(!storedSchedules || typeof storedSchedules !== 'object'){
    const id = 'sched_' + Date.now();
    storedSchedules = {};
    storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE);
    storedSchedules[id].name = DEFAULT_SCHEDULE.name;
    defaultScheduleId = id;
    saveSchedulesToLS();
  } else {
    Object.keys(storedSchedules).forEach(id=>{
      storedSchedules[id] = { ...DEFAULT_RANGES, ...storedSchedules[id] };
      storedSchedules[id].sch_am_start = storedSchedules[id].sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
      storedSchedules[id].sch_am_end   = storedSchedules[id].sch_am_end   || DEFAULT_SCHEDULE.sch_am_end;
      storedSchedules[id].sch_pm_start = storedSchedules[id].sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
      storedSchedules[id].sch_pm_end   = storedSchedules[id].sch_pm_end   || DEFAULT_SCHEDULE.sch_pm_end;
      if(typeof storedSchedules[id].sch_grace !== 'number') storedSchedules[id].sch_grace = DEFAULT_SCHEDULE.sch_grace;
      storedSchedules[id].name = storedSchedules[id].name || 'Schedule';
    });
    if(!defaultScheduleId || !storedSchedules[defaultScheduleId]){
      const keys = Object.keys(storedSchedules);
      if(keys.length) defaultScheduleId = keys[0];
      saveSchedulesToLS();
    }
  }
}
function saveSchedulesToLS(){
  localStorage.setItem(LS_SCHEDULES, JSON.stringify(storedSchedules));
  localStorage.setItem(LS_SCHEDULES_DEFAULT, defaultScheduleId);
}

const tabs = {
  tabMain: document.getElementById('tabMain'),
  // Dashboard tab/button for high-level summary and payroll history
  tabDashboard: document.getElementById('tabDashboard'),
  tabSchedule: document.getElementById('tabSchedule'),
  tabEmployees: document.getElementById('tabEmployees'),
  tabProjects: document.getElementById('tabProjects'),
  panelMain: document.getElementById('panelMain'),
  // Corresponding Dashboard panel
  panelDashboard: document.getElementById('panelDashboard'),
  panelSchedule: document.getElementById('panelSchedule'),
  panelEmployees: document.getElementById('panelEmployees'),
  panelProjects: document.getElementById('panelProjects'),
  tabPayroll: document.getElementById('tabPayroll'),
  panelPayroll: document.getElementById('panelPayroll')
};
function showTab(name){
  Object.values(tabs).forEach(el => el && el.classList && el.classList.remove('active'));

  // Manage date range controls: disable on non-dashboard tabs, enable on dashboard unless forced
  (() => {
    const wsEl = document.getElementById('weekStart');
    const weEl = document.getElementById('weekEnd');
    if (wsEl && weEl) {
      const isDash = (name === 'dashboard');
      // Only toggle if the inputs are not forcibly disabled (e.g., due to lock/open)
      const forced = wsEl.dataset.forced === 'true' || weEl.dataset.forced === 'true';
      if (!forced) {
        wsEl.disabled = !isDash;
        weEl.disabled = !isDash;
      }
    }
  })();
  if(name==='main'){ tabs.tabMain.classList.add('active'); tabs.panelMain.classList.add('active'); }
  // When the dashboard is selected, activate its tab and panel
  if(name==='dashboard'){ tabs.tabDashboard && tabs.tabDashboard.classList.add('active'); tabs.panelDashboard && tabs.panelDashboard.classList.add('active'); }
  if(name==='schedule'){ tabs.tabSchedule.classList.add('active'); tabs.panelSchedule.classList.add('active'); renderScheduleEditor(); }
  if(name==='employees'){ tabs.tabEmployees.classList.add('active'); tabs.panelEmployees.classList.add('active'); renderEmployees(); }
  if(name==='projects'){ tabs.tabProjects.classList.add('active'); tabs.panelProjects.classList.add('active'); renderProjects(); }

  if(name==='payroll'){ tabs.tabPayroll && tabs.tabPayroll.classList.add('active'); tabs.panelPayroll && tabs.panelPayroll.classList.add('active'); }
}
window.__dtrFilterBackup = null;
// When switching to the main (DTR) tab, render results and then toggle the edit
// state based on whether the selected period is locked. Without this call,
// the DTR UI may remain interactive even when a locked payroll period is
// selected. Any errors are caught to avoid breaking tab switching.
tabs.tabMain.addEventListener('click', () => {
  showTab('main');
  try {
    if (window.__dtrFilterBackup) {
      const { name, project, from, to } = window.__dtrFilterBackup;
      const nameEl = document.getElementById('dtrSearchName');
      const projectEl = document.getElementById('filterProject');
      const fromEl = document.getElementById('dtrDateFrom');
      const toEl = document.getElementById('dtrDateTo');
      if (nameEl) nameEl.value = name;
      if (projectEl) {
        projectEl.value = project;
        currentProjectFilter = project || 'all';
        try { localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter); } catch (e) {}
      }
      if (fromEl) fromEl.value = from;
      if (toEl) toEl.value = to;
      try {
        if (from) localStorage.setItem(LS_FROM, from);
        else localStorage.removeItem(LS_FROM);
        if (to) localStorage.setItem(LS_TO, to);
        else localStorage.removeItem(LS_TO);
      } catch (e) {}
      window.__dtrFilterBackup = null;
    }
    renderResults();
  } catch (e) {}
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
});
tabs.tabSchedule.addEventListener('click', ()=>showTab('schedule'));
tabs.tabEmployees.addEventListener('click', ()=>showTab('employees'));
tabs.tabProjects.addEventListener('click', ()=>showTab('projects'));

tabs.tabPayroll.addEventListener('click', ()=>{
  try {
    const defaultBtn = document.querySelector('#panelPayroll .tabs .tab-btn[data-tab="payrollTab"]');
    if (defaultBtn) defaultBtn.click();
  } catch (e) {}

  showTab('payroll');
  // When entering the payroll tab, derive hours directly from the DTR results table
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch(e){}
});

// Switch to the dashboard tab when clicked. Render payroll history if available.
if (tabs.tabDashboard) {
  tabs.tabDashboard.addEventListener('click', () => {
    showTab('dashboard');
    try {
      if (typeof renderHistory === 'function') renderHistory();
    } catch (e) {}
  });
}

const scheduleSelect = document.getElementById('scheduleSelect');
const scheduleNameInput = document.getElementById('scheduleName');

function renderScheduleSelector(){
  scheduleSelect.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = (storedSchedules[id].name || id) + (id === defaultScheduleId ? " (Default)" : "");
    scheduleSelect.appendChild(opt);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) scheduleSelect.value = defaultScheduleId;
  else if(scheduleSelect.options.length) scheduleSelect.selectedIndex = 0;
  renderEmpScheduleDropdowns();
  renderEmpScheduleDropdownsInTable();
}

function renderScheduleEditor(){
  const sel = scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  const s = storedSchedules[sel];
  document.querySelector('[data-key="sch_am_start"]').value = s.sch_am_start || DEFAULT_SCHEDULE.sch_am_start;
  document.querySelector('[data-key="sch_am_end"]').value = s.sch_am_end || DEFAULT_SCHEDULE.sch_am_end;
  document.querySelector('[data-key="sch_pm_start"]').value = s.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start;
  document.querySelector('[data-key="sch_pm_end"]').value = s.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end;
  
  const satStartInp = document.querySelector('[data-key="sch_sat_start"]');
  const satEndInp   = document.querySelector('[data-key="sch_sat_end"]');
  if (satStartInp) satStartInp.value = (s.sch_sat_start || "");
  if (satEndInp)   satEndInp.value   = (s.sch_sat_end   || "");
document.querySelector('[data-key="sch_grace"]').value = (s.sch_grace !== undefined ? s.sch_grace : DEFAULT_SCHEDULE.sch_grace);
  scheduleNameInput.value = s.name || ("Schedule " + sel);
  document.querySelectorAll('#rangesTable input[data-key]').forEach(inp=>{
    const key = inp.dataset.key;
    inp.value = s[key] || (DEFAULT_RANGES && DEFAULT_RANGES[key]) || "";
  });
}

function gatherScheduleFromEditor(){
  return {
    name: scheduleNameInput.value.trim() || ("Schedule " + Date.now()),
    sch_am_start: document.querySelector('[data-key="sch_am_start"]').value || DEFAULT_SCHEDULE.sch_am_start,
    sch_am_end: document.querySelector('[data-key="sch_am_end"]').value || DEFAULT_SCHEDULE.sch_am_end,
    sch_pm_start: document.querySelector('[data-key="sch_pm_start"]').value || DEFAULT_SCHEDULE.sch_pm_start,
    sch_pm_end: document.querySelector('[data-key="sch_pm_end"]').value || DEFAULT_SCHEDULE.sch_pm_end,
    
    sch_sat_start: (document.querySelector('[data-key="sch_sat_start"]')?.value || ""),
    sch_sat_end:   (document.querySelector('[data-key="sch_sat_end"]')?.value   || ""),
sch_grace: Number(document.querySelector('[data-key="sch_grace"]').value || DEFAULT_SCHEDULE.sch_grace),
    ...Object.fromEntries([...document.querySelectorAll('#rangesTable input[data-key]')].map(i=>[i.dataset.key, i.value || DEFAULT_RANGES[i.dataset.key] || ""]))
  };
}

document.getElementById('addScheduleBtn').addEventListener('click', ()=>{
  const id = 'sched_' + Date.now();
  storedSchedules[id] = Object.assign({}, DEFAULT_SCHEDULE); storedSchedules[id].name = 'New schedule';
  saveSchedulesToLS(); renderScheduleSelector(); scheduleSelect.value = id; renderScheduleEditor();
});
document.getElementById('deleteScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  if(Object.keys(storedSchedules).length === 1){ alert('Cannot delete the only schedule.'); return; }
  if(!confirm('Delete schedule "' + storedSchedules[sel].name + '"?')) return;
  delete storedSchedules[sel];
  if(!storedSchedules[defaultScheduleId]) defaultScheduleId = Object.keys(storedSchedules)[0];
  Object.keys(storedEmployees).forEach(eid=>{
    if(storedEmployees[eid].scheduleId === sel) storedEmployees[eid].scheduleId = defaultScheduleId;
  });
  saveSchedulesToLS(); saveEmployeesToLS(); renderScheduleSelector(); renderEmployees(); renderResults();
});
document.getElementById('setDefaultScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return; defaultScheduleId = sel; saveSchedulesToLS(); renderScheduleSelector();
});
document.getElementById('saveScheduleBtn').addEventListener('click', ()=>{
  const sel = scheduleSelect.value; if(!sel) return;
  const oldRanges = {};
  Object.keys(DEFAULT_RANGES).forEach(k=> oldRanges[k] = (storedSchedules[sel] && storedSchedules[sel][k]) || DEFAULT_RANGES[k]);
  storedSchedules[sel] = { ...gatherScheduleFromEditor(), ...oldRanges, name: document.getElementById('scheduleName').value.trim() || storedSchedules[sel].name || 'Schedule' };
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || DEFAULT_RANGES[i.dataset.key] || "";
  });
  saveSchedulesToLS(); renderScheduleSelector(); renderEmpScheduleDropdowns(); renderResults();
});
scheduleSelect.addEventListener('change', ()=>{ renderScheduleEditor(); });

function saveRangesFromUI(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  document.querySelectorAll('#rangesTable input[data-key]').forEach(i=>{
    storedSchedules[sel][i.dataset.key] = i.value || "";
  });
  saveSchedulesToLS();
  renderResults();
}
function resetRanges(){
  const sel = scheduleSelect && scheduleSelect.value;
  if(!sel || !storedSchedules[sel]) return;
  Object.keys(DEFAULT_RANGES).forEach(k=>{
    storedSchedules[sel][k] = DEFAULT_RANGES[k];
  });
  saveSchedulesToLS();
  renderScheduleEditor();
  renderResults();
}
document.getElementById('saveRangesBtn').addEventListener('click', saveRangesFromUI);
document.getElementById('resetRangesBtn').addEventListener('click', resetRanges);

function saveEmployeesToLS(){ localStorage.setItem(LS_EMPLOYEES, JSON.stringify(storedEmployees)); }
function renderEmpScheduleDropdowns(){
  const sel = document.getElementById('empScheduleSelect'); if(!sel) return;
  sel.innerHTML = '';
  Object.keys(storedSchedules).forEach(id=>{
    const o=document.createElement('option'); o.value=id;
    o.textContent=storedSchedules[id].name + (id===defaultScheduleId?' (Default)':'');
    sel.appendChild(o);
  });
  if(defaultScheduleId && storedSchedules[defaultScheduleId]) sel.value = defaultScheduleId;
}
function renderEmpScheduleDropdownsInTable(){
  document.querySelectorAll('.emp-sel-schedule').forEach(sel=>{
    const id = sel.dataset.id;
    sel.innerHTML = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      const o = document.createElement('option'); o.value = sid; o.textContent = label;
      if(storedEmployees[id] && storedEmployees[id].scheduleId === sid) o.selected = true;
      sel.appendChild(o);
    });
  });
}

function saveProjectsToLS(){ localStorage.setItem(LS_PROJECTS, JSON.stringify(storedProjects)); renderProjects(); renderProjectDropdowns(); renderProjectFilterOptions(); renderResults(); }
function renderProjects(){
  const tbody = document.querySelector('#projectsTable tbody'); tbody.innerHTML = '';
  Object.keys(storedProjects).forEach(pid=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td><input class="cell proj-name-input" data-id="${pid}" value="${storedProjects[pid].name}"></td>
      <td><button class="del-proj" data-id="${pid}">Delete</button></td>`;
    tbody.appendChild(tr);
  });
  document.querySelectorAll('.del-proj').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const id = e.target.dataset.id;
      if(confirm('Delete project "' + storedProjects[id].name + '"?')){
        delete storedProjects[id];
        Object.keys(storedEmployees).forEach(eid=>{ if(storedEmployees[eid].projectId === id) storedEmployees[eid].projectId = null; });
        saveProjectsToLS(); saveEmployeesToLS(); renderEmployees(); renderResults();
      }
    });
  });
  document.querySelectorAll('.proj-name-input').forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.dataset.id;
      storedProjects[id].name = e.target.value;
      saveProjectsToLS();
    });
  });

}
function renderProjectDropdowns(){
  const sel = document.getElementById('empProjectSelect');
  if(!sel) return;
  sel.innerHTML = '';
  const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid=>{
    const o=document.createElement('option'); o.value=pid; o.textContent=storedProjects[pid].name; sel.appendChild(o);
  });
}
function renderEmpProjectDropdownsInTable(){
  document.querySelectorAll('.emp-sel-project').forEach(sel=>{
    const id = sel.dataset.id;
    const prev = sel.value;
    sel.innerHTML = '';
    const noneOpt = document.createElement('option'); noneOpt.value = ''; noneOpt.textContent = '(None)'; sel.appendChild(noneOpt);
    Object.keys(storedProjects).forEach(pid=>{
      const o = document.createElement('option'); o.value = pid; o.textContent = storedProjects[pid].name;
      if(storedEmployees[id] && storedEmployees[id].projectId === pid) o.selected = true;
      sel.appendChild(o);
    });
    if(prev) sel.value = prev;
  });
}

const filterProjectSel = document.getElementById('filterProject');
function renderProjectFilterOptions(){
  if(!filterProjectSel) return;
  const prev = currentProjectFilter || 'all';
  filterProjectSel.innerHTML = '';
  const make = (value, label)=>{ const o=document.createElement('option'); o.value=value; o.textContent=label; return o; };
  filterProjectSel.appendChild(make('all','All Projects'));
  filterProjectSel.appendChild(make('none','(No project)'));
  Object.keys(storedProjects).forEach(pid=>{
    filterProjectSel.appendChild(make(pid, storedProjects[pid].name));
  });
  if([...filterProjectSel.options].some(o=>o.value===prev)) filterProjectSel.value = prev;
  else filterProjectSel.value = 'all';
  currentProjectFilter = filterProjectSel.value;
}
filterProjectSel && filterProjectSel.addEventListener('change', ()=>{
  currentProjectFilter = filterProjectSel.value || 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);
  renderResults();
});

function renderEmployees(){
  renderEmpScheduleDropdowns();
  renderProjectDropdowns();
  const tbody = document.querySelector('#employeesTable tbody'); tbody.innerHTML = '';
  const ids = Object.keys(storedEmployees).sort((a,b)=>{
    const na = /^\d+$/.test(a), nb = /^\d+$/.test(b);
    if (na && nb) return Number(a) - Number(b);
    return String(a).localeCompare(String(b));
  });
ids.forEach(id => {
    const emp = storedEmployees[id];
    let scheduleOptionsHtml = '';
    Object.keys(storedSchedules).forEach(sid=>{
      const label = storedSchedules[sid].name + (sid===defaultScheduleId ? ' (Default)' : '');
      scheduleOptionsHtml += `<option value="${sid}" ${emp.scheduleId===sid ? 'selected' : ''}>${label}</option>`;
    });
    let projectOptionsHtml = `<option value="">(None)</option>`;
    Object.keys(storedProjects).forEach(pid=>{
      projectOptionsHtml += `<option value="${pid}" ${emp.projectId===pid ? 'selected' : ''}>${storedProjects[pid].name}</option>`;
    });
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${id}</td>
      <td><input class="cell emp-name-input" data-id="${id}" value="${emp.name}"></td>
      <td><input class="cell emp-rate-input" type="number" step="0.01" min="0" data-id="${id}" value="${emp.hourlyRate != null ? emp.hourlyRate : ''}" disabled></td>
      <td><select class="emp-sel-schedule" data-id="${id}">${scheduleOptionsHtml}</select></td>
      <td><select class="emp-sel-project" data-id="${id}">${projectOptionsHtml}</select></td>
      <td><input class="cell emp-bank-input" data-id="${id}" value="${emp.bankAccount != null ? emp.bankAccount : ''}"></td>
      <td><input type="checkbox" class="emp-pagibig" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].pagibig === false) ? '' : 'checked'}></td>
      <td><input type="checkbox" class="emp-philhealth" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].philhealth === false) ? '' : 'checked'}></td>
      <td><input type="checkbox" class="emp-sss" data-id="${id}" ${ (contribFlags[id] && contribFlags[id].sss === false) ? '' : 'checked'}></td>
      <td><button class="del-emp" data-id="${id}">Delete</button></td>`;
    tbody.appendChild(tr);
    // Attach event listeners for contribution checkboxes for this employee
    const cbPagibig = tr.querySelector('.emp-pagibig');
    const cbPhilhealth = tr.querySelector('.emp-philhealth');
    const cbSss = tr.querySelector('.emp-sss');
    if (cbPagibig) {
      cbPagibig.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].pagibig = cbPagibig.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
    if (cbPhilhealth) {
      cbPhilhealth.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].philhealth = cbPhilhealth.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
    if (cbSss) {
      cbSss.addEventListener('change', () => {
        if (!contribFlags[id]) contribFlags[id] = {};
        contribFlags[id].sss = cbSss.checked;
        localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
        calculateAll();
      });
    }
  });

  document.querySelectorAll('.emp-name-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].name = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-rate-input').forEach(inp=> inp.addEventListener('change', (e)=>{
    const id = e.target.dataset.id;
    const val = parseFloat(e.target.value) || 0;
    storedEmployees[id].hourlyRate = val; saveEmployeesToLS();
    try { payrollRates[id] = val; localStorage.setItem(LS_RATES, JSON.stringify(payrollRates)); } catch(err) {}
    renderResults();
  }));
document.querySelectorAll('.emp-sel-schedule').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].scheduleId = e.target.value; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.emp-sel-project').forEach(sel=> sel.addEventListener('change', (e)=>{
    storedEmployees[e.target.dataset.id].projectId = e.target.value || null; saveEmployeesToLS(); renderResults();
  }));
  document.querySelectorAll('.del-emp').forEach(btn=> btn.addEventListener('click', (e)=>{
    const id=e.target.dataset.id;
    if(confirm(`Delete employee ${id} - ${storedEmployees[id].name}?`)){
      delete storedEmployees[id]; saveEmployeesToLS(); renderEmployees(); renderResults();
    }
  }));
}

document.getElementById('addEmployeeBtn').addEventListener('click', ()=>{
  const id = document.getElementById('empIdInput').value.trim();
  const name = document.getElementById('empNameInput').value.trim();
  const rate = parseFloat(document.getElementById('empRateInput').value) || 0;
  const scheduleId = document.getElementById('empScheduleSelect').value || defaultScheduleId;
  const projectId = document.getElementById('empProjectSelect').value || null;
  const bank = document.getElementById('empBankInput').value.trim();
  if(!id){ alert('Enter ID'); return; } if(!name){ alert('Enter Name'); return; }
  storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
  // Initialize default contribution deduction flags for new employee if not already set
  if (!contribFlags[id]) {
    contribFlags[id] = { pagibig: true, philhealth: true, sss: true };
    localStorage.setItem(LS_CONTRIB_FLAGS, JSON.stringify(contribFlags));
  }
  saveEmployeesToLS();
  document.getElementById('empIdInput').value=''; document.getElementById('empNameInput').value=''; document.getElementById('empRateInput').value=''; document.getElementById('empBankInput').value='';
  renderEmployees(); renderResults();
});
document.getElementById('clearEmployeesBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all employees?')) return;
  storedEmployees = {}; saveEmployeesToLS(); renderEmployees(); renderResults();
});

document.getElementById('empFileInput').addEventListener('change', (evt) => {
  const file = evt.target.files && evt.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      
const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
let added = 0, updated = 0;
rows.slice(1).forEach(row => {
  if (row && row.length >= 2) {
    const id = String(row[0] ?? '').trim();
    const name = String(row[1] ?? '').trim();
    const rate = row.length >= 3 ? parseFloat(row[2]) || 0 : 0;
    const schedName = row.length >= 4 ? String(row[3] ?? '').trim().toLowerCase() : '';
    const projName = row.length >= 5 ? String(row[4] ?? '').trim().toLowerCase() : '';

    const bank = row.length >= 6 ? String(row[5] ?? '').trim() : '';
    if (id && name) {
      if (!storedEmployees[id]) { added++; } else { updated++; }
      let scheduleId = Object.keys(storedSchedules).find(k => storedSchedules[k].name.toLowerCase() === schedName) || defaultScheduleId;
      let projectId = Object.keys(storedProjects).find(k => storedProjects[k].name.toLowerCase() === projName) || null;

      storedEmployees[id] = { name: name, hourlyRate: rate, bankAccount: bank, scheduleId: scheduleId, projectId: projectId };
    }
  }
});
saveEmployeesToLS();
renderEmployees();
renderResults();
if (added || updated) alert(`Imported: ${added}, Updated: ${updated}`);
 renderResults();
      if(added || updated) alert('Imported: ' + added + ' added, ' + updated + ' updated.');
    } catch (err) { console.error(err); alert('Error reading file.'); }
    finally { evt.target.value = ''; }
  };
  reader.readAsArrayBuffer(file);
});

function parseLine(line){
  if(!line || !line.trim()) return null;
  const parts = line.trim().split(/\t+/);
  if(parts.length >= 2){
    const id = parts[0].trim(); const dt = parts[1].trim();
    const m = dt.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})(:\d{2})?$/);
    if(m) return { empId: id, date: m[1], time: m[2] };
  }
  const m2 = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
  if(m2){
    const before = line.slice(0, m2.index); const idm = before.match(/(\d+)/);
    if(!idm) return null; return { empId: idm[1], date: m2[1], time: m2[2].slice(0,5) };
  }
  return null;
}



document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const inputEl = ev.target;
  const files = inputEl.files;
  if (!files || !files.length) return;

  let processed = 0, totalAdded = 0, errors = 0;
  const total = files.length;
  inputEl.disabled = true;

  Array.from(files).forEach(file=>{
    // Upload the raw .DAT/.TXT file to Supabase for backup/crossâ€‘device sync.
    try {
      if (typeof uploadDtrFileToCloud === 'function') {
        uploadDtrFileToCloud(file);
      }
    } catch (err) {
      // Ignore upload errors to avoid blocking file parsing
    }
    const r = new FileReader();
    r.onload = (e)=>{
      try {
        const content = String(e.target.result || '');
        const lines = content.split(/\r?\n/);
// === MIN PATCH: Only keep records inside the current payroll period (From/To) ===
let __from = '', __to = '';
try {
  const fEl = document.getElementById('weekStart');
  const tEl = document.getElementById('weekEnd');
  __from = (fEl && fEl.value) ? fEl.value : (localStorage.getItem('payroll_week_start') || '');
  __to   = (tEl && tEl.value) ? tEl.value : (localStorage.getItem('payroll_week_end')   || '');
} catch(_) {}
function __inRange(d){
  if (!d) return false;
  if (__from && d < __from) return false;
  if (__to   && d > __to)   return false;
  return true;
}
// === /MIN PATCH ===

        let added = 0;
        for(const ln of lines){
          const p = (typeof parseLine === 'function') ? parseLine(ln) : null;
          if (p && p.empId && p.date && p.time && __inRange(p.date)){
            storedRecords.push({ empId: String(p.empId), date: p.date, time: padHM(p.time) });
            added++;
          }
        }
        // Persist records locally for offline use
        try { localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords)); } catch(e){}
        // Refresh the DTR grid
        if (typeof renderResults === 'function') renderResults();
        // Persist the records to Supabase for crossâ€‘device sync
        try {
          if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
        } catch (e) {
          console.warn('Failed to save DTR to Supabase', e);
        }
        // Hide the remote alert since we now have data after upload
        try {
          if (typeof hideRemoteDtrAlert === 'function') hideRemoteDtrAlert();
        } catch (e) {
          // ignore alert errors
        }
        totalAdded += added;
      } catch(err){
        console.error('Error reading', file.name, err);
        errors++;
      } finally {
        processed++;
        if (processed === total){
          inputEl.disabled = false; inputEl.value = '';
          if (errors > 0){
            alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
          } else {
            alert(`Upload successful: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}.`);
          }
        }
      }
    };
    r.onerror = ()=>{
      errors++; processed++;
      if (processed === total){
        inputEl.disabled = false; inputEl.value = '';
        alert(`Upload finished with errors: imported ${totalAdded} record${totalAdded!==1?'s':''} from ${total} file${total>1?'s':''}. (${errors} file${errors>1?'s':''} failed)`);
      }
    };
    r.readAsText(file);
  });
});


document.getElementById('clearData').addEventListener('click', ()=>{
  if(!confirm('Clear all saved attendance data?')) return; // Remove the locally cached attendance data
  localStorage.removeItem(LS_RECORDS);
  // Persist the cleared dataset to Supabase for crossâ€‘device sync
  try {
    if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
  } catch (e) {
    console.warn('Failed to clear DTR in Supabase', e);
  }
  // Show alert after clearing since both local and remote are now empty
  try {
    if (typeof showRemoteDtrAlert === 'function') {
      showRemoteDtrAlert('No remote DTR data found. Import a .DAT/.TXT file to populate cloud data.');
    }
  } catch (e) {}
  renderResults();
});
document.getElementById('downloadCSV').addEventListener('click', ()=>{
  const rows = [['ID','Name','Project','Schedule','Date','AM In','AM Out','PM In','PM Out','OT In','OT Out','Total Regular Hrs','OT Hrs']];
  document.querySelectorAll('#resultsTable tbody tr').forEach(tr=>{
  const cells = Array.from(tr.querySelectorAll('td')).filter(td=>!td.classList.contains('actions-cell'));
  const rowVals = cells.map(td => {
    const sel = td.querySelector && td.querySelector('select');
    if (sel && sel.options && sel.selectedIndex >= 0) {
      const opt = sel.options[sel.selectedIndex];
      return (opt && opt.textContent) ? opt.textContent.trim() : '';
    }
    return td.textContent.trim();
  });
  rows.push(rowVals);
});
const csv = rows.map(r=>r.map(c=> (c.includes('"')||c.includes(',')||c.includes('\n')) ? '"' + c.replace(/"/g,'""') + '"' : c ).join(',')).join('\n');
  const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'attendance_with_ot.csv'; document.body.appendChild(a); a.click(); a.remove();
});
function padHM(hm){ if(!hm) return ''; const [h,m]=hm.split(':').map(x=>String(Number(x)).padStart(2,'0')); return h.padStart(2,'0')+':'+m.padStart(2,'0'); }
function toMins(hm){ if(!hm) return null; const [h,m]=hm.split(':').map(Number); return h*60+m; }
function minsToDecimal(mins){ return (mins/60).toFixed(2); }

function buildScheduleDropdown(empId, date, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesSchedules[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}
function buildProjectDropdown(empId, date, currentProjectId){
  const sel = document.createElement('select');
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', ()=>{
    overridesProjects[empId + '___' + date] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

// Build a project dropdown for half-day (AM/PM) rows. Uses a key that
// appends the half identifier (e.g. '123___2023-08-19___AM') so that
// overrides can be stored separately for morning and afternoon entries.
function buildProjectDropdownHalf(empId, date, half, currentProjectId){
  const sel = document.createElement('select');
  // Include a none/default option
  const noneOpt = document.createElement('option');
  noneOpt.value = '';
  noneOpt.textContent = '(None)';
  sel.appendChild(noneOpt);
  Object.keys(storedProjects).forEach(pid => {
    const o = document.createElement('option');
    o.value = pid;
    o.textContent = storedProjects[pid].name;
    if(pid === currentProjectId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    // Persist override keyed by empId + date + half
    overridesProjects[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    // Re-render to apply changes
    renderResults();
  });
  return sel;
}

// Build a schedule dropdown for half-day (AM/PM) rows. Similar to
// buildScheduleDropdown but stores overrides using a half-specific key.
function buildScheduleDropdownHalf(empId, date, half, currentScheduleId){
  const sel = document.createElement('select');
  Object.keys(storedSchedules).forEach(sid => {
    const o = document.createElement('option');
    o.value = sid;
    o.textContent = storedSchedules[sid].name + (sid === defaultScheduleId ? ' (Default)' : '');
    if(sid === currentScheduleId) o.selected = true;
    sel.appendChild(o);
  });
  sel.addEventListener('change', () => {
    overridesSchedules[empId + '___' + date + '___' + half] = sel.value;
    saveOverrides();
    renderResults();
  });
  return sel;
}

function formatHours(value){
  const num = parseFloat(value);
  return (!isFinite(num) || num === 0) ? '-' : num.toFixed(2);
}

function renderResults(){

// 12-hour clock formatter for display only (keeps underlying logic 24h)
function __fmt12Clock(hhmm){
  if(!hhmm || typeof hhmm !== 'string') return hhmm || '';
  const m = hhmm.match(/^\s*(\d{1,2})\s*:\s*(\d{2})\s*$/);
  if(!m) return hhmm;
  let h = parseInt(m[1],10), mm = m[2];
  let suffix = 'AM';
  if(h === 0){ h = 12; suffix = 'AM'; }
  else if(h === 12){ suffix = 'PM'; }
  else if(h > 12){ h = h - 12; suffix = 'PM'; }
  else { suffix = 'AM'; }
  return h + ':' + mm + ' ' + suffix;
}


  renderScheduleSelector();
  renderProjectFilterOptions();

  // Respect DTR tab's Date filter when present; fall back to active week.
  const __df = document.getElementById('dtrDateFrom');
  const __dt = document.getElementById('dtrDateTo');
  const startDate = (__df && __df.value) ? __df.value : (document.getElementById('weekStart').value || null);
  const endDate   = (__dt && __dt.value) ? __dt.value : (document.getElementById('weekEnd').value || null);
  currentProjectFilter = document.getElementById('filterProject') ? document.getElementById('filterProject').value : 'all';
  localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter);

  
  const nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
const groups = {};
  const manualKeys = new Set();
  for(const r of storedRecords){
    if(startDate && r.date < startDate) continue;
    if(endDate && r.date > endDate) continue;
    const key = r.date + '___' + r.empId;
    if(!groups[key]) groups[key]=[];
    groups[key].push(r.time);
    if (r.manual) manualKeys.add(key);
  }

  const keys = Object.keys(groups).sort((a,b)=>{
    const [da,ea]=a.split('___'), [db,eb]=b.split('___');
    const nameA=(storedEmployees[ea] ? storedEmployees[ea].name : '').toLowerCase();
    const nameB=(storedEmployees[eb] ? storedEmployees[eb].name : '').toLowerCase();
    if(nameA && nameB){ if(nameA!==nameB) return nameA.localeCompare(nameB); if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb)); }
    if(nameA && !nameB) return -1; if(!nameA && nameB) return 1; if(da!==db) return da.localeCompare(db); return String(ea).localeCompare(String(eb));
  });

  const tbody = document.querySelector('#resultsTable tbody'); tbody.innerHTML='';
  // Track rows appended to avoid expensive DOM queries after render
  let _rowCount = 0;
  // Initialize totals for DTR summary. We will accumulate regular and OT hours and unique employee IDs
  let _dtrTotalReg = 0;
  let _dtrTotalOt  = 0;
  const _dtrEmpIds = new Set();

  const __nameQuery = (document.getElementById('dtrSearchName') ? document.getElementById('dtrSearchName').value.trim().toLowerCase() : '');
  for(const key of keys){
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId] || null;
      if (__nameQuery) { const _nm = (emp && emp.name ? String(emp.name).toLowerCase() : ''); if (_nm.indexOf(__nameQuery) === -1) continue; }
let empProjId = emp ? (emp.projectId || '') : '';
    const overrideKeyProj = empId + '___' + date;
    if(overridesProjects[overrideKeyProj] !== undefined) empProjId = overridesProjects[overrideKeyProj];
    const passesProject =
      currentProjectFilter === 'all' ||
      (currentProjectFilter === 'none' && !empProjId) ||
      currentProjectFilter === empProjId;
    let _passes = passesProject;
if(!_passes && typeof splits !== 'undefined' && splits && splits[empId + '___' + date]){
  const segs = ['AM','PM','OT'];
  for (let i=0;i<segs.length;i++){
    const hk = empId + '___' + date + '___' + segs[i];
    const pidSeg = (typeof overridesProjects !== 'undefined' && overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, hk)) ? overridesProjects[hk] : empProjId;
    if (currentProjectFilter === 'all' || (currentProjectFilter === 'none' && !pidSeg) || currentProjectFilter === pidSeg){ _passes = true; break; }
  }
}
if(!_passes) continue;

    const times = Array.from(new Set(groups[key])).sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if(overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = storedSchedules[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);
    const rangesForEmp = {
      amIn: { start: schedule.rng_am_in_start || DEFAULT_RANGES.rng_am_in_start, end: schedule.rng_am_in_end || DEFAULT_RANGES.rng_am_in_end },
      amOut:{ start: schedule.rng_am_out_start || DEFAULT_RANGES.rng_am_out_start, end: schedule.rng_am_out_end || DEFAULT_RANGES.rng_am_out_end },
      pmIn: { start: schedule.rng_pm_in_start || DEFAULT_RANGES.rng_pm_in_start, end: schedule.rng_pm_in_end || DEFAULT_RANGES.rng_pm_in_end },
      pmOut:{ start: schedule.rng_pm_out_start || DEFAULT_RANGES.rng_pm_out_start, end: schedule.rng_pm_out_end || DEFAULT_RANGES.rng_pm_out_end },
      otIn: { start: schedule.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: schedule.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
      otOut:{ start: schedule.rng_ot_out_start || DEFAULT_RANGES.rng_ot_out_start, end: schedule.rng_ot_out_end || DEFAULT_RANGES.rng_ot_out_end }
    };

    const amInActual = pickEarliest(rangesForEmp.amIn), amOutActual = pickLatest(rangesForEmp.amOut);
    const pmInActual = pickEarliest(rangesForEmp.pmIn), pmOutActual = pickLatest(rangesForEmp.pmOut);

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otCandidates = times.filter(t => {
      const mins = toMins(t);
      return mins > pmOutRefMins && mins >= toMins(rangesForEmp.otIn.start) && mins <= toMins(rangesForEmp.otIn.end);
    });
    // --- Patched OT In/Out picking (DTR) ---
const otInCandidates = times.filter(t => {
  const m = toMins(t);
  return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otIn.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otIn.end);
});
const otInActual = otInCandidates.length ? otInCandidates[0] : null;

const otOutCandidates = times
  .filter(t => {
    const m = toMins(t);
    return m > pmOutRefMins && m >= toMins(__isSaturday ? __satEnd : rangesForEmp.otOut.start) && m <= toMins(__isSaturday ? '23:59' : rangesForEmp.otOut.end);
  })
  .filter(t => !otInActual || toMins(t) >= toMins(otInActual));
const otOutActual = otOutCandidates.length ? otOutCandidates[otOutCandidates.length - 1] : null;
// --- end patch ---

// Saturday fallback: if only a single OUT exists beyond the Saturday end, treat OT as (satEnd -> lastOut)
let otInCalc = otInActual;
let otOutCalc = otOutActual;
try {
  if (__isSaturday && __satEnd) {
    const lastOut = pmOutActual || amOutActual || null;
    const lastOutM = lastOut ? toMins(lastOut) : null;
    const satEndM = toMins(__satEnd);
    if (lastOutM !== null && lastOutM > satEndM) {
      if (!otInCalc) otInCalc = __satEnd;
      if (!otOutCalc) otOutCalc = lastOut;
    }
  }
} catch(e){ console.warn('Saturday OT fallback failed', e); }


    
    
    
    // Recompute regular time deterministically (no dependency on raw 'times' array)
    let totalMins = 0; const grace = Number(schedule.sch_grace) || 0;

    const clampSeg = (inStr, outStr, segStartStr, segEndStr) => {
      // Helper to add minutes
      const addMin = (m, d) => /* no-op placeholder removed */ m; // placeholder
    
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const segStart = toMins(segStartStr), segEndRaw = toMins(segEndStr);
      let segEnd = segEndRaw;
      // Auto-correct common input mistake: PM End typed as AM (e.g., 06:00 instead of 18:00)
      if (segEnd <= segStart && segStart >= 12*60 && segEnd <= 12*60) {
        segEnd += 12*60; // push to PM
      }
      if (segEnd <= segStart) return 0;
      if (inM <= segStart + grace) inM = segStart;
      const endM = Math.min(outM, segEnd);
      return Math.max(0, endM - inM);
    };

    if (__isSaturday && __satStart && __satEnd) {
      // Use the earliest actual IN and latest actual OUT between AM/PM within the Saturday window
      const firstIn  = amInActual || pmInActual || null;
      const lastOut  = pmOutActual || amOutActual || null;
      totalMins = clampSeg(firstIn, lastOut, __satStart, __satEnd);
    } else {
      // Weekdays: compute AM and PM independently; add them
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      if (hasBridge) {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        totalMins =
          clampSeg(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          clampSeg(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      } else {
        const amMins = clampSeg(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
        const pmMins = clampSeg(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
        totalMins = amMins + pmMins;
      }
    }

    const totalRegularDecimal = minsToDecimal(totalMins);
let otMins = 0;
    if(otInCalc && otOutCalc){
      const otStartClamp = Math.max(toMins(otInCalc), toMins(__isSaturday ? (__satEnd || rangesForEmp.otIn.start) : rangesForEmp.otIn.start));
      const otEndClamp   = Math.min(toMins(otOutCalc), toMins(__isSaturday ? '23:59' : (rangesForEmp.otOut.end || rangesForEmp.otIn.end)));
      if(otEndClamp > otStartClamp) otMins = otEndClamp - otStartClamp;
    }
    
    // Saturday definitive OT computation: last OUT beyond Saturday end is OT
    try {
      if (__isSaturday && __satEnd) {
        const lastOut = (pmOutActual || amOutActual || null);
        if (lastOut) {
          const satEndM = toMins(__satEnd);
          const satStartClamp = Math.max(satEndM, toMins(schedule.rng_sat_ot_start || __satEnd || DEFAULT_RANGES.rng_sat_ot_start));
          const satEndClamp   = toMins(schedule.rng_sat_ot_end || DEFAULT_RANGES.rng_sat_ot_end);
          const lastOutM = toMins(lastOut);
          const startM = satStartClamp;
          const endM   = Math.min(lastOutM, satEndClamp);
          const diff = endM - startM;
          if (diff > 0) otMins = diff;
        }
      }
    } catch(e){ console.warn('Saturday OT direct compute failed', e); }

    // Fallback OT computation for nonâ€‘Saturday days.
    // When there are no explicit OT punches (or the OT IN occurs before
    // the end of the regular shift), treat any minutes worked beyond
    // the scheduled PM end as overtime. Only the final clockâ€‘out time
    // is considered to avoid counting intermediate segments.
    try {
      if (!__isSaturday) {
        // Determine the reference end time for regular work (PM shift end)
        const pmRef = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end || (typeof DEFAULT_SCHEDULE !== 'undefined' ? DEFAULT_SCHEDULE.sch_pm_end : '17:00'));
        // Determine if explicit OT was applied (OT IN after PM end)
        let hasExplicitOT = false;
        if (typeof otInCalc !== 'undefined' && typeof otOutCalc !== 'undefined' && otInCalc && otOutCalc) {
          const otInM = toMins(otInCalc);
          if (otInM > pmRef) hasExplicitOT = true;
        }
        if (!hasExplicitOT) {
          const lastOutFallback = pmOutActual || amOutActual || null;
          if (lastOutFallback) {
            const lastOutM = toMins(lastOutFallback);
            if (lastOutM > pmRef) {
              otMins = lastOutM - pmRef;
            }
          }
        }
      }
    } catch(err) { console.warn('Nonâ€‘Saturday OT fallback failed', err); }

    const otDecimal = minsToDecimal(otMins);

    // --- Begin AM/PM/OT Split Logic ---
    // If this record is flagged for split, render separate rows for the AM,
    // PM and OT portions instead of one combined row. A split is recorded
    // in the `splits` object keyed by the employee/date (empId + '___' + date).
    // When a record is split we compute the regular hours and overtime
    // separately for each segment using the schedule assigned to that half
    // (any overrides are honoured). Each segment has its own project and
    // schedule dropdowns. Grace periods are applied according to the
    // selected schedule.

    const splitKey = empId + '___' + date;
    let splitEntry = splits && splits[splitKey];
    if (splitEntry) {
      if (splitEntry === true) splitEntry = { AM: true, PM: true, OT: true };
      const name = emp ? emp.name : '';
      const merged = { regMins:0, otMins:0, amIn:null, amOut:null, pmIn:null, pmOut:null, otIn:null, otOut:null, count:0 };
      const clampSegHalf = (inStr, outStr, segStartStr, segEndStr, sched) => {
        if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
        let inM = toMins(inStr);
        const outM = toMins(outStr);
        const segStart = toMins(segStartStr);
        let segEnd = toMins(segEndStr);
        if (segEnd <= segStart && segStart >= 12 * 60 && segEnd <= 12 * 60) segEnd += 12 * 60;
        if (segEnd <= segStart) return 0;
        const g = Number(sched && sched.sch_grace) || 0;
        if (inM <= segStart + g) inM = segStart;
        const endM = Math.min(outM, segEnd);
        return Math.max(0, endM - inM);
      };
      const computeOtHalf = (sched) => {
        let otM = 0, otIn = null, otOut = null;
        let pmOutRef = pmOutActual ? toMins(pmOutActual) : toMins(sched.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end);
        let isSat = false, satStart = null, satEnd = null;
        try {
          const dow = (function(d){ const dt = new Date(d + 'T00:00'); return (isNaN(dt) ? new Date(d) : dt).getDay(); })(date);
          if (dow === 6) { isSat = true; satStart = sched.sch_sat_start || sched.sch_am_start || '08:00'; satEnd = sched.sch_sat_end || sched.sch_pm_end || sched.sch_am_end || '11:00'; pmOutRef = toMins(satEnd); }
        } catch(e){}
        const rng = {
          otIn: { start: sched.rng_ot_in_start || DEFAULT_RANGES.rng_ot_in_start, end: sched.rng_ot_in_end || DEFAULT_RANGES.rng_ot_in_end },
          otOut:{ start: sched.rng_ot_out_start||DEFAULT_RANGES.rng_ot_out_start, end: sched.rng_ot_out_end||DEFAULT_RANGES.rng_ot_out_end }
        };
        const otInCands = times.filter(t=>{ const m=toMins(t); return m>pmOutRef && m>=toMins(isSat?satEnd:rng.otIn.start) && m<=toMins(isSat?'23:59':rng.otIn.end); });
        otIn = otInCands.length ? otInCands[0] : null;
        const otOutCands = times.filter(t=>{ const m=toMins(t); return m>pmOutRef && m>=toMins(isSat?satEnd:rng.otOut.start) && m<=toMins(isSat?'23:59':rng.otOut.end); }).filter(t=>!otIn||toMins(t)>=toMins(otIn));
        otOut = otOutCands.length ? otOutCands[otOutCands.length-1] : null;
        if (isSat && satEnd) { const lastOut=pmOutActual||amOutActual||null; const lastOutM=lastOut?toMins(lastOut):null; const satEndM=toMins(satEnd); if (lastOutM!==null&&lastOutM>satEndM){ if(!otIn) otIn=satEnd; if(!otOut) otOut=lastOut; } }
        if (otIn && otOut) { const startClamp=Math.max(toMins(otIn), toMins(isSat?(satEnd||rng.otIn.start):rng.otIn.start)); const endClamp=Math.min(toMins(otOut), toMins(isSat?'23:59':(rng.otOut.end||rng.otIn.end))); if(endClamp>startClamp) otM=endClamp-startClamp; }
        return { mins: otM, otIn: otIn, otOut: otOut };
      };
      const hasBridge = !!(amInActual && !amOutActual && !pmInActual && pmOutActual);
      const middayStart = schedule.sch_am_end || '12:00';
      const middayEnd   = schedule.sch_pm_start || '13:00';
      ['AM','PM','OT'].forEach(segment => {
        const halfKey = empId + '___' + date + '___' + segment;
        const schedIdHalf = (overridesSchedules && overridesSchedules[halfKey]) ? overridesSchedules[halfKey] : scheduleIdForEmp;
        const schedHalf = storedSchedules[schedIdHalf] || DEFAULT_SCHEDULE;
        let regMinsSeg=0, otMinsSeg=0, otInSeg=null, otOutSeg=null;
        if(segment==='AM'){ regMinsSeg = hasBridge ? clampSegHalf(amInActual, middayStart, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf) : clampSegHalf(amInActual, amOutActual, schedHalf.sch_am_start || DEFAULT_SCHEDULE.sch_am_start, schedHalf.sch_am_end || DEFAULT_SCHEDULE.sch_am_end, schedHalf); }
        else if(segment==='PM'){ regMinsSeg = hasBridge ? clampSegHalf(middayEnd, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf) : clampSegHalf(pmInActual, pmOutActual, schedHalf.sch_pm_start || DEFAULT_SCHEDULE.sch_pm_start, schedHalf.sch_pm_end || DEFAULT_SCHEDULE.sch_pm_end, schedHalf); }
        else { const otRes=computeOtHalf(schedHalf); otMinsSeg=otRes.mins; otInSeg=otRes.otIn; otOutSeg=otRes.otOut; }
        const regDecSeg = minsToDecimal(regMinsSeg);
        const otDecSeg = segment==='OT'? minsToDecimal(otMinsSeg):'0.00';
        let projIdSeg = (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey)) ? overridesProjects[halfKey] : empProjId;
        const __segPass = (currentProjectFilter === 'all' || (currentProjectFilter === 'none' && !projIdSeg) || currentProjectFilter === projIdSeg);
        if(!__segPass){ return; }
        if (splitEntry[segment]) {
          const trSeg = document.createElement('tr');
          let htmlSeg='';
          htmlSeg += '<td>' + __fmt12Clock(empId) + '</td>';
          htmlSeg += '<td>' + (name || '') + '</td>';
          htmlSeg += '<td></td><td></td>';
          htmlSeg += '<td>' + __fmt12Clock(date) + '</td>';
          if(segment==='AM'){
            htmlSeg += (amInActual ? '<td>' + __fmt12Clock(amInActual) + '</td>' : '<td class="missing">-</td>');
            htmlSeg += (hasBridge || !amOutActual) ? '<td class="missing">-</td>' : '<td>' + __fmt12Clock(amOutActual) + '</td>';
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
          } else if(segment==='PM'){
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
            htmlSeg += (hasBridge || !pmInActual) ? '<td class="missing">-</td>' : '<td>' + __fmt12Clock(pmInActual) + '</td>';
            htmlSeg += (pmOutActual ? '<td>' + __fmt12Clock(pmOutActual) + '</td>' : '<td class="missing">-</td>');
          } else {
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td><td class="missing">-</td><td class="missing">-</td>';
          }
          if(segment==='OT'){
            htmlSeg += (otInSeg ? '<td>'+__fmt12Clock(otInSeg)+'</td>' : '<td class="missing">-</td>');
            htmlSeg += (otOutSeg ? '<td>'+__fmt12Clock(otOutSeg)+'</td>' : '<td class="missing">-</td>');
          } else {
            htmlSeg += '<td class="missing">-</td><td class="missing">-</td>';
          }
          htmlSeg += '<td>' + formatHours(regDecSeg) + '</td>';
          htmlSeg += '<td>' + formatHours(otDecSeg) + '</td>';
          htmlSeg += '<td>' + formatHours(String((parseFloat(regDecSeg)||0)+(parseFloat(otDecSeg)||0))) + '</td>';
          htmlSeg += '<td><button type="button" class="btn-unsplit" data-key="' + splitKey + '" onclick="unsplitRecord(this.dataset.key)">Unsplit</button></td>';
          // Ensure Actions column always has a Delete button for split rows
          htmlSeg += '<td class="actions-cell"><button type="button" class="dtr-del-btn">Delete</button></td>';
          trSeg.innerHTML = htmlSeg;
          try {
            if (typeof manualKeys !== 'undefined' && manualKeys.has(splitKey)) {
              const nmCellSeg = trSeg.cells[1];
              if (nmCellSeg && !nmCellSeg.querySelector('.manual-indicator')) {
                const s2 = document.createElement('span');
                s2.className = 'manual-indicator';
                s2.title = 'Contains manual DTR';
                s2.textContent = '*';
                nmCellSeg.appendChild(s2);
              }
            }
          } catch(e){}
          const hasOverrideSeg = (overridesSchedules && overridesSchedules[halfKey]) || (overridesProjects && Object.prototype.hasOwnProperty.call(overridesProjects, halfKey));
          if (hasOverrideSeg) { trSeg.style.backgroundColor = '#fff3cd'; }
          const pcSeg = trSeg.cells[2]; if (pcSeg) { pcSeg.innerHTML=''; pcSeg.appendChild(buildProjectDropdownHalf(empId, date, segment, projIdSeg)); }
          const scSeg = trSeg.cells[3]; if (scSeg) { scSeg.innerHTML=''; scSeg.appendChild(buildScheduleDropdownHalf(empId, date, segment, schedIdHalf)); }
          trSeg.dataset.empId = empId; trSeg.dataset.date = date; trSeg.dataset.half = segment;
          (function(){
            const timesForHalf=[];
            if(segment==='AM'){ if(amInActual) timesForHalf.push(amInActual); if(!hasBridge && amOutActual) timesForHalf.push(amOutActual); }
            else if(segment==='PM'){ if(!hasBridge && pmInActual) timesForHalf.push(pmInActual); if(pmOutActual) timesForHalf.push(pmOutActual); }
            else { if(otInSeg) timesForHalf.push(otInSeg); if(otOutSeg) timesForHalf.push(otOutSeg); }
            trSeg.dataset.times=JSON.stringify(timesForHalf);
          })();
          tbody.appendChild(trSeg);
          _rowCount++;
          const _regVal=parseFloat(regDecSeg)||0; const _otVal=parseFloat(otDecSeg)||0;
          _dtrTotalReg+=_regVal; _dtrTotalOt+=_otVal; _dtrEmpIds.add(empId);
        } else {
          merged.count++;
          if(segment==='AM'){ merged.regMins+=regMinsSeg; merged.amIn=amInActual; merged.amOut=hasBridge?middayStart:amOutActual; }
          else if(segment==='PM'){ merged.regMins+=regMinsSeg; merged.pmIn=hasBridge?middayEnd:pmInActual; merged.pmOut=pmOutActual; }
          else { merged.otMins+=otMinsSeg; merged.otIn=otInSeg; merged.otOut=otOutSeg; }
        }
      });
      if (merged.count) {
        const tr = document.createElement('tr');
        const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');
        const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
        const cell = (v) => v ? '<td>' + __fmt12Clock(v) + '</td>' : '<td class="missing">-</td>';
        const regDec = minsToDecimal(merged.regMins);
        const otDec = minsToDecimal(merged.otMins);
        tr.innerHTML = '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
          cell(merged.amIn) + cell(merged.amOut) + cell(merged.pmIn) + cell(merged.pmOut) +
          (merged.otIn ? '<td>'+__fmt12Clock(merged.otIn)+'</td>' : '<td class="missing">-</td>') +
          (merged.otOut ? '<td>'+__fmt12Clock(merged.otOut)+'</td>' : '<td class="missing">-</td>') +
          '<td>'+formatHours(regDec)+'</td><td>'+formatHours(otDec)+'</td><td>'+formatHours(minsToDecimal(merged.regMins + merged.otMins))+'</td>' +
          '<td><button type="button" class="btn-split" data-key="'+splitKey+'" onclick="splitRecord(this.dataset.key)">Split</button></td>';
        if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){ tr.style.backgroundColor='#fff3cd'; }
        try{
          if (typeof manualKeys !== 'undefined' && manualKeys.has(splitKey)) {
            const nmCell = tr.cells[1];
            if (nmCell && !nmCell.querySelector('.manual-indicator')) {
              const s = document.createElement('span');
              s.className='manual-indicator';
              s.title='Contains manual DTR';
              s.textContent='*';
              nmCell.appendChild(s);
            }
          }
        }catch(e){}
        const projCell = tr.cells[2]; if(projCell){ projCell.innerHTML=''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
        const schedCell = tr.cells[3]; if(schedCell){ schedCell.innerHTML=''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
        tbody.appendChild(tr);
        const _regVal=parseFloat(regDec)||0; const _otVal=parseFloat(otDec)||0; _dtrTotalReg+=_regVal; _dtrTotalOt+=_otVal; _dtrEmpIds.add(empId);
      }
      continue;
    }

    // --- End AM/PM/OT Split Logic ---

    const name = emp ? emp.name : '';
    const scheduleName = storedSchedules[scheduleIdForEmp] ? storedSchedules[scheduleIdForEmp].name + (scheduleIdForEmp===defaultScheduleId ? ' (Default)' : '') : '';
    const projectName = (empProjId && storedProjects[empProjId]) ? storedProjects[empProjId].name : (emp && !emp.projectId ? '' : '');

    const cell = (v) => v ? '<td>' + __fmt12Clock(v) + '</td>' : '<td class="missing">-</td>';
    const tr = document.createElement('tr');
    const __tot = ((parseFloat(totalRegularDecimal)||0)+(parseFloat(otDecimal)||0));
    tr.innerHTML =
      '<td>'+empId+'</td><td>'+name+'</td><td>'+projectName+'</td><td>'+scheduleName+'</td><td>'+date+'</td>' +
      cell(amInActual) + cell(amOutActual) + cell(pmInActual) + cell(pmOutActual) +
      (otInCalc ? '<td>' + __fmt12Clock(otInCalc) + '</td>' : '<td class=\"missing\">-</td>') +
      (otOutCalc ? '<td>' + __fmt12Clock(otOutCalc) + '</td>' : '<td class=\"missing\">-</td>') +
      '<td>'+formatHours(totalRegularDecimal)+'</td><td>'+formatHours(otDecimal)+'</td><td>'+formatHours(__tot)+'</td>' +
      // Use a named handler with a data-key attribute instead of an inline IIFE.
      '<td><button type="button" class="btn-split" data-key="' + empId + '___' + date + '" onclick="splitRecord(this.dataset.key)">Split</button></td>' +
      // Ensure Actions column always has a Delete button for unsplit rows
      '<td class="actions-cell"><button type="button" class="dtr-del-btn">Delete</button></td>';
    if(overridesSchedules[overrideKey] || overridesProjects[overrideKeyProj] !== undefined){
      tr.style.backgroundColor = '#fff3cd';
    }
    // Add a star indicator next to the Name if this row contains manual DTR entries
    try {
      if (typeof manualKeys !== 'undefined' && manualKeys.has(key)) {
        const nmCell = tr.cells[1];
        if (nmCell && !nmCell.querySelector('.manual-indicator')) {
          const s = document.createElement('span');
          s.className = 'manual-indicator';
          s.title = 'Contains manual DTR';
          s.textContent = '*';
          nmCell.appendChild(s);
        }
      }
    } catch(e){}
    const projCell = tr.cells[2];
    if(projCell){ projCell.innerHTML = ''; projCell.appendChild(buildProjectDropdown(empId, date, empProjId)); }
    const schedCell = tr.cells[3];
    if(schedCell){ schedCell.innerHTML = ''; schedCell.appendChild(buildScheduleDropdown(empId, date, scheduleIdForEmp)); }
    tbody.appendChild(tr);
    _rowCount++;
    // Accumulate totals for unsplit rows
    const _regVal = parseFloat(totalRegularDecimal) || 0;
    const _otVal  = parseFloat(otDecimal) || 0;
    _dtrTotalReg += _regVal;
    _dtrTotalOt  += _otVal;
    _dtrEmpIds.add(empId);
  }

  // Show/hide download button
  document.getElementById('downloadCSV').style.display = _rowCount ? 'inline-block' : 'none';
  // --- DTR Summary ---
  // After building the table, update the summary using accumulated totals
  (function(){
    const summaryEl = document.getElementById('dtrSummary');
    if (!summaryEl) return;
    const rowCount = _rowCount;
    if (!rowCount) {
      summaryEl.textContent = '';
      return;
    }
    // Compute combined total hours (regular + OT)
    const _dtrTotalHours = _dtrTotalReg + _dtrTotalOt;
    summaryEl.textContent = `Grand Total Hours: ${formatHours(_dtrTotalHours)} | Regular Hours: ${formatHours(_dtrTotalReg)} | OT Hours: ${formatHours(_dtrTotalOt)} | Employees: ${_dtrEmpIds.size}`;
  })();

(function(){
  const tbl = document.getElementById('resultsTable');
  if (!tbl) return;
  // Create/clear tfoot
  let foot = tbl.querySelector('tfoot#resultsFoot');
  if (!foot) {
    foot = document.createElement('tfoot');
    foot.id = 'resultsFoot';
    tbl.appendChild(foot);
  }
  // Locate important columns by header text
  const ths = Array.from(tbl.querySelectorAll('thead th'));
  const norm = s => String((s||'')).trim().toLowerCase();
  const regIdx = ths.findIndex(th => (function(t){t=String(t||'').trim().toLowerCase();return t==='regular hrs'||t==='total regular hrs';})(th.textContent));
  const otIdx  = ths.findIndex(th => norm(th.textContent) === 'ot hrs');
  const totIdx = ths.findIndex(th => norm(th.textContent) === 'total hours');
  const nameIdx = ths.findIndex(th => norm(th.textContent) === 'name');
  const cols = ths.length;
  // Values: prefer internal running totals if present; otherwise sum from table
  function sumCol(idx){
    if (idx < 0) return 0;
    let s = 0;
    const rows = (tbl.tBodies && tbl.tBodies[0]) ? Array.from(tbl.tBodies[0].rows) : [];
    rows.forEach(tr => {
      const td = tr.cells[idx]; if (!td) return;
      const v = parseFloat(String(td.textContent||'').replace(/[^0-9.\-]/g,''));
      if (!isNaN(v)) s += v;
    });
    return s;
  }
  const reg = (typeof _dtrTotalReg === 'number') ? _dtrTotalReg : sumCol(regIdx);
  const ot  = (typeof _dtrTotalOt  === 'number') ? _dtrTotalOt  : sumCol(otIdx);
  const tot = reg + ot;
  const empCount = (typeof _dtrEmpIds === 'object' && _dtrEmpIds) ? _dtrEmpIds.size : (window.__lastEmpCount || 0);
  // Build row with cells aligned to columns
  const tr = document.createElement('tr');
  tr.className = 'totals-row';
  for (let i=0;i<cols;i++){
    const td = document.createElement('td');
    td.style.fontWeight = '700';
    td.style.background = '#fafafa';
    if (i===nameIdx) { td.textContent = 'Employees: ' + empCount; td.style.textAlign = 'left'; }
    else if (i===regIdx) { td.textContent = formatHours(reg); td.style.textAlign = 'right'; }
    else if (i===otIdx)  { td.textContent = formatHours(ot);  td.style.textAlign = 'right'; }
    else if (i===totIdx) { td.textContent = formatHours(tot); td.style.textAlign = 'right'; }
    else if (i===0)      { td.textContent = 'Totals:'; td.style.textAlign = 'left'; }
    else { td.textContent = ''; }
    const headTxt = norm(ths[i] && ths[i].textContent);
      if (headTxt === 'split' || headTxt === 'actions') { td.style.display='none'; td.style.border='0'; }
      tr.appendChild(td);
  }
  foot.innerHTML = '';
  foot.appendChild(tr);
  // Hide old textual summary
  const summaryEl = document.getElementById('dtrSummary');
  if (summaryEl){ summaryEl.textContent = ''; summaryEl.style.display = 'none'; }
})();
}

document.getElementById('addProjectBtn').addEventListener('click', ()=>{
  const name = document.getElementById('projectNameInput').value.trim();
  if(!name) return alert('Enter project name');
  const id = 'proj_' + Date.now();
  storedProjects[id] = { name };
  document.getElementById('projectNameInput').value='';
  saveProjectsToLS();
});
document.getElementById('clearProjectsBtn').addEventListener('click', ()=>{
  if(!confirm('Clear all projects?')) return;
  storedProjects = {}; saveProjectsToLS();
});

async function initApp(){
  await hydrateSplitOverrides();
  ensureSchedules();
  renderScheduleSelector();
  renderScheduleEditor();
  renderEmployees();
  renderProjects();
  renderProjectFilterOptions();
  const savedFilter = localStorage.getItem(LS_FILTER_PROJECT);
  if(document.getElementById('filterProject') && savedFilter && [...document.getElementById('filterProject').options].some(o=>o.value===savedFilter)){
    document.getElementById('filterProject').value = savedFilter;
    currentProjectFilter = savedFilter;
  }
  renderResults();
}
initApp();
document.addEventListener('DOMContentLoaded', function () {
  const dlBtn = document.getElementById('downloadEmployeesCSV');
  if (dlBtn) {
    dlBtn.addEventListener('click', () => {
      const header = ['ID','Name','Hourly Rate','Bank Account','Schedule Name','Schedule ID','Project Name','Project ID','Deduct Pag-IBIG','Deduct PhilHealth','Deduct SSS'];
      const rows = [header];
      Object.keys(storedEmployees).forEach(id => {
        const emp = storedEmployees[id] || {};
        const schedId = emp.scheduleId || '';
        const schedName = (storedSchedules && storedSchedules[schedId]?.name) || '';
        const projId = emp.projectId || '';
        const projName = (storedProjects && storedProjects[projId]?.name) || '';
        const bank = emp.bankAccount || '';
        const flags = (typeof contribFlags !== 'undefined' && contribFlags[id]) || {};
        const fPI = (flags.pagibig !== false) ? 'Yes' : 'No';
        const fPH = (flags.philhealth !== false) ? 'Yes' : 'No';
        const fSSS = (flags.sss !== false) ? 'Yes' : 'No';
        rows.push([id, emp.name || '', emp.hourlyRate || '', bank, schedName, schedId, projName, projId, fPI, fPH, fSSS]);
      });
      const csv = rows.map(r => r.map(v => {
        const s = String(v ?? '');
        return (s.includes(',') || s.includes('"') || s.includes('\\n'))
          ? '"' + s.replace(/"/g,'""') + '"'
          : s;
      }).join(',')).join('\\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'employees_backup.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
  }
});
  </script>
  <script>
function computeHoursForDateRange(startDate, endDate) {
  const totalsReg = {};
  const totalsOT = {};
  Object.keys(storedEmployees).forEach(id => {
    totalsReg[id] = 0;
    totalsOT[id] = 0;
  });

  const keys = Object.keys(storedSchedules).length ? storedSchedules : {default: DEFAULT_SCHEDULE};
  const grouped = {};

  for (const r of storedRecords) {
    if (startDate && r.date < startDate) continue;
    if (endDate && r.date > endDate) continue;
    const emp = storedEmployees[r.empId];
    if (!emp) continue;
    const dayKey = r.date + '___' + r.empId;
    if (!grouped[dayKey]) grouped[dayKey] = [];
    grouped[dayKey].push(r.time);
  }

  const toMins = hm => { const [h,m] = hm.split(':').map(Number); return h*60+m; };
  const minsToDec = mins => mins / 60;

  for (const key in grouped) {
    const [date, empId] = key.split('___');
    const emp = storedEmployees[empId];
    if (!emp) continue;

    let scheduleIdForEmp = emp && emp.scheduleId ? emp.scheduleId : defaultScheduleId;
    const overrideKey = empId + '___' + date;
    if (overridesSchedules[overrideKey]) scheduleIdForEmp = overridesSchedules[overrideKey];
    const schedule = keys[scheduleIdForEmp] || Object.assign({}, DEFAULT_SCHEDULE);

    const times = [...new Set(grouped[key])].sort();

    const pickEarliest = (win) => times.find(t => t >= win.start && t <= win.end) || null;
    const pickLatest = (win) => { const arr = times.filter(t => t >= win.start && t <= win.end); return arr.length ? arr[arr.length-1] : null; };

    const amInActual = pickEarliest({start: schedule.rng_am_in_start, end: schedule.rng_am_in_end});
    const amOutActual = pickLatest({start: schedule.rng_am_out_start, end: schedule.rng_am_out_end});
    const pmInActual = pickEarliest({start: schedule.rng_pm_in_start, end: schedule.rng_pm_in_end});
    const pmOutActual = pickLatest({start: schedule.rng_pm_out_start, end: schedule.rng_pm_out_end});

    let pmOutRefMins = pmOutActual ? toMins(pmOutActual) : toMins(schedule.sch_pm_end);

    
    
    // === Saturday rule (scoped) ===
    // Use local flags/vars so other days are untouched.
    let __isSaturday = false, __satStart = null, __satEnd = null;
    try {
      const __dow = (function(d){
        const dt = new Date(d + 'T00:00');
        return (isNaN(dt) ? new Date(d) : dt).getDay();
      })(date);
      if (__dow === 6) { // Saturday
        __isSaturday = true;
        const satStart = schedule.sch_sat_start || schedule.sch_am_start || "08:00";
        const satEnd   = schedule.sch_sat_end   || schedule.sch_pm_end || schedule.sch_am_end || "11:00";
        __satStart = satStart;
        __satEnd   = satEnd;
        // For OT picking, any time after scheduled end counts as OT
        pmOutRefMins = toMins(satEnd);
      }
    } catch(e){ console.warn('Saturday OT local patch error', e); }
const otInActual = pickEarliest({start: schedule.rng_ot_in_start, end: schedule.rng_ot_in_end});
    const otOutActual = pickLatest({start: schedule.rng_ot_out_start, end: schedule.rng_ot_out_end});

    let regMins = 0;
    const grace = Number(schedule.sch_grace) || 0;
    const segMins = (inStr, outStr, segStartStr, segEndStr) => {
      if (!inStr || !outStr || !segStartStr || !segEndStr) return 0;
      let inM = toMins(inStr);
      const outM = toMins(outStr);
      const sS = toMins(segStartStr), sEraw = toMins(segEndStr);
      let sE = sEraw;
      if (sE <= sS && sS >= 12*60 && sE <= 12*60) sE += 12*60; // fix 06:00 vs 18:00 typo
      if (sE <= sS) return 0;
      if (inM <= sS + grace) inM = sS; // grace on start
      const endM = Math.min(outM, sE);
      return Math.max(0, endM - inM);
    };
    // Compute regular minutes.  Use Saturday-specific start/end ranges when
    // applicable; otherwise fall back to the normal AM/PM schedule ranges.
    if (__isSaturday) {
      // On Saturdays, clamp both AM and PM segments to the Saturday window
      regMins += segMins(amInActual, amOutActual, __satStart, __satEnd);
      regMins += segMins(pmInActual, pmOutActual, __satStart, __satEnd);
    } else {
      regMins += segMins(amInActual, amOutActual, schedule.sch_am_start, schedule.sch_am_end);
      regMins += segMins(pmInActual, pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
    }
    // Bridge case: AM IN + PM OUT only.  If no regular minutes were
    // computed above, but we have an AM clock-in and a PM clock-out,
    // synthesize a noon break.  On Saturdays, treat the entire day as
    // a single continuous window between __satStart and __satEnd.
    if (regMins === 0 && amInActual && !amOutActual && !pmInActual && pmOutActual) {
      if (__isSaturday) {
        // Saturday bridging: compute the full span between the first
        // clock-in and final clock-out within the Saturday window.
        regMins = segMins(amInActual, pmOutActual, __satStart, __satEnd);
      } else {
        const synthAmOut = schedule.sch_am_end || "12:00";
        const synthPmIn  = schedule.sch_pm_start || "13:00";
        regMins =
          segMins(amInActual, synthAmOut, schedule.sch_am_start, schedule.sch_am_end) +
          segMins(synthPmIn,  pmOutActual, schedule.sch_pm_start, schedule.sch_pm_end);
      }
    }
    totalsReg[empId] += minsToDec(regMins);

    /*
     * Compute OT minutes for the current day/employee.  There are three
     * scenarios handled here:
     *
     *   1) Saturday: Any time worked after the scheduled Saturday end
     *      counts as OT, regardless of whether explicit OT punches were
     *      recorded.  Each in/out segment contributes separately to the
     *      OT total.  The resulting OT minutes are added to the employee's
     *      running total.
     *
     *   2) Nonâ€‘Saturday with explicit OT punches: When OT In and OT Out
     *      times are recorded and the OT In occurs after the normal
     *      scheduled end (pmOutRefMins), compute OT as the difference
     *      between OT Out and OT In.  This respects the configured OT
     *      ranges and leaves any early departures uncounted.
     *
     *   3) Nonâ€‘Saturday without explicit OT punches: When no valid OT
     *      punches exist but there is a single endâ€‘ofâ€‘day clockâ€‘out, treat
     *      any minutes worked after the scheduled end as OT.  This
     *      allows afterâ€‘hours work to be captured without requiring
     *      separate OT punches.  If multiple segments exist for the day
     *      (more than one in/out pair), only the final clockâ€‘out is
     *      considered for the fallback; intermediate segments are
     *      presumed to be normal work/breaks and do not contribute to OT.
     */
    let dayOTMins = 0;
    if (__isSaturday) {
      // Saturday override: sum minutes worked after the Saturday end for
      // every recorded segment.  Each segment contributes its own OT
      // minutes without regard to explicit OT punches.
      let extraOTMins = 0;
      const satEndM = toMins(__satEnd);
      for (let i = 0; i < times.length; i += 2) {
        const inStr  = times[i];
        const outStr = times[i+1];
        if (!outStr) continue;
        const inM  = toMins(inStr);
        const outM = toMins(outStr);
        const startM = Math.max(inM, satEndM);
        if (outM > startM) {
          extraOTMins += (outM - startM);
        }
      }
      dayOTMins = extraOTMins;
    } else {
      // Nonâ€‘Saturday: prefer explicit OT punches when they exist
      if (otInActual && otOutActual && toMins(otInActual) > pmOutRefMins) {
        let otInM = toMins(otInActual);
        let otOutM = toMins(otOutActual);
        if (otOutM < otInM) otOutM += 1440;
        dayOTMins = Math.max(0, otOutM - otInM);
      } else {
        // Fallback: no explicit OT punches.  Check the last clockâ€‘out and
        // count any minutes worked after the scheduled end as OT.  Only
        // the final out of the day is considered to avoid counting
        // intermediate segments twice.
        let lastOutM = null;
        for (let i = 0; i < times.length; i += 2) {
          const outStr = times[i+1];
          if (!outStr) continue;
          const outM = toMins(outStr);
          if (lastOutM === null || outM > lastOutM) lastOutM = outM;
        }
        if (lastOutM != null) {
          let adjLastOut = lastOutM;
          if (adjLastOut < pmOutRefMins) adjLastOut += 1440;
          if (adjLastOut > pmOutRefMins) {
            dayOTMins = adjLastOut - pmOutRefMins;
          }
        }
      }
    }
    totalsOT[empId] += minsToDec(dayOTMins);
  }
  return { totalsReg, totalsOT };
}
const dtrStartEl = document.getElementById('filterStart');
const dtrEndEl = document.getElementById('filterEnd');

function calculatePayrollFromRecords(){
  try { if (typeof renderResults === 'function') renderResults(); } catch(e){ console.warn('renderResults failed', e); }

  /*
   * Instead of deriving regular and OT hours from the filtered results table
   * (which can change when the DTR list is filtered), compute these values
   * directly from the underlying storedRecords for the selected date range.
   * This ensures that payroll calculations remain fixed regardless of
   * any filtering performed on the DTR tab.
   */
  try {
    // Determine the date range from the payroll period inputs.  Fall back
    // to the DTR filter inputs if the payroll period inputs are absent.
    const start = (typeof weekStartEl !== 'undefined' && weekStartEl && weekStartEl.value) ? weekStartEl.value : (dtrStartEl ? dtrStartEl.value : '');
    const end   = (typeof weekEndEl   !== 'undefined' && weekEndEl   && weekEndEl.value)   ? weekEndEl.value   : (dtrEndEl   ? dtrEndEl.value   : '');
    // Use the helper to compute perâ€‘employee hours across the full dataset.
    const { totalsReg, totalsOT } = computeHoursForDateRange(start, end);
    // Initialize regHours and otHours with computed totals
    regHours = Object.assign({}, totalsReg || {});
    otHours  = Object.assign({}, totalsOT  || {});
    // Guarantee every employee has a defined entry (default 0)
    Object.keys(storedEmployees || {}).forEach(id => {
      if (!regHours.hasOwnProperty(id)) regHours[id] = 0;
      if (!otHours.hasOwnProperty(id))  otHours[id]  = 0;
    });
    // Persist hours to localStorage
    try {
      localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
      localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
    } catch (err) {
      console.warn('LS save failed', err);
    }
  } catch (err) {
    console.warn('Error computing hours from full records', err);
  }
  // Ensure hourly rates are populated for all employees
  Object.keys(storedEmployees || {}).forEach(id => {
    if (!payrollRates[id] || payrollRates[id] === 0) {
      payrollRates[id] = storedEmployees[id]?.hourlyRate || 0;
    }
  });
  // Persist rates
  try {
    localStorage.setItem(LS_RATES, JSON.stringify(payrollRates));
  } catch (err) {}
  // Rebuild the payroll table with the newly computed hours
  try {
    if (typeof renderTable === 'function') renderTable();
  } catch (err) {
    console.warn('renderTable failed', err);
  }
}

  /**
   * Compute regular and overtime hours directly from the DTR results table.
   * This implementation scans the #resultsTable built by renderResults() and
   * aggregates the regular and OT hours by employee. By relying on the
   * existing DTR computation (which correctly handles split records and
   * schedule overrides), the payroll tab stays in sync with whatever
   * appears in the DTR tab, even when rounding and OT logic differs from
   * the generic computeHoursForDateRange() helper.  The selected payroll
   * period (weekStart/weekEnd) is mirrored onto the DTR date filters
   * before computing.  Project and name filters are temporarily
   * cleared so that all employees are included, and then restored.
   */
  function calculatePayrollFromResultsTable() {
    try {
      // Save current filter/search values
      const searchInput = document.getElementById('dtrSearchName');
      const filterSelect = document.getElementById('filterProject');
      const origSearch = searchInput ? searchInput.value : '';
      const origFilter = filterSelect ? filterSelect.value : '';
      // Save current DTR date inputs (so we can restore after aggregation)
      const dtrStartElTmp = document.getElementById('filterStart') || document.getElementById('dtrDateFrom');
      const dtrEndElTmp   = document.getElementById('filterEnd')   || document.getElementById('dtrDateTo');
      const origFrom = dtrStartElTmp ? dtrStartElTmp.value : '';
      const origTo   = dtrEndElTmp   ? dtrEndElTmp.value   : '';
      // Preserve original LS project filter to fully restore later
      let __savedLSFilter = null;
      try { __savedLSFilter = localStorage.getItem(LS_FILTER_PROJECT); } catch(_) {}
      // Clear name search and select all projects
      if (searchInput) searchInput.value = '';
      if (filterSelect) {
        filterSelect.value = 'all';
        // Persist the filter state so renderResults respects it
        if (typeof currentProjectFilter !== 'undefined') currentProjectFilter = 'all';
        // Do not permanently persist this temporary change; we will restore later.
        try { localStorage.setItem(LS_FILTER_PROJECT, 'all'); } catch (e) {}
      }
      // Sync the DTR date range with the payroll period.  Update the
      // DTR filter inputs if present (filterStart/filterEnd) and let
      // renderResults() handle the new range.  Some DTR pages use
      // dtrDateFrom/dtrDateTo instead.
      try {
        const dtrStart = document.getElementById('filterStart') || document.getElementById('dtrDateFrom');
        const dtrEnd   = document.getElementById('filterEnd')   || document.getElementById('dtrDateTo');
        if (weekStartEl && dtrStart) dtrStart.value = weekStartEl.value;
        if (weekEndEl   && dtrEnd)   dtrEnd.value   = weekEndEl.value;
      } catch (err) {}
      // Re-render the DTR results table with updated filters
      if (typeof renderResults === 'function') renderResults();
      // Aggregate hours from the rendered DTR table
      const rows = document.querySelectorAll('#resultsTable tbody tr');
      const regTotals = {};
      const otTotals = {};
      rows.forEach(row => {
        const cells = row.cells;
        if (!cells || cells.length < 13) return;
        const empId = cells[0].textContent.trim();
        // Column 11: total regular hours; column 12: OT hours
        const regVal = parseFloat(cells[11].textContent) || 0;
        const otVal  = parseFloat(cells[12].textContent) || 0;
        regTotals[empId] = (regTotals[empId] || 0) + regVal;
        otTotals[empId]  = (otTotals[empId]  || 0) + otVal;
      });
      // Restore original filters and search
      if (searchInput) searchInput.value = origSearch;
      if (filterSelect) {
        filterSelect.value = origFilter;
        if (typeof currentProjectFilter !== 'undefined') currentProjectFilter = origFilter;
        // Restore original LS filter value exactly as it was
        try {
          if (__savedLSFilter !== null && __savedLSFilter !== undefined) localStorage.setItem(LS_FILTER_PROJECT, __savedLSFilter);
          else localStorage.removeItem(LS_FILTER_PROJECT);
        } catch (e) {}
      }
      // Restore DTR date range values to what the user had prior to aggregation
      try {
        if (dtrStartElTmp) dtrStartElTmp.value = origFrom;
        if (dtrEndElTmp)   dtrEndElTmp.value   = origTo;
      } catch(_) {}
      // Re-render the DTR table with the original filter/search and date range
      if (typeof renderResults === 'function') renderResults();
      // Apply aggregated hours to regHours and otHours, rounding to two decimals
      regHours = {};
      otHours = {};
      Object.keys(regTotals).forEach(id => {
        regHours[id] = +(regTotals[id]).toFixed(2);
      });
      Object.keys(otTotals).forEach(id => {
        otHours[id] = +(otTotals[id]).toFixed(2);
      });
      // Ensure every employee has entries for reg and OT hours
      Object.keys(storedEmployees || {}).forEach(id => {
        if (!regHours.hasOwnProperty(id)) regHours[id] = 0;
        if (!otHours.hasOwnProperty(id))  otHours[id]  = 0;
      });
      // Persist the hours to localStorage
      try {
        localStorage.setItem(LS_REG_HRS, JSON.stringify(regHours));
        localStorage.setItem(LS_OT_HRS, JSON.stringify(otHours));
      } catch (err) {}
      // Rebuild the payroll table using the computed hours
      if (typeof renderTable === 'function') renderTable();
    } catch (err) {
      console.warn('calculatePayrollFromResultsTable failed', err);
    }
  }

weekStartEl.addEventListener('change', () => {
  if (dtrStartEl) dtrStartEl.value = weekStartEl.value;
  syncPeriodScopedData();
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
  if (typeof renderTable === 'function') renderTable();
  if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
  calculateAll();
});
weekEndEl.addEventListener('change', () => {
  if (dtrEndEl) dtrEndEl.value = weekEndEl.value;
  syncPeriodScopedData();
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
  if (typeof renderTable === 'function') renderTable();
  if (typeof renderAdjustmentsTable === 'function') renderAdjustmentsTable();
  calculateAll();
});
if (dtrStartEl) {
  dtrStartEl.addEventListener('change', () => {
    weekStartEl.value = dtrStartEl.value;
    // When editing the DTR date range directly, recompute payroll hours from the DTR table
    syncPeriodScopedData();
    try {
      if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
      else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
    } catch (e) {}
  });
}
if (dtrEndEl) {
  dtrEndEl.addEventListener('change', () => {
    weekEndEl.value = dtrEndEl.value;
    // When editing the DTR date range directly, recompute payroll hours from the DTR table
    syncPeriodScopedData();
    try {
      if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
      else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
    } catch (e) {}
  });
}

tabs.tabPayroll.addEventListener('click', () => {
  if (dtrStartEl && !weekStartEl.value) weekStartEl.value = dtrStartEl.value;
  if (dtrEndEl && !weekEndEl.value) weekEndEl.value = dtrEndEl.value;
  // Compute hours based on the current DTR table rather than recomputing from raw records
  try {
    if (typeof calculatePayrollFromResultsTable === 'function') calculatePayrollFromResultsTable();
    else if (typeof calculatePayrollFromRecords === 'function') calculatePayrollFromRecords();
  } catch (e) {}
});
function backupData() {
  const data = {};
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    data[key] = localStorage.getItem(key);
  }
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'payroll_backup.json';
  a.click();
}

function restoreData(file) {
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const data = JSON.parse(e.target.result);
      for (const key in data) {
        localStorage.setItem(key, data[key]);
      }
      alert('Data restored! Reloading...');
      location.reload();
    } catch (err) {
      alert('Invalid backup file.');
    }
  };
  reader.readAsText(file);
}
// Legacy backup UI removed - replaced by enhanced Backup & Restore controls.
  </script>
 
<!-- Manual DTR Modal -->
<div id="manualDtrModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
  <div style="background:white; padding:20px; border-radius:8px; width:320px; max-width:95vw;">
    <h3 style="margin-top:0;">Enter Manual DTR</h3>
    <label>Employee:<br/>
      <select id="manualEmpSelect" style="width:100%;"></select>
    </label><br/><br/>
    <label>Date:<br/>
      <input type="date" id="manualDate" style="width:100%;"/>
    </label><br/><br/>
    <label>Time:<br/>
      <input type="time" id="manualTime" style="width:100%;"/>
    </label><br/><br/>
    <div style="text-align:right; display:flex; gap:8px; justify-content:flex-end;">
      <button id="cancelManualDtr">Cancel</button>
      <button id="saveManualDtr" class="primary">Save</button>
    </div>
  </div>
</div>

<script>
(function(){
  function openManualModal(){
    const modal = document.getElementById('manualDtrModal');
    const empSelect = document.getElementById('manualEmpSelect');
    const manualDate = document.getElementById('manualDate');
    const manualTime = document.getElementById('manualTime');
    if(!modal || !empSelect) return;
    empSelect.innerHTML = '';
    try {
      Object.keys(storedEmployees || {}).forEach(id => {
        const opt = document.createElement('option');
        opt.value = id;
        const nm = (storedEmployees[id] && storedEmployees[id].name) ? storedEmployees[id].name : '';
        opt.textContent = nm ? `${nm} (${id})` : id;
        empSelect.appendChild(opt);
      });
    } catch(e) {}
    manualDate.value = '';
    manualTime.value = '';
    modal.style.display = 'flex';
  }
  function closeManualModal(){
    const modal = document.getElementById('manualDtrModal');
    if(modal) modal.style.display = 'none';
  }
  function wireManualDTR(){
    const btn = document.getElementById('manualDtrBtn');
    const cancelBtn = document.getElementById('cancelManualDtr');
    const saveBtn = document.getElementById('saveManualDtr');
    if(btn) btn.addEventListener('click', openManualModal);
    if(cancelBtn) cancelBtn.addEventListener('click', closeManualModal);
    if(saveBtn) saveBtn.addEventListener('click', function(){
      const empId = (document.getElementById('manualEmpSelect')||{}).value;
      const dateVal = (document.getElementById('manualDate')||{}).value;
      const timeVal = (document.getElementById('manualTime')||{}).value;
      if(!empId || !dateVal || !timeVal){
        alert('Please fill all fields.');
        return;
      }
      try {
        storedRecords.push({ empId: String(empId), date: dateVal, time: timeVal, manual: true });
        // Persist to localStorage
        localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
        // Persist to Supabase for crossâ€‘device sync
        if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
      } catch(e) { console.error('Saving manual DTR failed', e); }
      closeManualModal();
      if(typeof renderResults === 'function') renderResults();
    });
  }
  function ensureActionsHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(theadRow && !theadRow.querySelector('.actions-header')){
      const th = document.createElement('th');
      th.textContent = 'Actions';
      th.classList.add('actions-header');
      theadRow.appendChild(th);
    }
  }
  // Robust event delegation so Delete works even if rows insert buttons directly
  function setupDtrDeleteDelegation(){
    const table = document.getElementById('resultsTable');
    if (!table || table.__dtrDelBound) return;
    table.addEventListener('click', function(ev){
      const btn = ev.target && ev.target.closest ? ev.target.closest('.dtr-del-btn') : null;
      if (!btn) return;
      const tr = btn.closest('tr');
      if (!tr) return;
      const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
      const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
      if(!empIdCell || !dateCell) return;
      const isSplitHalf = tr.dataset && tr.dataset.half;
      const confirmMsg = isSplitHalf
        ? `Delete this ${tr.dataset.half} DTR for ${empIdCell} on ${dateCell}?`
        : `Delete all DTR entries for ${empIdCell} on ${dateCell}?`;
      if(!confirm(confirmMsg)) return;
      try {
        if (isSplitHalf) {
          let timesForHalf = [];
          try { timesForHalf = JSON.parse(tr.dataset.times || '[]'); } catch(e) { timesForHalf = []; }
          timesForHalf.forEach(t => {
            for (let i = 0; i < storedRecords.length; i++) {
              const rec = storedRecords[i];
              if (String(rec.empId) === String(empIdCell) && rec.date === dateCell && rec.time === t) {
                storedRecords.splice(i, 1);
                break;
              }
            }
          });
          const splitKey = `${empIdCell}___${dateCell}`;
          if (splits && splits[splitKey]) {
            delete splits[splitKey];
            if (typeof saveSplits === 'function') saveSplits();
          }
        } else {
          for(let i = storedRecords.length - 1; i >= 0; i--){
            const rec = storedRecords[i];
            if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
              storedRecords.splice(i, 1);
            }
          }
        }
        localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
        try { if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords); } catch (e) {}
        renderResults();
      } catch(e){ console.error('DTR delete failed', e); }
    });
    table.__dtrDelBound = true;
  }
  function addDtrDeleteButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureActionsHeader();
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      if(tr.querySelector('.dtr-del-btn')) return;
      const td = document.createElement('td');
      td.className = 'actions-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Delete';
      btn.className = 'dtr-del-btn';
      btn.addEventListener('click', () => {
        // Get empId and date from row cells (empId at col 0, date at col 4)
        const empIdCell = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
        const dateCell  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
        if(!empIdCell || !dateCell) return;
        // Determine if this row is part of a split (AM/PM). If so, use the attached
        // metadata to remove only the specific half. Otherwise, remove all times.
        const isSplitHalf = tr.dataset && tr.dataset.half;
        const confirmMsg = isSplitHalf
          ? `Delete this ${tr.dataset.half} DTR for ${empIdCell} on ${dateCell}?`
          : `Delete all DTR entries for ${empIdCell} on ${dateCell}?`;
        if(!confirm(confirmMsg)) return;
        try {
          if (isSplitHalf) {
            // Parse times to remove for this half. The dataset.times stores an array
            // of the exact time strings (e.g., "08:00", "12:00") that belong to
            // this AM or PM half. Only records with matching empId, date and time
            // found in this array will be removed.
            let timesForHalf = [];
            try {
              timesForHalf = JSON.parse(tr.dataset.times || '[]');
            } catch(e) { timesForHalf = []; }
            // Remove only the specific occurrences of each time listed for this half.
            // We iterate through the array of times and, for each, remove one matching
            // record (empId/date/time). This avoids removing duplicates beyond the
            // count present in timesForHalf (e.g., AM out and OT may share the same
            // time value, so we only remove the intended PM/OT instances).
            timesForHalf.forEach(t => {
              for (let i = 0; i < storedRecords.length; i++) {
                const rec = storedRecords[i];
                if (String(rec.empId) === String(empIdCell) && rec.date === dateCell && rec.time === t) {
                  storedRecords.splice(i, 1);
                  break; // remove only one matching occurrence per time value
                }
              }
            });
            // After removing the half, unset the split flag for this emp/date so
            // the remaining records render as a single row. This mirrors the
            // behavior of the "Unsplit" button.
            const splitKey = `${empIdCell}___${dateCell}`;
            if (splits && splits[splitKey]) {
              delete splits[splitKey];
              if (typeof saveSplits === 'function') saveSplits();
            }
          } else {
            // Remove all records for this employee on this date
            for(let i = storedRecords.length - 1; i >= 0; i--){
              const rec = storedRecords[i];
              if(String(rec.empId) === String(empIdCell) && rec.date === dateCell){
                storedRecords.splice(i, 1);
              }
            }
          }
          // Persist updated records to localStorage
          localStorage.setItem(LS_RECORDS, JSON.stringify(storedRecords));
          // Also persist to Supabase so all devices reflect the deletion
          try {
            if (typeof saveDtrToCloud === 'function') saveDtrToCloud(storedRecords);
          } catch (e) {
            console.warn('Failed to sync DTR deletion to Supabase', e);
          }
          renderResults();
        } catch(e){ console.error('DTR delete failed', e); }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }
  function patchRenderResults(){
    if(typeof renderResults !== 'function') return false;
    const original = renderResults;
    window.renderResults = function(){
      const res = original.apply(this, arguments);
      try { addDtrDeleteButtons(); } catch(e){}
      try { setupDtrDeleteDelegation(); } catch(e){}
      // After rendering results, always check whether the selected payroll period is
      // locked and toggle editing accordingly. This ensures that dynamic
      // controls inserted by renderResults() respect the current lock state.
      try {
        if (typeof checkAndToggleEditState === 'function') {
          checkAndToggleEditState();
        }
      } catch(e) {}
      return res;
    };
    try { addDtrDeleteButtons(); } catch(e){}
    return true;
  }
  function init(){
    wireManualDTR();
    setupDtrDeleteDelegation();
    if(!patchRenderResults()){
      const iv = setInterval(() => {
        if(patchRenderResults()) clearInterval(iv);
      }, 200);
      setTimeout(() => clearInterval(iv), 6000);
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>


<script>
(function(){
  function q(id){ return document.getElementById(id); }
  function toMins(hm){ if(!hm) return null; var p=hm.split(':'), h=+p[0]||0, m=+p[1]||0; return h*60+m; }
  function minsToDec(mins){ return Math.round((mins/60)*100)/100; }
  function uniqSort(arr){ var seen={}, out=[]; for(var i=0;i<arr.length;i++){ var v=arr[i]; if(!seen[v]){ seen[v]=1; out.push(v);} } out.sort(); return out; }
  function max0(x){ return x>0?x:0; }

  // Extend tabs registry
  if (typeof tabs !== 'undefined' && tabs){
    tabs.tabProjectTotals   = document.getElementById('tabProjectTotals');
    tabs.panelProjectTotals = document.getElementById('panelProjectTotals');
  }

  // Wrap showTab to support projectTotals
  if (typeof showTab === 'function'){
    var _showTab = showTab;
    window.showTab = function(name){
      _showTab(name);
      if (name === 'projectTotals'){
        if (tabs.tabProjectTotals) tabs.tabProjectTotals.classList.add('active');
        if (tabs.panelProjectTotals) tabs.panelProjectTotals.classList.add('active');
        renderProjectTotals();
      }
    };
  }

  // Click to open our tab
  if (tabs && tabs.tabProjectTotals){
    tabs.tabProjectTotals.addEventListener('click', function(){
      var nameEl = document.getElementById('dtrSearchName');
      var projectEl = document.getElementById('filterProject');
      var fromEl = document.getElementById('dtrDateFrom');
      var toEl = document.getElementById('dtrDateTo');
      window.__dtrFilterBackup = {
        name: nameEl ? nameEl.value : '',
        project: projectEl ? projectEl.value : 'all',
        from: fromEl ? fromEl.value : '',
        to: toEl ? toEl.value : ''
      };
      if (nameEl) nameEl.value = '';
      if (projectEl) projectEl.value = 'all';
      currentProjectFilter = 'all';
      try { localStorage.setItem(LS_FILTER_PROJECT, currentProjectFilter); } catch(e){}
      if (fromEl) fromEl.value = '';
      if (toEl) toEl.value = '';
      try {
        localStorage.removeItem(LS_FROM);
        localStorage.removeItem(LS_TO);
      } catch (e) {}
      try { renderResults(); } catch (e) {}
      showTab('projectTotals');
    });
  }

  // Re-render when date range changes while active
  ['weekStart','weekEnd'].forEach(function(id){
    var el = q(id);
    if (el) el.addEventListener('change', function(){
      if (tabs && tabs.tabProjectTotals && tabs.tabProjectTotals.classList.contains('active')) renderProjectTotals();
    });
  });

  
  // DTR name search live filter
  if (document.getElementById('dtrSearchName')) {
    document.getElementById('dtrSearchName').addEventListener('input', ()=>{
      renderResults();
    });
  }
// CSV export
  var dl = q('downloadProjectTotalsCSV');
  if (dl) dl.addEventListener('click', exportProjectTotalsCSV);

  // Core compute: honors date range + per-day project/schedule overrides + schedule windows, grace, OT windows
  function computeProjectTotals(startDate, endDate){
    var empMap = (typeof storedEmployees!=='undefined' && storedEmployees) || {};
    var schedMap = (typeof storedSchedules!=='undefined' && storedSchedules) || {};
    var defSchedId = (typeof defaultScheduleId!=='undefined' && defaultScheduleId) || null;
    var records = (typeof storedRecords!=='undefined' && storedRecords) || [];
    var projMap = (typeof storedProjects!=='undefined' && storedProjects) || {};
    var ovSched = (typeof overridesSchedules!=='undefined' && overridesSchedules) || {};
    var ovProj  = (typeof overridesProjects!=='undefined' && overridesProjects) || {};
    var DEF     = (typeof DEFAULT_SCHEDULE!=='undefined' && DEFAULT_SCHEDULE) || {};

    var dayGroups = {};
    for (var i=0;i<records.length;i++){
      var r = records[i];
      if (startDate && r.date < startDate) continue;
      if (endDate && r.date > endDate) continue;
      if (!empMap[r.empId]) continue;
      var key = r.date + '___' + r.empId;
      if (!dayGroups[key]) dayGroups[key] = [];
      dayGroups[key].push(r.time);
    }

    var totals = {}; // projectId => { name, reg, ot, total, employees:{} }
    var keys = Object.keys(dayGroups);
    for (var k=0;k<keys.length;k++){
      var key = keys[k];
      var parts = key.split('___');
      var date = parts[0], empId = parts[1];
      var emp = empMap[empId]; if (!emp) continue;

      var ovKey = empId + '___' + date;
      var projId = (ovProj.hasOwnProperty(ovKey) ? ovProj[ovKey] : (emp.projectId || '')) || '';
      var projName = (projId && projMap[projId]) ? (projMap[projId].name || projId) : '(No project)';

      var schedId = emp.scheduleId || defSchedId;
      if (ovSched[ovKey]) schedId = ovSched[ovKey];
      var S = (schedId && schedMap[schedId]) ? schedMap[schedId] : DEF;

      var times = uniqSort(dayGroups[key]);

      var win = {
        amIn:  {start:S.rng_am_in_start||'05:00', end:S.rng_am_in_end||'09:00'},
        amOut: {start:S.rng_am_out_start||'11:30', end:S.rng_am_out_end||'12:30'},
        pmIn:  {start:S.rng_pm_in_start||'12:30', end:S.rng_pm_in_end||'14:30'},
        pmOut: {start:S.rng_pm_out_start||'15:00', end:S.rng_pm_out_end||'20:00'},
        otIn:  {start:S.rng_ot_in_start||'19:00', end:S.rng_ot_in_end||'22:00'},
        otOut: {start:S.rng_ot_out_start||'19:00', end:S.rng_ot_out_end||'23:59'}
      };
      function pickEarliest(w){ for(var i2=0;i2<times.length;i2++){ var t=times[i2]; if(t>=w.start && t<=w.end) return t; } return null; }
      function pickLatest(w){ var last=null; for(var j2=0;j2<times.length;j2++){ var t2=times[j2]; if(t2>=w.start && t2<=w.end) last=t2; } return last; }

      var amIn  = pickEarliest(win.amIn);
      var amOut = pickLatest(win.amOut);
      var pmIn  = pickEarliest(win.pmIn);
      var pmOut = pickLatest(win.pmOut);

      var pmOutRefMins = pmOut ? toMins(pmOut) : toMins(S.sch_pm_end || '17:00');

      var otIn = null, otOut = null;
      for (var x=0;x<times.length;x++){
        var tt = times[x]; var m = toMins(tt);
        if (m>pmOutRefMins && m>=toMins(win.otIn.start) && m<=toMins(win.otIn.end)){ otIn = tt; break; }
      }
      for (var y=times.length-1;y>=0;y--){
        var tt2 = times[y]; var m2 = toMins(tt2);
        if (m2>pmOutRefMins && m2>=toMins(win.otOut.start) && m2<=toMins(win.otOut.end)){ otOut = tt2; if(!otIn || toMins(otOut)>=toMins(otIn)) break; }
      }

      var grace = Number(S.sch_grace)||0;
      var regMins = 0;

      if (amIn && pmOut && !amOut && !pmIn){
        var saS = toMins(S.sch_am_start||'08:00'), saE = toMins(S.sch_am_end||'12:00');
        var spS = toMins(S.sch_pm_start||'13:00'), spE = toMins(S.sch_pm_end||'17:00');
        var amInM = toMins(amIn), pmOutM = toMins(pmOut);
        var late = Math.max(0, amInM - saS);
        var under = Math.max(0, spE - pmOutM);
        var full = max0(saE-saS) + max0(spE-spS);
        regMins = (late <= grace) ? max0(full - under) : max0(full - late - under);
      } else {
        if (amIn && amOut){
          var inM = toMins(amIn), sS = toMins(S.sch_am_start||'08:00'), sE = toMins(S.sch_am_end||'12:00');
          if (inM <= sS + grace) inM = sS;
          var endM = Math.min(toMins(amOut), sE);
          if (endM > inM) regMins += (endM - inM);
        }
        if (pmIn && pmOut){
          var inM2 = toMins(pmIn), sS2 = toMins(S.sch_pm_start||'13:00'), sE2 = toMins(S.sch_pm_end||'17:00');
          if (inM2 <= sS2 + grace) inM2 = sS2;
          var endM2 = Math.min(toMins(pmOut), sE2);
          if (endM2 > inM2) regMins += (endM2 - inM2);
        }
      }

      var otMins = 0;
      if (otIn && otOut){
        var startClamp = Math.max(toMins(otIn), toMins(win.otIn.start));
        var endClamp   = Math.min(toMins(otOut), toMins(win.otOut.end));
        if (endClamp > startClamp) otMins = endClamp - startClamp;
      }

      var regDec = minsToDec(regMins);
      var otDec  = minsToDec(otMins);

      if (!totals[projId]) totals[projId] = { name: projName, reg: 0, ot: 0, total: 0, gross: 0, employees: {} };
      totals[projId].reg   = Math.round((totals[projId].reg + regDec)*100)/100;
      totals[projId].ot    = Math.round((totals[projId].ot  + otDec )*100)/100;
      totals[projId].total = Math.round((totals[projId].total + regDec + otDec)*100)/100;
      var rate = (emp && typeof emp.hourlyRate==='number') ? emp.hourlyRate : (+emp.hourlyRate||0);
      var otp = (document.getElementById('otMultiplier')&&parseFloat(document.getElementById('otMultiplier').value)) || 1.5;
      var grossInc = (regDec*rate) + (otDec*rate*otp);
      totals[projId].gross = Math.round((totals[projId].gross + grossInc)*100)/100;
      if (!totals[projId].employees[empId]) totals[projId].employees[empId] = { id: empId, name: (emp && emp.name) || '', reg: 0, ot: 0, total: 0, gross: 0, perDay: {} };
totals[projId].employees[empId].reg = Math.round((totals[projId].employees[empId].reg + regDec)*100)/100;
totals[projId].employees[empId].ot  = Math.round((totals[projId].employees[empId].ot  + otDec )*100)/100;
totals[projId].employees[empId].total = Math.round((totals[projId].employees[empId].total + regDec + otDec)*100)/100;
totals[projId].employees[empId].gross = Math.round((totals[projId].employees[empId].gross + grossInc)*100)/100;
// NEW: record per-day total hours (reg + OT) for this date
var _dTot = Math.round(((regDec + otDec))*100)/100;
if (!totals[projId].employees[empId].perDay) totals[projId].employees[empId].perDay = {};
totals[projId].employees[empId].perDay[date] = Math.round(((totals[projId].employees[empId].perDay[date]||0) + _dTot)*100)/100;
    }

    var rows = [];
    var pids = Object.keys(totals).sort(function(a,b){ var A=totals[a].name||''; var B=totals[b].name||''; return A.localeCompare(B); });
    for (var z=0; z<pids.length; z++){
      var pid = pids[z];
      var _emps = Object.values(totals[pid].employees || {}).sort(function(a,b){return (a.name||'').localeCompare(b.name||'') || String(a.id).localeCompare(String(b.id));});
rows.push({ projectId: pid, project: totals[pid].name, reg: totals[pid].reg, ot: totals[pid].ot, total: totals[pid].total, gross: totals[pid].gross, employees: Object.keys(totals[pid].employees).length , breakdown: _emps });
    }
    if (rows.length){
      var g = {reg:0, ot:0, total:0, gross:0, employees:0};
      for (var r=0;r<rows.length;r++){ g.reg+=rows[r].reg; g.ot+=rows[r].ot; g.total+=rows[r].total; g.gross+=rows[r].gross; g.employees+=rows[r].employees; }
      rows.push({ projectId: '__grand__', project: 'Grand Total', reg: Math.round(g.reg*100)/100, ot: Math.round(g.ot*100)/100, total: Math.round(g.total*100)/100, gross: Math.round(g.gross*100)/100, employees: g.employees });
    }
    return rows;
  }

  function renderProjectTotals(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var tbody = document.querySelector('#projectTotalsTable tbody'); if (!tbody) return;
    var data = computeProjectTotals(ws, we);
    tbody.innerHTML = '';
    if (!data.length){
      var tr = document.createElement('tr'); tr.innerHTML = '<td colspan="5" class="muted">No data for the selected date range.</td>'; tbody.appendChild(tr); return;
    }
    for (var i=0;i<data.length;i++){
      var row = data[i]; var tr = document.createElement('tr');
      tr.className = 'proj-row';
      if (row.projectId==='__grand__') tr.style.fontWeight = '700';
      tr.innerHTML = '<td>'+row.project+'</td>'
                   + '<td style="text-align:right">'+row.reg.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.ot.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+row.total.toFixed(2)+'</td>'
                   + '<td style="text-align:right">'+(row.gross!=null?row.gross.toFixed(2):'0.00')+'</td>'
                   + '<td style="text-align:right">'+row.employees+'</td>';
      tbody.appendChild(tr);
      if (row.projectId !== '__grand__' && Array.isArray(row.breakdown) && row.breakdown.length){
        tr.classList.add('has-breakdown');
        var dtr = document.createElement('tr');
        dtr.className = 'proj-emp-breakdown';
        var inner = '<td colspan="6" style="background:#f9fafb">'
  + '<div style="padding:8px 6px">'
  + '<strong>Employees (per-day hours):</strong>';

function dateRangeList(s, e){
  var out = []; if(!s || !e) return out;
  var d = new Date(s); var end = new Date(e);
  while (d <= end){ out.push(new Date(d)); d.setDate(d.getDate()+1); }
  return out;
}
var days = dateRangeList(ws, we);

inner += '<table style="width:100%;margin-top:6px;border-collapse:collapse">'
      + '<thead><tr>'
      + '<th style="text-align:left">ID</th>'
      + '<th style="text-align:left">Name</th>';
for (var di=0; di<days.length; di++){
  var dt = days[di];
  var label = (dt.getMonth()+1)+'/'+dt.getDate();
  inner += '<th style="text-align:right">'+label+'</th>';
}
inner += '<th style="text-align:right">Total Hrs</th>';
inner += '<th style="text-align:right">Total Amount</th>';
inner += '</tr></thead><tbody>';

for (var k=0;k<row.breakdown.length;k++){
  var e = row.breakdown[k];
  var totalRow = Number(e.total||0);
  var grossRow = Number(e.gross||0);
  inner += '<tr>'
        + '<td>'+(e.id ?? '')+'</td>'
        + '<td>'+(e.name ?? '')+'</td>';
  var perDay = (e.perDay||{});
  for (var di=0; di<days.length; di++){
    var dkey = days[di].toISOString().slice(0,10);
    var val = Number(perDay[dkey]||0).toFixed(2);
    inner += '<td style="text-align:right">'+val+'</td>';
  }
  inner += '<td style="text-align:right">'+ totalRow.toFixed(2) +'</td>';
  inner += '<td style="text-align:right">'+ grossRow.toFixed(2) +'</td>';
  inner += '</tr>';
}
inner += '</tbody></table></div></td>';
        dtr.innerHTML = inner;
        dtr.style.display = 'none';
        tbody.appendChild(dtr);
        // toggle and show detailed modal when a project row is clicked. The modal
        // provides a comprehensive breakdown and grand totals for the selected project.
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (function(detailRow, rowObj){
          return function(){
            // Show modal with project breakdown if available
            if (typeof showProjectReport === 'function') showProjectReport(rowObj);
            // Toggle the inline breakdown row visibility for quick reference
            if (detailRow) {
              detailRow.style.display = (detailRow.style.display === 'none' ? 'table-row' : 'none');
            }
          };
        })(dtr, row));
      }

    }
  }

  function exportProjectTotalsCSV(){
    var ws = (q('weekStart') && q('weekStart').value) || '';
    var we = (q('weekEnd') && q('weekEnd').value) || '';
    var data = computeProjectTotals(ws, we);
    var rows = [['Week Start','Week End','Project','Regular Hours','OT Hours','Total Hours','Gross Amount','Employees']];
    for (var i=0;i<data.length;i++){ var r = data[i]; rows.push([ws,we,r.project,r.reg.toFixed(2),r.ot.toFixed(2),r.total.toFixed(2),(r.gross!=null?r.gross.toFixed(2):'0.00'),r.employees]); }
var csv = rows.map(function(r){
      return r.map(function(s){
        s = String(s==null?'':s);
        var needs = (s.indexOf('"')>=0) || (s.indexOf(',')>=0) || (s.indexOf('\n')>=0);
        if (needs) s = '"' + s.split('"').join('""') + '"';
        return s;
      }).join(',');
    }).join('\n');
    var blob = new Blob([csv], {type:'text/csv'}); var url = URL.createObjectURL(blob);
    var a = document.createElement('a'); a.href=url; a.download='project_totals.csv'; document.body.appendChild(a); a.click(); a.remove();
  }
})();
</script>


<script>
// --- Employees: small UX helpers ---
document.addEventListener('DOMContentLoaded', () => {
  const panel = document.querySelector('#panelEmployees');
  if (!panel) return;
  const form = panel.querySelector('form');
  if (!form) return;

  // Wrap form in a card if not already
  if (!form.closest('.form-card')) {
    const card = document.createElement('div');
    card.className = 'form-card';
    form.parentNode.insertBefore(card, form);
    card.appendChild(form);
  }

  // Enter-to-submit (except textarea)
  form.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
      e.preventDefault();
      const submit = form.querySelector('button[type="submit"], input[type="submit"]');
      if (submit) submit.click();
    }
  });

  // Auto-mark dangerous buttons
  form.querySelectorAll('button, input[type="button"]').forEach(el => {
    const text = (el.textContent || el.value || '').toLowerCase();
    if (/(clear|reset|delete|remove)/.test(text)) el.classList.add('btn-danger');
    if (/(save|add|submit|create)/.test(text)) el.classList.add('btn-primary');
  });

  // Group actions into a row if not already
  const actions = Array.from(form.querySelectorAll('button, input[type="submit"], input[type="button"]'));
  if (actions.length) {
    let bar = form.querySelector('.form-actions');
    if (!bar) {
      bar = document.createElement('div');
      bar.className = 'form-actions';
      // move trailing buttons into actions
      actions.forEach(btn => {
        if (!btn.closest('.form-actions')) bar.appendChild(btn);
      });
      form.appendChild(bar);
    }
  }
});
</script>

<script>
// Clean print for per-project sheet (modal) with strong grid lines
function printProjectReportClean(){
  try{
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var css = '<style>'+
      'html,body{margin:0;padding:10px;font-family:Arial,Helvetica,sans-serif}'+
      '*{-webkit-print-color-adjust:exact;print-color-adjust:exact}'+
      'h3{margin:0 0 8px 0}'+
      'table{width:100%;border-collapse:collapse;font-size:12px}'+
      'table,th,td{border:0.6pt solid #000 !important}'+
      'th,td{padding:4px 6px;vertical-align:middle}'+
      'th{background:#f1f5f9;text-align:left}'+
      '@media print{@page{margin:10mm}}'+
      '</style>';
    var html = '<!doctype html><html><head><meta charset="utf-8">'+css+'</head><body>'+ box.innerHTML + '</body></html>';
    var w = window.open('', '', 'width=1024,height=768');
    if (!w) return;
    w.document.open(); w.document.write(html); try{ w.document.title=' '; }catch(e){}; w.document.close();
    w.focus(); setTimeout(function(){ try{ safePrint(w); }catch(e){} }, 0);
  }catch(e){ console.warn('Project report clean print failed', e); }
}
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('printProjectTotalsBtn');
  if (btn) btn.addEventListener('click', function(e){ e.preventDefault(); printProjectReportClean(); });
});
</script>

<!-- Enhanced DTR Print -->
<script>
// Enhanced DTR print: clones the results table, removes 'Split' or 'Actions' columns,
// replaces dropdowns with selected text, and shows date range/project filter.
(function(){
  function printDTR(){
    try{
      var table = document.getElementById('resultsTable');
      if(!table){ alert('No DTR records to print.'); return; }
      // Capture selected texts from original selects
      var selectedTexts = [];
      var origSelects = table.querySelectorAll('select');
      origSelects.forEach(function(osel){
        var txt = '';
        try{
          var idx = osel.selectedIndex;
          if(idx >= 0 && osel.options[idx]){
            var opt = osel.options[idx];
            txt = (opt.textContent || opt.innerText || opt.value || '');
          }
        }catch(e){}
        selectedTexts.push(txt);
      });
      // Clone table
      var clone = table.cloneNode(true);
      // Remove columns labelled 'Split', 'Actions', or 'Editor'
      var dropIdx = [];
      clone.querySelectorAll('thead th').forEach(function(th, idx){
        var t = (th.textContent || '').trim().toLowerCase();
        if(t === 'split' || t === 'actions' || t === 'editor') dropIdx.push(idx);
      });
      if(dropIdx.length){
        // Remove header cells
        var headers = clone.querySelectorAll('thead th');
        headers.forEach(function(th, idx){
          if(dropIdx.indexOf(idx) !== -1){ th.remove(); }
        });
        // Remove columns from each row (in reverse order)
        clone.querySelectorAll('tbody tr').forEach(function(tr){
          var cells = tr.children;
          var sorted = dropIdx.slice().sort(function(a,b){ return b - a; });
          sorted.forEach(function(i){
            if(cells[i]) cells[i].remove();
          });
        });

        // Remove columns from any footer rows as well
        var footRows = clone.querySelectorAll('tfoot tr');
        footRows.forEach(function(fr){
          var fc = fr.children;
          var sortedF = dropIdx.slice().sort(function(a,b){ return b - a; });
          sortedF.forEach(function(i){
            if(fc[i]) fc[i].remove();
          });
        });
      }
      // Replace select dropdowns in the clone with the captured text values
      var cloneSelects = clone.querySelectorAll('select');
      cloneSelects.forEach(function(csel, i){
        var td = csel.closest('td');
        if(td){ td.textContent = selectedTexts[i] || ''; }
      });
      // Remove any buttons inside the cloned table (e.g., split buttons)
      clone.querySelectorAll('button').forEach(function(btn){ btn.remove(); });
      
      function fmtLong(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          return dt.toLocaleDateString(undefined,{ year:'numeric', month:'long', day:'numeric' });
        }catch(e){ return d; }
      }
      function fmtLongWithDay(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          var dateStr = dt.toLocaleDateString(undefined,{ year:'numeric', month:'long', day:'numeric' });
          var dayStr  = dt.toLocaleDateString(undefined,{ weekday:'long' });
          return dateStr + ' (' + String(dayStr||'').toUpperCase() + ')';
        }catch(e){ return d; }
      }
// Build header for print

      function fmtLong(d){
        if(!d) return '';
        try{
          var dt = new Date(d);
          if (isNaN(dt)) return d;
          var opts = { year: 'numeric', month: 'long', day: 'numeric' };
          return dt.toLocaleDateString(undefined, opts);
        }catch(e){ return d; }
      }

      var start = (document.getElementById('weekStart') || {}).value || '';
      var end = (document.getElementById('weekEnd') || {}).value || '';
      // Prefer the small Date range filter in the DTR tab
      var smallFrom = (document.getElementById('dtrDateRangeFrom')||{}).value || (document.getElementById('dtrDateFrom')||{}).value || '';
      var smallTo   = (document.getElementById('dtrDateRangeTo')||{}).value   || (document.getElementById('dtrDateTo')||{}).value   || '';
      var s = smallFrom || start;
      var e = smallTo   || end;
      var hdr = 'Daily Time Records';
      if(start || end){
        var sL = fmtLong(start), eL = fmtLong(end);
        hdr += ' - ' + (sL || '') + (eL ? (' - ' + eL) : '');
      }
      // Determine project filter text
      var filterSel = document.getElementById('filterProject');
      var filterTxt = '';
      if(filterSel){
        try{
          if(!filterSel.value || filterSel.value === 'all'){
            filterTxt = 'All Projects';
          } else {
            var o = filterSel.options[filterSel.selectedIndex];
            filterTxt = (o && (o.textContent || o.innerText || '')) || '';
          }
        }catch(e){}
      }
      var w = window.open('', '_blank', 'width=900,height=700');
      w.document.write('<!DOCTYPE html><html><head><meta charset="utf-8"><title>DTR Records</title>');
      w.document.write('<style>body{font-family:Arial,Helvetica,sans-serif;margin:16px} h2{margin:0 0 6px} .muted{color:#555;margin:0 0 12px;font-size:12px} table{width:100%;border-collapse:collapse} th,td{border:1px solid #000;padding:6px;text-align:center;font-size:12px} th{background:#eee}#payrollTable th, #payrollTable td { white-space: nowrap; }#payrollTable th:nth-child(3), #payrollTable td:nth-child(3) { width:110px; min-width:110px; }#payrollTable th:nth-child(4), #payrollTable td:nth-child(4) { width:120px; min-width:120px; }#payrollTable th:nth-child(5), #payrollTable td:nth-child(5) { width:120px; min-width:120px; }</style>');
      w.document.write('</head><body>');
      w.document.write('<h2>' + hdr.replace(/</g, '&lt;') + '</h2>');
      if(filterTxt){
        var __pf = (filterTxt||'').replace(/</g,'&lt;');
      w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Project filter: ' + __pf + '</div>');
      // Date Filter line (shows weekday)
      (function(){
        var df = (document.getElementById('dtrDateRangeFrom')||{}).value || (document.getElementById('dtrDateFrom')||{}).value || '';
        var dt = (document.getElementById('dtrDateRangeTo')||{}).value   || (document.getElementById('dtrDateTo')||{}).value   || '';
        var s = df || start, e = dt || end;
        if (s && e && s !== e){
          w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Date filter: ' + fmtLongWithDay(s) + ' - ' + fmtLongWithDay(e) + '</div>');
        } else if (s){
          w.document.write('<div style="margin:2px 0;font-weight:700;font-size:14px;">Date filter: ' + fmtLongWithDay(s) + '</div>');
        }
      })();
      }
      // Include summary of totals (Grand Total Hours, Regular, OT, Employees) if available
      try {
        var summaryEl = document.getElementById('dtrSummary');
        if(summaryEl){
          var summaryText = (summaryEl.textContent || '').trim();
          if(summaryText){
            // Escape angle brackets
            var safeSummary = summaryText.replace(/</g,'&lt;');
            w.document.write('<div style="margin:8px 0;font-weight:bold;font-size:12px;">'+ safeSummary +'</div>');
          }
        }
      } catch(e) {}
      w.document.write(clone.outerHTML);
      w.document.write('</body></html>');
      w.document.close();
      w.focus();
      safePrint(w);
    }catch(err){
      alert('Unable to print DTR: ' + err);
    }
  }
  window.printDTR = printDTR;
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.id === 'printDtrBtn'){
      printDTR();
    }
  });
})();
</script>



<script>
(function(){
  function _parse(n){ var x=parseFloat(String(n||'').replace(/[^0-9.\-]/g,'')); return isNaN(x)?0:x; }
  function _val(el){
    try {
      if (!el) return '';
      if (typeof el.value !== 'undefined') return el.value;
      return el.textContent || '';
    } catch(e){ return ''; }
  }
  function _fmt(n){
    var v = Math.round((n||0)*100)/100;
    try { return v.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2}); }
    catch(e){ return v.toFixed(2); }
  }

  // === Payroll ===
  function updatePayrollGrandTotals(){
    var tb = document.querySelector('#payrollTable tbody');
    var foot = document.querySelector('#payrollTotalsFoot');
    if (!tb || !foot) return;
      var t = {regHrs:0, otHrs:0, adjHrs:0, totalHrs:0, rate:0, regPay:0, otPay:0, adjAmt:0, bantay:0, grossPay:0, pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, totalDed:0, netPay:0};
    var div = Number(divisor) || 1;
    tb.querySelectorAll('tr').forEach(function(tr){
      t.regHrs   += _parse(_val(tr.querySelector('.regHrs')));
      t.otHrs    += _parse(_val(tr.querySelector('.otHrs')));
      // Sum adjustment hours from the adjHrs cell (displayed as text)
      t.adjHrs   += _parse(tr.querySelector('.adjHrs')?.textContent);
      // Sum total hours from the computed totalHrs cell
      t.totalHrs += _parse(tr.querySelector('.totalHrs')?.textContent);
      t.rate     += _parse(_val(tr.querySelector('.rate')));
        t.regPay   += _parse(tr.querySelector('.regPay')?.textContent);
        t.otPay    += _parse(tr.querySelector('.otPay')?.textContent);
        t.adjAmt   += _parse(tr.querySelector('.adjAmt')?.textContent);
        // Sum Bantay allowance from the bantay input
        t.bantay  += _parse(_val(tr.querySelector('.bantay')));
        t.grossPay += _parse(tr.querySelector('.grossPay')?.textContent);
        t.pagibig  += _parse(tr.querySelector('.pagibig')?.textContent);
        t.philhealth += _parse(tr.querySelector('.philhealth')?.textContent);
        t.sss      += _parse(tr.querySelector('.sss')?.textContent);
        t.loanSSS  += _parse(_val(tr.querySelector('.loanSSS'))) / div;
        t.loanPI   += _parse(_val(tr.querySelector('.loanPI'))) / div;
        t.vale     += _parse(_val(tr.querySelector('.vale')));
        t.valeWed  += _parse(_val(tr.querySelector('.valeWed')));
        t.totalDed += _parse(tr.querySelector('.totalDed')?.textContent);
        t.netPay   += _parse(tr.querySelector('.netPay')?.textContent);
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updatePayrollGrandTotals = updatePayrollGrandTotals;

  // === Deductions ===
  function _dedHeadMap(){
    var ths = Array.from(document.querySelectorAll('#deductionsTable thead th')).map(function(th){return (th.textContent||'').trim().toLowerCase();});
    function findIdx(keys){
      for (var i=0;i<ths.length;i++){
        for (var j=0;j<keys.length;j++){
          if (ths[i] === keys[j]) return i;
        }
        // loose contains for variants like "vale wed" vs "wed vale"
        for (var j=0;j<keys.length;j++){
          if (ths[i].indexOf(keys[j]) !== -1) return i;
        }
      }
      return -1;
    }
    return {
      id: findIdx(['id','emp id','employee id']),
      name: findIdx(['name','employee name']),
      pagibig: findIdx(['pag-ibig','pag ibig','pagibig']),
      philhealth: findIdx(['philhealth','phil health']),
      sss: findIdx(['sss']),
      loanSSS: findIdx(['sss loan','loan sss']),
      loanPI: findIdx(['pag-ibig loan','pag ibig loan','loan pi','pi loan']),
      vale: findIdx(['vale','account','acct']),
      valeWed: findIdx(['vale wed','wed vale']),
      total: findIdx(['total','total deductions','total ded'])
    };
  }

  function updateDeductionsGrandTotals(){
    var tb = document.querySelector('#deductionsTable tbody');
    var foot = document.querySelector('#deductionsTable_foot');
    if (!tb || !foot) return;
    var map = _dedHeadMap();
    var t = {pagibig:0, philhealth:0, sss:0, loanSSS:0, loanPI:0, vale:0, valeWed:0, total:0};
    tb.querySelectorAll('tr').forEach(function(tr){
      var c = tr.cells||[];
      function cell(idx){ return (idx>=0 && idx<c.length) ? c[idx].textContent : ''; }
      t.pagibig   += _parse(cell(map.pagibig));
      t.philhealth+= _parse(cell(map.philhealth));
      t.sss       += _parse(cell(map.sss));
      t.loanSSS   += _parse(cell(map.loanSSS));
      t.loanPI    += _parse(cell(map.loanPI));
      t.vale      += _parse(cell(map.vale));
      t.valeWed   += _parse(cell(map.valeWed));
      t.total     += _parse(cell(map.total));
    });
    Object.keys(t).forEach(function(k){
      var cell = foot.querySelector('[data-col="'+k+'"]');
      if (cell) cell.textContent = _fmt(t[k]);
    });
  }
  window.updateDeductionsGrandTotals = updateDeductionsGrandTotals;

  // Debounced scheduling for totals to avoid thrash during bulk updates
  window.__suspendTotals = window.__suspendTotals || false;
  window.__needsTotalsUpdate = window.__needsTotalsUpdate || false;
  (function(){
    var rafId = null;
    function flush(){
      rafId = null;
      if (window.__suspendTotals) { window.__needsTotalsUpdate = true; return; }
      try { updatePayrollGrandTotals(); } catch(e){}
      try { updateDeductionsGrandTotals(); } catch(e){}
    }
    window.scheduleTotals = function(){
      if (window.__suspendTotals) { window.__needsTotalsUpdate = true; return; }
      if (rafId) return;
      var raf = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };
      rafId = raf(flush);
    };
  })();

  // Run on load
  function _initTotals(){
    try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', _initTotals);
  } else { _initTotals(); }

  // Observe table changes to keep totals fresh (debounced)
  try {
    var mo = new MutationObserver(function(){ try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){} });
    var ptb = document.querySelector('#payrollTable tbody');
    var dtb = document.querySelector('#deductionsTable tbody');
    if (ptb) mo.observe(ptb, {childList:true, subtree:true, characterData:true});
    if (dtb) mo.observe(dtb, {childList:true, subtree:true, characterData:true});
  } catch(e){}

  // Also recalc on payroll inputs (debounced)
  document.addEventListener('input', function(ev){
    if ((ev.target && ev.target.closest('#payrollTable'))) {
      try{ (window.scheduleTotals||updatePayrollGrandTotals)(); }catch(e){}
    }
  });

  // Patch into existing functions if present
  try {
    var _calcAll = window.calculateAll;
    if (typeof _calcAll === 'function'){
      window.calculateAll = function(){
        var prev = window.__suspendTotals;
        window.__suspendTotals = true;
        try { var r = _calcAll.apply(this, arguments); return r; }
        finally {
          window.__suspendTotals = prev;
          var need = window.__needsTotalsUpdate; window.__needsTotalsUpdate = false;
          try { (window.scheduleTotals||updatePayrollGrandTotals)(); if (need) (window.scheduleTotals||updateDeductionsGrandTotals)(); } catch(e){}
        }
      };
    }
  } catch(e){}
  try {
    var _renderDed = window.renderDeductionsTable;
    if (typeof _renderDed === 'function'){
      window.renderDeductionsTable = function(){ var r = _renderDed.apply(this, arguments); try{ (window.scheduleTotals||updateDeductionsGrandTotals)(); }catch(e){}; return r; };
    }
  } catch(e){}

})();</script>

<script>
// Custom Payroll CSV export: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay)
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // If "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = parts[0].trim();
      var rhs = (parts.slice(1).join(',')).trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Else assume "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){
    var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function csvEscape(val){
    var s = String(val==null?'':val);
    var needs = /[",\n]/.test(s);
    if (needs) s = '"' + s.replace(/"/g,'""') + '"';
    return s;
  }
  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};
    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || '';
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });
    // Serialize
    return rows.map(function(r){ return r.map(csvEscape).join(','); }).join('\n');
  }
  function attachPayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    btn.addEventListener('click', function(){
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(e){
        console.error('Payroll CSV export failed', e);
        alert('Failed to build Payroll CSV.');
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachPayrollCsv);
  } else {
    attachPayrollCsv();
  }
})();
</script>

<script>
// === Override Payroll CSV to: Last name, First Name, Middle Name, Employee Account Number, Amount (Net Pay) ===
(function(){
  function splitName(full){
    full = String(full||'').trim();
    if (!full) return {last:'', first:'', middle:''};
    // Handle "Last, First Middle"
    if (full.indexOf(',') >= 0){
      var parts = full.split(',');
      var last = (parts.shift()||'').trim();
      var rhs = (parts.join(',')||'').trim();
      var toks = rhs.split(/\s+/).filter(Boolean);
      var first = toks.shift() || '';
      var middle = toks.join(' ') || '';
      return {last, first, middle};
    }
    // Default "First Middle Last"
    var toks = full.split(/\s+/).filter(Boolean);
    if (toks.length === 1) return {last: toks[0], first:'', middle:''};
    if (toks.length === 2) return {first: toks[0], last: toks[1], middle:''};
    var first = toks[0];
    var last = toks[toks.length-1];
    var middle = toks.slice(1, -1).join(' ');
    return {last, first, middle};
  }
  function parseNum(s){ var n = parseFloat(String(s||'').replace(/[^0-9.\-]/g,'')); return isNaN(n)?0:n; }
  function csvEscape(val){ var s=String(val==null?'':val); return /[",\n]/.test(s) ? ('"'+s.replace(/"/g,'""')+'"') : s; }

  function buildPayrollCSV(){
    var rows = [['Last name','First Name','Middle Name','Employee Account Number','Amount']];
    var tb = document.querySelector('#payrollTable tbody');
    if (!tb) return rows.map(r=>r.join(',')).join('\n');
    var empMap = (typeof storedEmployees !== 'undefined' && storedEmployees) ? storedEmployees : {};

    tb.querySelectorAll('tr').forEach(function(tr){
      var id = (tr.cells[0] && tr.cells[0].textContent.trim()) || '';
      var name = (tr.cells[1] && tr.cells[1].textContent.trim()) || (empMap[id]?.name || '');
      var bank = (empMap[id]?.bankAccount) || ''; // Employee Account Number
      var netTxt = (tr.querySelector('.netPay') || {}).textContent;
      var amount = (Math.round(parseNum(netTxt)*100)/100).toFixed(2);
      var nm = splitName(name);
      rows.push([nm.last, nm.first, nm.middle, bank, amount]);
    });

    return rows.map(r => r.map(csvEscape).join(',')).join('\n');
  }

  function overridePayrollCsv(){
    var btn = document.getElementById('downloadPayrollCSV');
    if (!btn) return;
    // Remove all existing listeners by cloning
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      try{
        var csv = buildPayrollCSV();
        var blob = new Blob([csv], {type:'text/csv'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'Payroll_NetPay.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }catch(err){
        console.error('Payroll CSV export failed', err);
        alert('Failed to build Payroll CSV.');
      }
    });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', overridePayrollCsv);
  } else {
    overridePayrollCsv();
  }
})();
</script>


</div>






<link rel="preconnect" href="https://cdn.jsdelivr.net"/>


</div>




<script>
document.addEventListener('DOMContentLoaded', function(){
  var nodes = document.querySelectorAll('#cloudSyncCard');
  for (var i=1;i<nodes.length;i++){ nodes[i].remove(); }
});
</script>

<!-- Payslip Button functionality -->
<script>
// Add click listener for payslip buttons on payroll table
document.addEventListener('click', function(e) {
  var target = e.target;
  if (!target || !target.classList || !target.classList.contains('payslipBtn')) return;

  var row = target.closest('tr');
  if (!row) return;

  function cellText(sel){
    var el = row.querySelector(sel);
    return (el ? (el.textContent || el.value || '') : '').toString().trim();
  }
  function inputVal(sel){
    var el = row.querySelector(sel);
    var v = el ? (el.value || el.textContent || '') : '';
    return v.toString().trim();
  }

  var id = (row.cells[0] && row.cells[0].textContent || '').trim();
  var name = (row.cells[1] && row.cells[1].textContent || '').trim();

  var rate      = inputVal('.rate');
  var regHrs    = inputVal('.regHrs');
  var otHrs     = inputVal('.otHrs');
  var regPay    = cellText('.regPay');
  var otPay     = cellText('.otPay');
  var gross     = cellText('.grossPay');
  var pagibig   = cellText('.pagibig');
  var philhealth= cellText('.philhealth');
  var sss       = cellText('.sss');
  var sssLoan   = inputVal('.loanSSS');
  var piLoan    = inputVal('.loanPI');
  var valeAmt   = inputVal('.vale');
  var wedValeAmt= inputVal('.valeWed');
  var adjAmt    = cellText('.adjAmt');
  var totalDed  = cellText('.totalDed');
  var net       = cellText('.netPay');

  var ws = (document.getElementById('weekStart') || {}).value || '';
  var we = (document.getElementById('weekEnd')   || {}).value || '';

  var html = `<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Payslip - ${name}</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;padding:20px;line-height:1.4;}
  h2{margin:0 0 12px 0;text-align:center;}
  .meta{margin:0 0 16px 0;text-align:center;color:#475569;}
  table{border-collapse:collapse;width:100%;font-size:14px;}
  th,td{border:1px solid #e2e8f0;padding:8px;text-align:left;}
  th{background:#f1f5f9;}
  .right{text-align:right;}
  .section{margin-top:16px;}
</style>
</head><body>
  <h2>Payslip</h2>
  <div class="meta">${ws && we ? `Period: ${ws} - ${we}` : ''}</div>

  <table>
    <tr><th>Employee ID</th><td>${id}</td><th>Name</th><td>${name}</td></tr>
    <tr><th>Rate</th><td class="right">${rate}</td><th>Reg Hrs</th><td class="right">${regHrs}</td></tr>
    <tr><th>OT Hrs</th><td class="right">${otHrs}</td><th>Gross Pay</th><td class="right">${gross}</td></tr>
  </table>

  <div class="section">
    <table>
      <tr><th colspan="2">Earnings</th></tr>
      <tr><td>Regular Pay</td><td class="right">${regPay}</td></tr>
      <tr><td>OT Pay</td><td class="right">${otPay}</td></tr>
    </table>
  </div>

  <div class="section">
    <table>
      <tr><th colspan="2">Deductions</th></tr>
      <tr><td>Pag-IBIG</td><td class="right">${pagibig}</td></tr>
      <tr><td>PhilHealth</td><td class="right">${philhealth}</td></tr>
      <tr><td>SSS</td><td class="right">${sss}</td></tr>
      <tr><td>SSS Loan</td><td class="right">${sssLoan}</td></tr>
      <tr><td>Pag-IBIG Loan</td><td class="right">${piLoan}</td></tr>
      <tr><td>Account</td><td class="right">${valeAmt}</td></tr>
      <tr><td>Wednesday Vale</td><td class="right">${wedValeAmt}</td></tr>
      <tr><td>Adjustments</td><td class="right">${adjAmt}</td></tr>
      <tr><th>Total Deductions</th><th class="right">${totalDed}</th></tr>
    </table>
  </div>

  <div class="section">
    <table>
      <tr><th>Net Pay</th><th class="right">${net}</th></tr>
    </table>
  </div>
</body></html>`;

  var w = window.open('', '', 'width=800,height=900');
  if (!w) return;
  w.document.open();
  w.document.write(html);
  try{ w.document.title = ' '; }catch(e){}
  w.document.close();
  w.focus();
  try{ safePrint(w); }catch(e){}
});
var LS_FROM = (typeof window.LS_FROM !== 'undefined') ? window.LS_FROM : 'dtrDateFrom';
var LS_TO   = (typeof window.LS_TO   !== 'undefined') ? window.LS_TO   : 'dtrDateTo';
function getEl(id){ return document.getElementById(id); }
function loadSaved(){
    const from = localStorage.getItem(LS_FROM) || '';
    const to   = localStorage.getItem(LS_TO) || '';
    const f = getEl('dtrDateFrom'), t = getEl('dtrDateTo');
    if (f) f.value = from;
    if (t) t.value = to;
  }

  function withinRange(dateStr, from, to){
    if (!dateStr) return false;
    const s = dateStr.trim();
    if (!s) return false;
    if (from && s < from) return false;
    if (to   && s > to)   return false;
    return true;
  }

  function applyDtrDateFilter(){
    const f = getEl('dtrDateFrom')?.value || '';
    const t = getEl('dtrDateTo')?.value || '';
    try { localStorage.setItem(LS_FROM, f); } catch(e){}
    try { localStorage.setItem(LS_TO, t); } catch(e){}

    const tbody = document.querySelector('#resultsTable tbody');
    if (!tbody) return;
    const hasRange = !!(f || t);

    Array.from(tbody.rows).forEach(tr=>{
      // Adjust the index below if your Date column index is different.
      // Assuming the "Date" column is 4 (0-based), change as necessary.
      const dateStr = (tr.cells[4]?.textContent || '').trim();
      const show = !hasRange || withinRange(dateStr, f, t);
      tr.style.display = show ? '' : 'none';
    });

    // After applying the date filter, recompute the DTR summary to reflect only visible rows.
    const summaryEl = document.getElementById('dtrSummary');
    if (summaryEl) {
      // Initialize totals
      let regSum = 0;
      let otSum  = 0;
      const empSet = new Set();
      const rows = Array.from(tbody.rows);
      let visibleCount = 0;
      rows.forEach(row => {
        // Skip rows hidden by the date filter
        if (row.style.display === 'none') return;
        visibleCount++;
        // Extract values from the Total Regular Hrs and OT Hrs columns (indices 11 and 12)
        const regVal = parseFloat((row.cells[11]?.textContent || '').trim()) || 0;
        const otVal  = parseFloat((row.cells[12]?.textContent || '').trim()) || 0;
        regSum += regVal;
        otSum  += otVal;
        // Collect unique employee IDs (column 0)
        const idCell = (row.cells[0]?.textContent || '').trim();
        if (idCell) empSet.add(idCell);
      });
      // If there are visible rows, update the summary text; otherwise clear it
      if (visibleCount > 0) {
        const totalHours = regSum + otSum;
        summaryEl.textContent = `Grand Total Hours: ${formatHours(totalHours)} | Regular Hours: ${formatHours(regSum)} | OT Hours: ${formatHours(otSum)} | Employees: ${empSet.size}`;
      } else {
        summaryEl.textContent = '';
      }
    }
  }

  function hookUI(){
    const f = getEl('dtrDateFrom');
    const t = getEl('dtrDateTo');
    const c = getEl('dtrDateClear');
    if (f) f.addEventListener('change', applyDtrDateFilter);
    if (t) t.addEventListener('change', applyDtrDateFilter);
    if (c) c.addEventListener('click', ()=>{
      if (f) f.value = '';
      if (t) t.value = '';
      try { localStorage.removeItem(LS_FROM); } catch(e){}
      try { localStorage.removeItem(LS_TO); } catch(e){}
      applyDtrDateFilter();
    });
  }

  function monkeyPatchRender(){
    const orig = window.renderResults;
    if (typeof orig === 'function') {
      window.renderResults = function(){
        orig.apply(this, arguments);
        applyDtrDateFilter();
      };
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // Inject controls right before #resultsTable if not already in DOM.
    if (!document.getElementById('dtrDateControls')){
      const table = document.getElementById('resultsTable');
      if (table && table.parentNode){
        const wrapper = document.createElement('div');
      wrapper.innerHTML = '<div id="dtrDateControls" style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;margin:8px 0;"><label style="display:flex;align-items:center;gap:.35rem;"><span>Date:</span><input id="dtrDateFrom" type="date" /></label><span>-</span><label><input id="dtrDateTo" type="date" /></label><button id="dtrDateClear" type="button">Clear</button></div>';
        table.parentNode.insertBefore(wrapper.firstElementChild, table);
      }
    }
    loadSaved();
    hookUI();
    monkeyPatchRender();
    applyDtrDateFilter();
  });

</script>


<script>
// === Thousands Separator Formatting for Amounts (Payroll & Deductions) ===
(function(){
  // Format helper: 1,234.56
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function formatAllNumbers(){
    var sels = '#payrollTable td.num, #payrollTable tfoot td.num, #deductionsTable td.num';
    document.querySelectorAll(sels).forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g, '').trim();
      var num = parseFloat(raw);
      if (isFinite(num)) {
        if (num === 0) {
          td.textContent = '-';
        } else {
          td.textContent = fmt(num);
        }
      }
    });
    // Inputs: hide zeros by showing blank
    document.querySelectorAll('#payrollTable input.regHrs, #payrollTable input.otHrs, #payrollTable input.rate').forEach(function(inp){
      var v = parseFloat(inp.value);
      if (!isNaN(v) && v === 0) { inp.value = ''; }
    });
  }

  // Patch calculateAll to apply formatting after calculations
  function patchCalculateAll(){
    try{
      var orig = window.calculateAll;
      if (typeof orig === 'function'){
        window.calculateAll = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      } else {
        // If not defined yet, retry after load
        document.addEventListener('DOMContentLoaded', function(){
          if (typeof window.calculateAll === 'function'){
            patchCalculateAll(); 
            try { formatAllNumbers(); } catch(e){}
          }
        });
      }
    }catch(e){}
  }

  // Also patch renderDeductionsTable so that a manual refresh there also formats
  function patchRenderDeductions(){
    try{
      var orig = window.renderDeductionsTable;
      if (typeof orig === 'function'){
        window.renderDeductionsTable = function(){
          var out = orig.apply(this, arguments);
          try { formatAllNumbers(); } catch(e){}
          return out;
        };
      }
    }catch(e){}
  }

  // Initial hooks
  patchCalculateAll();
  patchRenderDeductions();
  document.addEventListener('DOMContentLoaded', function(){
    try { formatAllNumbers(); } catch(e){}
  });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function patch(fnName){
    var orig=window[fnName];
    if(typeof orig==='function'){
      window[fnName]=function(){
        var out=orig.apply(this,arguments);
        try{formatAllNumbers();}catch(e){}
        return out;
      }
    }
  }
  patch('calculateAll');
  patch('renderDeductionsTable');
  patch('renderReportTable');
  patch('renderTable');
  document.addEventListener('DOMContentLoaded', function(){ try{ window.formatAllNumbers && formatAllNumbers(); }catch(e){} });
})();
</script>

<script>
(function(){
  function fmt(n){
    var num = Number(n);
    if (!isFinite(num)) return String(n || '');
    return num.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
  }
  function formatCells(cells){
    cells.forEach(function(td){
      var raw = (td.textContent || '').replace(/,/g,'').trim();
      if (raw === '') return;
      var num = parseFloat(raw);
      if (isFinite(num)) td.textContent = fmt(num);
    });
  }
  function formatProjectTotals(){
    var tbl = document.getElementById('projectTotalsTable');
    if(!tbl) return;
    var tds = tbl.querySelectorAll('tbody td, tfoot td');
    formatCells(Array.from(tds));
  }
  function formatProjectModal(){
    var box = document.getElementById('projectReportContent');
    if (!box) return;
    var tds = box.querySelectorAll('td');
    formatCells(Array.from(tds));
  }
  // Patch showProjectReport to format modal numbers
  (function(){
    var orig = window.showProjectReport;
    if (typeof orig === 'function'){
      window.showProjectReport = function(){
        var out = orig.apply(this, arguments);
        try { formatProjectModal(); } catch(e){}
        return out;
      };
    }
  })();
  // Observe changes on the project totals table and auto-format
  document.addEventListener('DOMContentLoaded', function(){
    formatProjectTotals();
    var tbl = document.getElementById('projectTotalsTable');
    if (tbl && window.MutationObserver){
      var timer = null;
      var mo = new MutationObserver(function(){
        clearTimeout(timer);
        timer = setTimeout(formatProjectTotals, 50);
      });
      mo.observe(tbl.tBodies[0] || tbl, { childList: true, subtree: true });
    }
  });
})();
</script>


<script>
(function(){
  const ACTIVE_KEY = 'payroll_active';            // object map: key=start_end, value={startDate,endDate,rows,totals}
  const CURRENT_KEY = 'current_active_week';      // string: "YYYY-MM-DD__YYYY-MM-DD"
  const HIST_KEY = 'payroll_hist';                // existing history (may contain locked snapshots)

  function loadJSON(k, d){ try{ return JSON.parse(localStorage.getItem(k)||''); }catch(_){ return d; } }
  function saveJSON(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); }catch(_){} }

  function toKey(s,e){ return (s||'') + '__' + (e||''); }
  function fromKey(k){ const [s,e] = String(k||'').split('__'); return {start:s,end:e}; }

  // Build active store from locked history (one-time, if active is empty)
  function maybeSeedActiveFromHistory(){
    let active = loadJSON(ACTIVE_KEY, null);
    if (active && typeof active === 'object' && Object.keys(active).length) return;
    const hist = loadJSON(HIST_KEY, []);
    active = {};
    (hist||[]).forEach(s=>{
      if (s && s.startDate && s.endDate /* && s.locked */){
        const key = toKey(s.startDate, s.endDate);
        active[key] = { startDate:s.startDate, endDate:s.endDate, rows:s.rows||[], totals:s.totals||{} };
      }
    });
    saveJSON(ACTIVE_KEY, active);
  }

  function upsertActiveWeek(snap){
    if(!snap || !snap.startDate || !snap.endDate) return;
    const key = toKey(snap.startDate, snap.endDate);
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    active[key] = { startDate:snap.startDate, endDate:snap.endDate, rows:snap.rows||[], totals:snap.totals||{} };
    saveJSON(ACTIVE_KEY, active);
    localStorage.setItem(CURRENT_KEY, key);
  }

  function listActiveWeeks(){
    const active = loadJSON(ACTIVE_KEY, {}) || {};
    return Object.keys(active).sort().map(k=>({ key:k, ...fromKey(k) }));
  }

  function fillActiveWeekSelects(){
    const weeks = listActiveWeeks();
    const current = localStorage.getItem(CURRENT_KEY) || (weeks[weeks.length-1]?.key || '');
    if (current) localStorage.setItem(CURRENT_KEY, current);
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      const prev = sel.value;
      sel.innerHTML='';
      weeks.forEach(w=>{
        const opt = document.createElement('option');
        opt.value = w.key;
        opt.textContent = `${w.start} - ${w.end}`;
        sel.appendChild(opt);
      });
      if (weeks.length){
        sel.value = current && weeks.some(w=>w.key===current) ? current : weeks[weeks.length-1].key;
      }
    });
  }

  function applyActiveWeekToGlobals(){
    const key = localStorage.getItem(CURRENT_KEY) || '';
    const {start,end} = fromKey(key);
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    if (ws) ws.value = start || ws.value;
    if (we) we.value = end || we.value;
  }

  function reRenderAll(){
    try{ applyActiveWeekToGlobals(); }catch(_){}
    try{ window.renderResults && renderResults(); }catch(_){}
    try{ window.calculateAll && calculateAll(); }catch(_){}
    try{ window.renderReportTable && renderReportTable(); }catch(_){}
    // If you have totals/project tables:
    try{ window.formatAllNumbers && formatAllNumbers(); }catch(_){}
  }

  // Wire the dropdown "Apply" buttons
  function hookActiveWeekUI(){
    document.querySelectorAll('.refreshActiveWeek').forEach(btn=>{
      if (btn._wired) return;
      btn._wired = true;
      btn.addEventListener('click', ()=>{
        const sel = btn.parentElement && btn.parentElement.querySelector('.activeWeekSelect');
        if (!sel) return;
        localStorage.setItem(CURRENT_KEY, sel.value || '');
        applyActiveWeekToGlobals();
        reRenderAll();
      });
    });
    document.querySelectorAll('.activeWeekSelect').forEach(sel=>{
      if (sel._wired) return;
      sel._wired = true;
      sel.addEventListener('change', ()=>{
        localStorage.setItem(CURRENT_KEY, sel.value || '');
      });
    });
  }

  // Patch Generate to upsert into ACTIVE store (while keeping existing behavior)
  function patchGenerateToActive(){
    const btn = document.getElementById('dashGenerate');
    if (!btn || btn._activeWired) return;
    btn._activeWired = true;
    btn.addEventListener('click', async ()=>{
      // Wait a moment for existing listeners to compute tables, then capture
      setTimeout(()=>{
        try{
          const ws = document.getElementById('weekStart')?.value;
          const we = document.getElementById('weekEnd')?.value;
          if (!ws || !we) return;
          // Try to collect current payroll rows/totals from existing functions
          if (typeof window.buildSnapshot === 'function'){
            (async ()=>{
              const snap = await window.buildSnapshot(ws, we);
              if (snap) upsertActiveWeek(snap);
              fillActiveWeekSelects();
            })();
          } else {
            // Fallback: minimal capture from payroll table if present
            const rows = [];
            document.querySelectorAll('#payrollTable tbody tr').forEach(tr=>{
              rows.push(Array.from(tr.cells).map(td=>td.textContent.trim()));
            });
            upsertActiveWeek({ startDate: ws, endDate: we, rows, totals:{} });
            fillActiveWeekSelects();
          }
        }catch(_){}
      }, 300);
    }, { capture: true });
  }

  // On load
  document.addEventListener('DOMContentLoaded', ()=>{
    maybeSeedActiveFromHistory();
    fillActiveWeekSelects();
    hookActiveWeekUI();
    patchGenerateToActive();

    // Optional: visually disable weekStart/weekEnd outside dashboard
    try {
      const onHashChange = () => {
        const ws = document.getElementById('weekStart');
        const we = document.getElementById('weekEnd');
        // Simple heuristic: if dashboard panel isn't visible, keep inputs disabled
        const dash = document.getElementById('panelDashboard');
        const dashActive = dash && (dash.classList.contains('active') || dash.style.display !== 'none');
        const disabled = !dashActive;
        if (ws) ws.disabled = disabled;
        if (we) we.disabled = disabled;
      };
      onHashChange();
      window.addEventListener('hashchange', onHashChange);
    } catch(_){}
  });
})();
</script>

<!-- Script to manage global Active Payroll dropdown and New Period functionality -->
<script>
(function(){
  const PAYROLL_HIST_KEY = 'payroll_hist';
  const LS_ACTIVE_INDEX = 'payroll_active_index';

  function loadHistory() {
    try {
      const hist = JSON.parse(localStorage.getItem(PAYROLL_HIST_KEY)) || [];
      return Array.isArray(hist) ? hist : [];
    } catch (e) {
      return [];
    }
  }

  function saveActiveIndex(idx) {
    localStorage.setItem(LS_ACTIVE_INDEX, String(idx));
  }

  function getActiveIndex() {
    const v = localStorage.getItem(LS_ACTIVE_INDEX);
    const n = v == null ? -1 : parseInt(v, 10);
    return Number.isFinite(n) ? n : -1;
  }

  function toIsoDate(s){
  if(!s) return '';
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) {
    const mm = String(parseInt(m[1],10)).padStart(2,'0');
    const dd = String(parseInt(m[2],10)).padStart(2,'0');
    return m[3] + '-' + mm + '-' + dd;
  }
  const d = new Date(s);
  if (!isNaN(d)) return d.toISOString().slice(0,10);
  return '';
}
function updateWeekInputs(snap) {
  const startISO = toIsoDate(snap && snap.startDate);
  const endISO   = toIsoDate(snap && snap.endDate);

  const ws = document.getElementById('weekStart');
  const we = document.getElementById('weekEnd');
  if (ws) ws.value = startISO || '';
  if (we) we.value = endISO   || '';

  // Notify listeners that the week range changed (so Reports can re-render)
  try {
    if (ws) ws.dispatchEvent(new Event('change', { bubbles: true }));
    if (we) we.dispatchEvent(new Event('change', { bubbles: true }));
  } catch (_) {}

  // DTR date inputs (type=date) must receive ISO; then fire change events
  try {
    const df = document.getElementById('dtrDateFrom');
    const dt = document.getElementById('dtrDateTo');
    if (df) { df.value = startISO || ''; df.dispatchEvent(new Event('change', { bubbles: true })); }
    if (dt) { dt.value = endISO   || ''; dt.dispatchEvent(new Event('change', { bubbles: true })); }
  } catch (_) {}

  // Refresh DTR list immediately
  try { if (typeof renderResults === 'function') { renderResults(); } } catch (e) {}

  // Recalculate payroll if available, deriving hours from the DTR results table
  try { if (typeof calculatePayrollFromResultsTable === 'function') { calculatePayrollFromResultsTable(); } else if (typeof calculatePayrollFromRecords === 'function') { calculatePayrollFromRecords(); } } catch (e) {}

  // After updating the week range, toggle editing state based on whether the
  // selected period is locked. Without this, switching between periods would
  // incorrectly leave the UI enabled for locked snapshots or vice versa.
  try {
    if (typeof checkAndToggleEditState === 'function') {
      checkAndToggleEditState();
    }
  } catch (e) {}
}

  function populateDropdowns() {
    // Prefer the global payrollHistory array if available, else fall back to localStorage
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const history = Array.isArray(hist) ? hist : [];
    // Build list of items with their original indices; sort newest first by start date
    const items = history.map((s, i) => Object.assign({ i: i }, s)).sort((a, b) => {
      return (b.startDate || '').localeCompare(a.startDate || '');
    });
    const globalSelect = document.getElementById('activePayrollSelect');
    const panelSelects = Array.from(document.querySelectorAll('.activeWeekSelect'));
    function fill(selectEl) {
      if (!selectEl) return;
      // Rebuild the dropdown options
      selectEl.innerHTML = '';
      items.forEach(item => {
        const opt = document.createElement('option');
        opt.value = String(item.i);
        opt.textContent = `${item.startDate || ''} - ${item.endDate || ''}${item.locked ? ' (locked)' : ''}`;
        selectEl.appendChild(opt);
      });
      // Always set the selected value to the saved active index so all selectors stay in sync
      const saved = String(getActiveIndex());
      if ([...selectEl.options].some(o => o.value === saved)) {
        selectEl.value = saved;
      } else if (selectEl.options.length) {
        selectEl.selectedIndex = 0;
      }
    }
    fill(globalSelect);
    panelSelects.forEach(sel => {
      if (sel !== globalSelect) fill(sel);
    });
    // after filling, apply active
    const idxVal = parseInt((globalSelect && globalSelect.value) || getActiveIndex(), 10);
    const snap = Number.isFinite(idxVal) ? history[idxVal] : null;
    if (snap) {
      saveActiveIndex(idxVal);
      updateWeekInputs(snap);
    }
  }

  function onSelectChange(e) {
    const idx = parseInt(e.target.value, 10);
    if (!Number.isFinite(idx)) return;
    const history = loadHistory();
    if (!history[idx]) return;
    saveActiveIndex(idx);
    updateWeekInputs(history[idx]);
    // Keep all selects in sync
    populateDropdowns();
  }

  async function createNewPeriodSnapshot(start, end){
    if (!start || !end) return;
    // Normalize to ISO (YYYY-MM-DD)
    const toIso = (s)=>{ try{ return s && /^\d{4}-\d{2}-\d{2}$/.test(s) ? s : (new Date(s)).toISOString().slice(0,10); } catch { return s; } };
    let s = toIso(start), e = toIso(end);
    if (s && e && s > e) { const t = s; s = e; e = t; }
    // Prevent duplicates
    const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : loadHistory();
    const exists = hist.some(x => x && x.startDate === s && x.endDate === e);
    if (exists) { alert('A payroll snapshot for this date range already exists.'); return; }
    if (typeof buildSnapshot !== 'function') { alert('buildSnapshot function not available.'); return; }
    const snap = await buildSnapshot(s, e);
    if (!snap) { alert('Payroll table is missing or empty.'); return; }
    const json = JSON.stringify(snap);
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(json));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    const now = new Date().toISOString();
    const newSnap = { startDate: s, endDate: e, rows: snap.rows, totals: snap.totals, hash: hashHex, lockedAt: now, locked: false };
    if (Array.isArray(window.payrollHistory)) {
      window.payrollHistory.push(newSnap);
      if (typeof saveHistory === 'function') saveHistory();
    } else {
      const localHist = loadHistory();
      localHist.push(newSnap);
      localStorage.setItem(PAYROLL_HIST_KEY, JSON.stringify(localHist));
    }
    // Refresh UI pieces
    try { if (typeof renderHistory === 'function') renderHistory(); } catch {}
    try { if (typeof renderActivePayrolls === 'function') renderActivePayrolls(); } catch {}
    // Set new active index (last)
    let idx;
    if (Array.isArray(window.payrollHistory)) idx = window.payrollHistory.length - 1; else idx = (loadHistory().length - 1);
    saveActiveIndex(idx);
    populateDropdowns();
  }

  function validateNewPeriodForm(){
    const sEl = document.getElementById('newPeriodStart');
    const eEl = document.getElementById('newPeriodEnd');
    const err = document.getElementById('newPeriodErr');
    const saveBtn = document.getElementById('saveNewPeriod');
    const s = sEl && sEl.value || '';
    const e = eEl && eEl.value || '';
    const ok = !!s && !!e && (!s || !e || s <= e);
    if (err) err.style.display = (s && e && s > e) ? 'block' : 'none';
    if (saveBtn) saveBtn.disabled = !ok;
    return ok;
  }

  function setNewPeriodBusy(busy){
    const saveBtn = document.getElementById('saveNewPeriod');
    const cancelBtn = document.getElementById('cancelNewPeriod');
    const status = document.getElementById('newPeriodStatus');
    const spin = document.getElementById('newPeriodSpin');
    if (status) status.style.display = busy ? 'inline-flex' : 'none';
    if (spin) spin.style.display = busy ? 'inline-block' : 'none';
    if (saveBtn) saveBtn.disabled = !!busy;
    if (cancelBtn) cancelBtn.disabled = !!busy;
  }

  function ensureNewPeriodBindings(){
    const modal = document.getElementById('newPeriodModal');
    if (!modal) return;
    if (!modal.__bound){
      modal.addEventListener('click', (e)=>{ if (e.target === modal) { modal.style.display = 'none'; } });
      document.getElementById('cancelNewPeriod')?.addEventListener('click', ()=>{ if (!document.getElementById('cancelNewPeriod').disabled) modal.style.display='none'; });
      const saveBtn = document.getElementById('saveNewPeriod');
      if (saveBtn){
        saveBtn.addEventListener('click', async ()=>{
          if (!validateNewPeriodForm()) return;
          setNewPeriodBusy(true);
          // allow spinner to render
          await new Promise(r=>setTimeout(r,0));
          const s = (document.getElementById('newPeriodStart')||{}).value || '';
          const e = (document.getElementById('newPeriodEnd')||{}).value || '';
          await createNewPeriodSnapshot(s, e);
          setNewPeriodBusy(false);
          modal.style.display = 'none';
        });
      }
      const sEl = document.getElementById('newPeriodStart');
      const eEl = document.getElementById('newPeriodEnd');
      const syncMins = ()=>{ try{ if (eEl) eEl.min = sEl && sEl.value ? sEl.value : ''; } catch{} };
      sEl?.addEventListener('input', ()=>{ syncMins(); validateNewPeriodForm(); });
      eEl?.addEventListener('input', ()=>{ validateNewPeriodForm(); });
      syncMins();
      // Keyboard shortcuts
      modal.addEventListener('keydown', async (ev)=>{
        if (ev.key === 'Escape') { ev.preventDefault(); if (!document.getElementById('cancelNewPeriod').disabled) modal.style.display='none'; }
        if (ev.key === 'Enter') { ev.preventDefault(); if (validateNewPeriodForm()) document.getElementById('saveNewPeriod').click(); }
      });
      modal.__bound = true;
    }
  }

  function onNewPeriod() {
    const modal = document.getElementById('newPeriodModal');
    ensureNewPeriodBindings();
    if (!modal) return;
    // Prefill from existing inputs
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const sEl = document.getElementById('newPeriodStart');
    const eEl = document.getElementById('newPeriodEnd');
    if (sEl) sEl.value = (ws && ws.value) || '';
    if (eEl) eEl.value = (we && we.value) || '';
    // Reset UI state
    const err = document.getElementById('newPeriodErr');
    if (err) err.style.display = 'none';
    setNewPeriodBusy(false);
    validateNewPeriodForm();
    modal.style.display = 'flex';
    try { modal.setAttribute('tabindex','-1'); modal.focus(); } catch{}
    // Focus start date without forcing the picker to open (avoids jank)
    setTimeout(()=>{ try{ sEl?.focus(); } catch{} }, 0);
  }

  function onPanelApply(e) {
    const wrap = e.target.closest('.active-week-bar');
    if (!wrap) return;
    const sel = wrap.querySelector('.activeWeekSelect');
    if (!sel) return;
    onSelectChange({ target: sel });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const globalSelect = document.getElementById('activePayrollSelect');
    if (globalSelect) {
      globalSelect.addEventListener('change', onSelectChange);
    }
    const newBtn = document.getElementById('newPayrollPeriod');
    if (newBtn) {
      newBtn.addEventListener('click', onNewPeriod);
    }
    // Bind modal controls once DOM is ready for instant usage
    try { ensureNewPeriodBindings(); } catch(_){ }
    document.addEventListener('click', (e) => {
      if (e.target && e.target.classList && e.target.classList.contains('refreshActiveWeek')) {
        onPanelApply(e);
      }
    });
    populateDropdowns();
  });

  (function() {
    const tbody = document.querySelector('#historyTable tbody');
    if (!tbody) return;
    const observer = new MutationObserver(() => {
      try {
        populateDropdowns();
      } catch (err) {}
    });
    observer.observe(tbody, { childList: true, subtree: false });
  })();
})();
</script>

<script>
/* Cash Advance Tracker implementation.  Handles sub-tab navigation within the
 * Deductions tab and provides a per-employee cash advance table that stores
 * original amounts, deductions and current balances.  The tracker updates
 * the main Deductions table's Vale column via the `vale` object and calls
 * `calculateAll()` whenever a deduction or payment changes. */

(function(){
  // Ensure new cash-advance keys are mirrored to Supabase by adding them to KNOWN_KEYS.
  // Use window.KNOWN_KEYS exclusively because the constant KNOWN_KEYS is scoped to the
  // module that defines the Supabase adapter. Without referencing window.KNOWN_KEYS
  // here, attempts to push new keys could throw a ReferenceError if KNOWN_KEYS is
  // not defined in the global scope. Wrapping in a try/catch protects against any
  // unexpected errors while still allowing the page to function normally.
  try {
    const extra = ['payroll_cashAdvanceOrig', 'payroll_cashAdvanceDed', 'payroll_cashAdvanceBal'];
    if (window.KNOWN_KEYS) {
      extra.forEach(k => {
        const keys = window.KNOWN_KEYS;
        if (!Array.isArray(keys)) return;
        if (!keys.includes(k)) keys.push(k);
      });
    }
  } catch (err) {
    // Swallow errors silently; failure to add keys will simply leave them local-only.
  }

  // Render the cash advance tracker table
  function renderCashAdvanceTable() {
    syncPeriodScopedData();
    const tb = document.querySelector('#cashAdvanceTable tbody');
    if (!tb) return;
    tb.innerHTML = '';
    (employeeList || []).forEach(emp => {
      const id = emp.id;
      const name = emp.name || '';
      const origVal = Number(cashOrig[id] ?? 0);
      const dedVal  = Number(cashDed[id] ?? 0);
      // Determine the current balance.  If no explicit balance is stored for
      // this employee yet, default to the original amount (not yet updated).
      const hasBal = cashBal.hasOwnProperty(id);
      const balVal = hasBal ? Number(cashBal[id] || 0) : origVal;
      // Decide if update button should be disabled and what label it should have.
      // The update button remains active after each click to allow multiple deductions until the balance is zero.
      let btnLabel = 'Update';
      let disabled = false;
      if (!origVal || !dedVal) {
        // Need both original amount and deduction to enable update
        disabled = true;
      } else if (balVal <= 0) {
        // Fully paid off
        btnLabel = 'Paid';
        disabled = true;
      }
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${id}</td>
        <td class="wrap">${name}</td>
        <td><input type="number" step="0.01" class="cashOrig" data-id="${id}" value="${origVal || ''}"></td>
        <td><input type="number" step="0.01" class="cashDed" data-id="${id}" value="${dedVal || ''}"></td>
        <td class="cashBal">${balVal ? balVal.toFixed(2) : '0.00'}</td>
        <td><button class="cashUpdateBtn" data-id="${id}" ${disabled ? 'disabled' : ''}>${btnLabel}</button></td>
      `;
      tb.appendChild(tr);
    });
    attachCashAdvanceHandlers();
  }

  function attachCashAdvanceHandlers() {
    // Handle original amount changes
    document.querySelectorAll('.cashOrig').forEach(inp => {
      // Update the inâ€‘memory values on every keystroke but defer reâ€‘rendering
      inp.addEventListener('input', () => {
        const id = inp.getAttribute('data-id');
        const val = parseFloat(inp.value);
        if (!isNaN(val) && val > 0) {
          cashOrig[id] = +(val.toFixed(2));
          // Reset balance to original whenever original amount changes
          cashBal[id] = +(val.toFixed(2));
        } else {
          delete cashOrig[id];
          delete cashBal[id];
        }
        localStorage.setItem(LS_CASH_ORIG, JSON.stringify(cashOrig));
        localStorage.setItem(LS_CASH_BAL, JSON.stringify(cashBal));
        // Do not call renderCashAdvanceTable() here; this would rebuild the table
        // on every keystroke and cause the input to lose focus.  Reâ€‘render on blur instead.
      });
      // When the user finishes editing (on blur/change), rebuild the table so buttons/labels refresh
      inp.addEventListener('change', () => {
        renderCashAdvanceTable();
      });
    });
    // Handle deduction changes
    document.querySelectorAll('.cashDed').forEach(inp => {
      // Update the deduction and recalculate totals on each keystroke but do not reâ€‘render
      inp.addEventListener('input', () => {
        const id = inp.getAttribute('data-id');
        const val = parseFloat(inp.value);
        if (!isNaN(val) && val > 0) {
          cashDed[id] = +(val.toFixed(2));
          // Persist the deduction for this employee
          vale[id] = +(val.toFixed(2));
        } else {
          delete cashDed[id];
          delete vale[id];
        }
        localStorage.setItem(LS_CASH_DED, JSON.stringify(cashDed));
        saveCurrentPeriodDeductions();
        calculateAll();
        // Avoid calling renderCashAdvanceTable() here; it would reset focus on every key press.
      });
      // Rebuild the table when the user commits their change (on blur/change)
      inp.addEventListener('change', () => {
        renderCashAdvanceTable();
      });
    });
    // Handle update (apply a single deduction)
    document.querySelectorAll('.cashUpdateBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-id');
        const orig = Number(cashOrig[id] ?? 0);
        const ded  = Number(cashDed[id] ?? 0);
        // Only proceed if we have valid original and deduction amounts
        if (!orig || !ded) return;
        // Determine the current balance; fall back to original amount if no stored balance exists.
        const currentBal = cashBal.hasOwnProperty(id) ? Number(cashBal[id] || 0) : orig;
        // Compute new balance by subtracting the deduction from the current balance.
        let newBal = +(currentBal - ded);
        if (newBal <= 0) {
          // Fully paid off: set balance to zero and clear deduction and vale
          newBal = 0;
          delete cashDed[id];
          delete vale[id];
          localStorage.setItem(LS_CASH_DED, JSON.stringify(cashDed));
        }
        // Persist the new balance
        cashBal[id] = +(newBal.toFixed(2));
        localStorage.setItem(LS_CASH_BAL, JSON.stringify(cashBal));
        saveCurrentPeriodDeductions();
        calculateAll();
        // Re-render the table to reflect the updated balance; the update button remains active.
        renderCashAdvanceTable();
      });
    });
  }

  // Wire up the sub-tab navigation within the Deductions tab
  document.addEventListener('DOMContentLoaded', () => {
    const navBtns = document.querySelectorAll('#deductionsTab .subtab-nav .subtab-btn');
    navBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        navBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const target = btn.getAttribute('data-subtab');
        // Show the selected panel and hide others
        document.querySelectorAll('#deductionsTab .subtab-panel').forEach(panel => {
          panel.style.display = (panel.id === target) ? '' : 'none';
        });
      });
    });
    // Initialize panel visibility on page load
    document.querySelectorAll('#deductionsTab .subtab-panel').forEach(panel => {
      panel.style.display = (panel.id === 'dedMainSection') ? '' : 'none';
    });
    renderCashAdvanceTable();
  });
  // On page load, immediately check whether the currently selected payroll period
  // is locked and toggle the UI accordingly. Without this, the DTR panel may
  // remain interactive on initial load even if the chosen period has been
  // previously locked. The check is wrapped in a try-catch to avoid
  // exceptions during startup.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if (typeof checkAndToggleEditState === 'function') {
        checkAndToggleEditState();
      }
    } catch (e) {}
  });
})();
</script>

<!-- =====================================================================
     DTR Cloud Persistence with Supabase

     The payroll application originally stored uploaded DTR records exclusively
     in localStorage.  Browsers typically limit localStorage to about 5Â MB,
     which can be quickly exceeded when importing large attendance files.  To
     provide true crossâ€‘device persistence and remove the size constraint,
     the functions below save and load the DTR dataset via Supabase.  They
     expect a table named `dtr_records` in your Supabase database with the
     following schema:

         CREATE TABLE dtr_records (
           id text PRIMARY KEY,
           data jsonb
         );

     The policy can mirror the permissive configuration used for kv_store:

         -- Allow anon users to read and write the single row
         CREATE POLICY "Allow all access to dtr_records" ON dtr_records
           FOR ALL USING (true) WITH CHECK (true);

     The row uses a fixed primary key (id = 'records') so that each upsert
     overwrites the existing dataset.  If you wish to store separate sets
     by period or company, you can adjust the id accordingly.  When the
     page loads it attempts to fetch the remote DTR and, if found, will
     populate the global `storedRecords` array and update localStorage.
     Uploaded files are automatically persisted to the cloud via
     saveDtrToCloud(), invoked in the file upload handler above.
===================================================================== -->
<script>
/*
 * Save the entire DTR dataset to Supabase.  This helper uses the
 * globally scoped `supabase` client (injected by the KV sync adapter)
 * to upsert the records into the `dtr_records` table.  The primary
 * key is fixed to 'records' so that only a single row is maintained.
 */
async function saveDtrToCloud(records) {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return;
    const { error } = await supa
      .from('dtr_records')
      .upsert({ id: 'records', data: records }, { onConflict: 'id' });
    if (error) console.error('Supabase DTR save error:', error.message);
  } catch (e) {
    console.error('Supabase DTR save failed', e);
  }
}

/*
 * Upload a raw DTR file to Supabase Storage.  This helper uploads the
 * original .DAT/.TXT file into the 'dtr_uploads' folder of the 'app'
 * storage bucket.  If the bucket does not exist or the upload fails,
 * the error is logged and the application continues silently.  Each
 * upload uses a timestamp and random suffix to avoid collisions.
 */
async function uploadDtrFileToCloud(file) {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa || !file) return;
    const bucket = supa.storage.from('app');
    // Compose a unique path using a timestamp and random number to avoid collisions
    const path = `dtr_uploads/${Date.now()}_${Math.floor(Math.random() * 1000)}_${file.name}`;
    const { error } = await bucket.upload(path, file, { upsert: false });
    if (error) {
      console.warn('Supabase DTR file upload error:', error.message);
    }
  } catch (err) {
    console.warn('Supabase DTR file upload failed', err);
  }
}

/*
 * Retrieve the DTR dataset from Supabase.  Returns an array of
 * attendance records if available, otherwise null.  The returned
 * object is expected to have the shape { data: [...] }, so we
 * unwrap the nested data field when present.
 */
async function loadDtrFromCloud() {
  try {
    const supa = window.supabase || (typeof supabase !== 'undefined' ? supabase : null);
    if (!supa) return null;
    const { data, error } = await supa
      .from('dtr_records')
      .select('data')
      .eq('id', 'records')
      .maybeSingle();
    if (error) {
      // Only warn on fetch errors to avoid blocking page load.  The
      // application will fall back to localStorage if the fetch fails.
      console.warn('Supabase DTR fetch error:', error.message);
      return null;
    }
    return data && Array.isArray(data.data) ? data.data : null;
  } catch (e) {
    console.error('Supabase DTR fetch failed', e);
    return null;
  }
}

// Helpers to control the remote DTR alert banner.  These functions
// locate the #remoteDtrAlert element and toggle its visibility.  The
// banner notifies users when there is no remote DTR data available
// and encourages them to upload a .DAT/.TXT file to populate the
// cloud.  If the element is not present these helpers silently do
// nothing.
function showRemoteDtrAlert(msg){
  const el = document.getElementById('remoteDtrAlert');
  if (!el) return;
  // Prefix the message with a warning symbol for emphasis
  el.textContent = `âš  ${msg}`;
  el.style.display = '';
}
function hideRemoteDtrAlert(){
  const el = document.getElementById('remoteDtrAlert');
  if (!el) return;
  el.style.display = 'none';
}

// On initial load, attempt to hydrate storedRecords from Supabase.  If
// remote data exists it will overwrite the current storedRecords array
// and localStorage.  This ensures that the latest DTR data is available
// across devices while preserving offline capability.  The call is
// performed after DOMContentLoaded to ensure that other scripts have
// defined storedRecords and renderResults() before we modify them.
document.addEventListener('DOMContentLoaded', async function () {
  try {
    const remote = await loadDtrFromCloud();
    if (Array.isArray(remote) && remote.length) {
      // When remote data is available, replace the inâ€‘memory dataset.  We
      // deliberately overwrite both the local variable and the global
      // window.storedRecords to ensure all modules reference the same
      // canonical source of truth.  Persist into localStorage as an
      // offline fallback, but always prefer Supabase on subsequent loads.
      storedRecords = remote;
      window.storedRecords = remote;
      try { localStorage.setItem(LS_RECORDS, JSON.stringify(remote)); } catch (e) {}
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
      if (typeof hideRemoteDtrAlert === 'function') hideRemoteDtrAlert();
    } else {
      // No remote data: clear any existing local dataset and inform the user. window. try { localStorage.removeItem(LS_RECORDS); } catch (e) {}
      if (typeof renderResults === 'function') {
        try { renderResults(); } catch (e) {}
      }
      if (typeof showRemoteDtrAlert === 'function') {
        showRemoteDtrAlert('No remote DTR data found. Import a .DAT/.TXT file to populate cloud data.');
      }
    }
  } catch (e) {
    console.error('Error hydrating DTR from Supabase', e);
  }
});
</script>

<script>
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    const supabase = window.supabase;
    const KV_TABLE = window.SUPABASE_TABLE || 'kv_store';
    const DTR_TABLE = 'dtr_records';
    const BUCKET = 'backups';
    // locate header to attach controls (fallback to body if missing)
    const header = document.querySelector('#panelPayroll header') || document.body;
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '6px';
    wrap.style.alignItems = 'center';
    wrap.style.marginTop = '10px';
    // status element
    const statusSpan = document.createElement('span');
    statusSpan.id = 'backupStatus';
    statusSpan.style.fontSize = '12px';
    statusSpan.style.color = '#374151';
    // Buttons
    const backupBtn = document.createElement('button');
    backupBtn.id = 'backupNowBtn';
    backupBtn.type = 'button';
    backupBtn.textContent = 'ðŸ”’ Backup Now';
    backupBtn.style.cursor = 'pointer';
    const testBtn = document.createElement('button');
    testBtn.id = 'testRestoreBtn';
    testBtn.type = 'button';
    testBtn.textContent = 'ðŸ§ª Test Restore (Dry Run)';
    testBtn.style.cursor = 'pointer';
    const restoreBtn = document.createElement('button');
    restoreBtn.id = 'restoreBundleBtn';
    restoreBtn.type = 'button';
    restoreBtn.textContent = 'Restore Bundle';
    restoreBtn.style.cursor = 'pointer';
    const listCloudBtn = document.createElement('button');
    listCloudBtn.id = 'listCloudBackups';
    listCloudBtn.type = 'button';
    listCloudBtn.textContent = 'List Backups';
    listCloudBtn.style.cursor = 'pointer';
    listCloudBtn.title = 'Fetch available backups from Supabase storage';
    const cloudSelect = document.createElement('select');
    cloudSelect.id = 'cloudBackupSelect';
    cloudSelect.style.display = 'none';
    const restoreCloudBtn = document.createElement('button');
    restoreCloudBtn.id = 'restoreCloudBtn';
    restoreCloudBtn.type = 'button';
    restoreCloudBtn.textContent = 'Restore Selected';
    restoreCloudBtn.style.cursor = 'pointer';
    restoreCloudBtn.style.display = 'none';
    restoreCloudBtn.title = 'Download the selected backup from Supabase and restore';
    const healthBtn = document.createElement('button');
    healthBtn.id = 'healthCheckBtn';
    healthBtn.type = 'button';
    healthBtn.textContent = 'ðŸ©º Health Check';
    healthBtn.style.cursor = 'pointer';
    const restoreInput = document.createElement('input');
    restoreInput.id = 'restoreFileInput';
    restoreInput.type = 'file';
    restoreInput.accept = '.json';
    restoreInput.style.display = 'none';
    const logDiv = document.createElement('div');
    logDiv.id = 'backupLog';
    logDiv.style.width = '100%';
    logDiv.style.maxWidth = '920px';
    logDiv.style.background = '#ffffff';
    logDiv.style.border = '1px solid #e5e7eb';
    logDiv.style.borderRadius = '8px';
    logDiv.style.padding = '10px';
    logDiv.style.fontSize = '12px';
    logDiv.style.color = '#111111';
    logDiv.style.lineHeight = '1.35';
    logDiv.style.display = 'none';
    // Append children
    wrap.appendChild(statusSpan);
    wrap.appendChild(backupBtn);
    wrap.appendChild(testBtn);
    wrap.appendChild(restoreBtn);
    wrap.appendChild(listCloudBtn);
    wrap.appendChild(cloudSelect);
    wrap.appendChild(restoreCloudBtn);
    wrap.appendChild(healthBtn);
    wrap.appendChild(logDiv);
    wrap.appendChild(restoreInput);
    header.appendChild(wrap);
    // Local references
    const statusEl = statusSpan;
    const logEl = logDiv;
    const btnBackup = backupBtn;
    const btnDry = testBtn;
    const btnRestore = restoreBtn;
    const btnList = listCloudBtn;
    const selectCloud = cloudSelect;
    const btnRestoreCloud = restoreCloudBtn;
    const btnHealth = healthBtn;
    const inputRestore = restoreInput;
    // Utility functions
    function setStatus(msg, isError){
      if (!statusEl) return;
      statusEl.textContent = msg || '';
      statusEl.style.color = isError ? '#b91c1c' : '#374151';
    }
    function logMsg(msg){
      if (!logEl) return;
      if (logEl.style.display === 'none') logEl.style.display = 'block';
      const div = document.createElement('div');
      const now = new Date();
      div.textContent = now.toLocaleTimeString() + ' - ' + msg;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function clearLog(){
      if (logEl){ logEl.innerHTML = ''; logEl.style.display = 'none'; }
    }
    function lockUI(lock){
      [btnBackup, btnDry, btnRestore, btnHealth, inputRestore, btnList, btnRestoreCloud, selectCloud].forEach(function(el){ if (el){ el.disabled = lock; el.style.opacity = lock ? '0.7' : '1'; }});
    }
    async function listBackups(){
      if(!supabase || !supabase.storage){ setStatus('Supabase storage unavailable', true); return; }
      try {
        setStatus('Fetching backups...');
        const { data, error } = await supabase.storage.from(BUCKET).list('');
        if (error){ setStatus('List failed: ' + error.message, true); return; }
        selectCloud.innerHTML = '';
        (data || []).filter(o=>o.name && o.name.endsWith('.json')).sort((a,b)=> b.name.localeCompare(a.name)).forEach(function(obj){
          const opt = document.createElement('option');
          opt.value = obj.name;
          opt.textContent = obj.name;
          selectCloud.appendChild(opt);
        });
        if (selectCloud.options.length){
          selectCloud.style.display = '';
          btnRestoreCloud.style.display = '';
          setStatus('Select a backup to restore');
        } else {
          selectCloud.style.display = 'none';
          btnRestoreCloud.style.display = 'none';
          setStatus('No backups found');
        }
      } catch(e){ setStatus('List failed: ' + e.message, true); }
    }
    async function restoreFromCloud(){
      const name = selectCloud && selectCloud.value;
      if(!name){ alert('Select a backup first'); return; }
      if(!supabase || !supabase.storage){ setStatus('Supabase storage unavailable', true); return; }
      try {
        setStatus('Downloading ' + name + '...');
        const { data, error } = await supabase.storage.from(BUCKET).download(name);
        if (error) throw error;
        const file = new File([data], name, { type: 'application/json' });
        await restoreFile(file, { dryRun: false });
      } catch(e){
        setStatus('Cloud restore failed: ' + e.message, true);
        logMsg('Cloud restore failed: ' + e.message);
      }
    }
    function nowStamp(){
      const d = new Date();
      const iso = d.toISOString().replace(/[:]/g,'').replace(/\.\d{3}Z$/,'Z');
      return iso;
    }
    async function sha256Hex(str){
      const enc = new TextEncoder().encode(str);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
    }
    async function backupNow(){
      try {
        lockUI(true); clearLog(); setStatus('Running backup...');
        logMsg('Starting backup');
        const local = {};
        const lsKeys = Object.keys(localStorage);
        lsKeys.forEach(function(k){
          try { local[k] = localStorage.getItem(k); } catch(e){}
        });
        logMsg('LocalStorage keys: ' + lsKeys.length);
        const TABLES = window.DB_TABLES || [KV_TABLE, DTR_TABLE];
        const db = {};
        let totalRows = 0;
        for (const t of TABLES){
          try {
            const { data, error } = await supabase.from(t).select('*');
            if (error){
              logMsg(t + ' fetch warning: ' + error.message);
              db[t] = [];
            } else {
              db[t] = data || [];
              totalRows += db[t].length;
              logMsg(t + ' rows: ' + db[t].length);
            }
          } catch(e){
            logMsg(t + ' fetch failed: ' + e.message);
            db[t] = [];
          }
        }
        const bundle = {
          schema: 'payrollhub.backup.v1',
          createdAt: new Date().toISOString(),
          local: local,
          db: db
        };
        const withoutHash = JSON.stringify(bundle);
        const hash = await sha256Hex(withoutHash);
        bundle.hash = hash;
        const final = JSON.stringify(bundle, null, 2);
        const blob = new Blob([final], { type: 'application/json' });
        const filename = 'backup-' + nowStamp() + '.json';
        try {
          if (supabase && supabase.storage){
            const { error: upErr } = await supabase.storage.from(BUCKET).upload(filename, blob, { upsert: true, contentType: 'application/json' });
            if (upErr) logMsg('Storage upload skipped: ' + upErr.message);
            else logMsg('Uploaded to storage bucket: ' + BUCKET + '/' + filename);
          }
        } catch(e){ logMsg('Storage error: ' + e.message); }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus('Backup complete âœ“  (Local: ' + lsKeys.length + ', Tables: ' + TABLES.length + ', Rows: ' + totalRows + ')');
        logMsg('Backup complete - SHA256: ' + hash);
      } catch(e){
        console.error(e);
        setStatus('Backup failed: ' + e.message, true);
        logMsg('ERROR: ' + e.message);
        alert('Backup failed: ' + e.message);
      } finally {
        lockUI(false);
      }
    }
    function isObject(o){ return o && typeof o === 'object' && !Array.isArray(o); }
    async function verifyBackup(bundle){
      const local = isObject(bundle.local) ? bundle.local : {};
      const db = isObject(bundle.db) ? bundle.db : {};
      const lsKeys = Object.keys(local);
      const tableNames = Object.keys(db);
      let tablesOk = 0;
      let localOk = 0;
      const tableIssues = [];
      const localIssues = [];
      if (supabase){
        for (const t of tableNames){
          const expected = Array.isArray(db[t]) ? db[t].length : 0;
          try {
            const { count, error } = await supabase.from(t).select('*', { count: 'exact', head: true });
            if (!error && count === expected) tablesOk++;
            else tableIssues.push(t + ': expected ' + expected + ', got ' + (error ? ('error ' + error.message) : count));
          } catch(e){ tableIssues.push(t + ': verify failed - ' + e.message); }
        }
      }
      lsKeys.forEach(function(k){
        try {
          const expected = typeof local[k] === 'string' ? local[k] : JSON.stringify(local[k]);
          const actual = localStorage.getItem(k);
          if (String(actual) === String(expected)) localOk++;
          else localIssues.push(k);
        } catch(e){ localIssues.push(k + ' (' + e.message + ')'); }
      });
      if (tableIssues.length) tableIssues.forEach(function(m){ logMsg('Table mismatch: ' + m); });
      if (localIssues.length) localIssues.forEach(function(m){ logMsg('LocalStorage mismatch: ' + m); });
      logMsg('Verification result - tables: ' + tablesOk + '/' + tableNames.length + ', local: ' + localOk + '/' + lsKeys.length);
      return { tables: { ok: tablesOk, total: tableNames.length }, local: { ok: localOk, total: lsKeys.length } };
    }
    window.verifyBackup = verifyBackup;
    async function restoreFile(file, opts){
      lockUI(true); clearLog();
      try {
        setStatus((opts && opts.dryRun ? 'Dry run: ' : '') + 'Reading file...');
        logMsg('Reading file: ' + file.name);
        const text = await file.text();
        let bundle;
        try { bundle = JSON.parse(text); } catch(e){ setStatus('Invalid JSON', true); throw e; }
        if (!isObject(bundle) || bundle.schema !== 'payrollhub.backup.v1'){ setStatus('Schema mismatch', true); throw new Error('Schema mismatch'); }
        const clone = Object.assign({}, bundle);
        const declared = clone.hash; delete clone.hash;
        const recompute = await sha256Hex(JSON.stringify(clone));
        if (declared && declared !== recompute){ setStatus('Hash mismatch', true); throw new Error('Hash mismatch'); }
        const local = isObject(bundle.local) ? bundle.local : {};
        const db = isObject(bundle.db) ? bundle.db : {};
        const lsKeys = Object.keys(local);
        const tableNames = Object.keys(db);
        logMsg('Bundle valid - Local keys: ' + lsKeys.length + ', Tables: ' + tableNames.length);
        if (opts && opts.dryRun){ setStatus('Dry run passed âœ“'); logMsg('No writes performed'); alert('Dry run OK - no data written.'); return; }
        // Upsert tables
        if (supabase){
          for (const t of tableNames){
            const rows = Array.isArray(db[t]) ? db[t] : [];
            if (!rows.length) continue;
            try {
              const { error } = await supabase.from(t).upsert(rows);
              if (error) logMsg(t + ' upsert warning: ' + error.message);
              else logMsg(t + ' upserted: ' + rows.length);
            } catch(e){ logMsg(t + ' upsert failed: ' + e.message); }
          }
        }
        // Hydrate localStorage
        try {
          lsKeys.forEach(function(k){
            const v = local[k];
            const str = typeof v === 'string' ? v : JSON.stringify(v);
            localStorage.setItem(k, str);
          });
          logMsg('LocalStorage hydrated: ' + lsKeys.length + ' keys');
        } catch(e){ logMsg('LocalStorage hydrate warning: ' + e.message); }
        try {
          if (typeof calculateAll === 'function') calculateAll();
          if (typeof renderDeductionsTable === 'function') renderDeductionsTable();
          if (typeof renderTable === 'function') renderTable();
        } catch(e){}
        const verify = await verifyBackup(bundle);
        const localSummary = verify.local.ok + '/' + verify.local.total;
        const tableSummary = verify.tables.ok + '/' + verify.tables.total;
        const allOk = verify.local.ok === verify.local.total && verify.tables.ok === verify.tables.total;
        const msg = (allOk ? 'Restore complete âœ“ ' : 'Restore completed with discrepancies') +
          ' (Local: ' + localSummary + ', Tables: ' + tableSummary + ')';
        setStatus(msg, !allOk);
        logMsg(msg);
        alert(allOk ? 'Restore complete.' : 'Restore completed with discrepancies. See log.');
      } catch(e){
        console.error(e);
        setStatus('Restore failed: ' + e.message, true);
        logMsg('ERROR: ' + e.message);
        alert('Restore failed: ' + e.message);
      } finally {
        lockUI(false);
      }
    }
    async function healthCheck(){
      lockUI(true); clearLog();
      setStatus('Running health checkâ€¦');
      logMsg('Checking KV table, DTR table, and Storage bucket');
      const results = { kv:false, dtr:false, storage:false };
      try {
        const r = await supabase.from(KV_TABLE).select('key').limit(1);
        if (!r.error){ results.kv = true; logMsg('KV table OK'); } else { logMsg('KV issue: ' + r.error.message); }
      } catch(e){ logMsg('KV exception: ' + e.message); }
      try {
        const r2 = await supabase.from(DTR_TABLE).select('count', { count: 'exact', head: true });
        if (!r2.error){ results.dtr = true; logMsg('DTR table OK'); } else { logMsg('DTR issue: ' + r2.error.message); }
      } catch(e){ logMsg('DTR exception: ' + e.message); }
      try {
        if (supabase && supabase.storage){
          const r3 = await supabase.storage.from(BUCKET).list('', { limit: 1 });
          if (!r3.error){ results.storage = true; logMsg('Storage bucket OK'); } else { logMsg('Storage bucket issue: ' + r3.error.message); }
        } else { logMsg('Supabase storage client not available'); }
    } catch(e){ logMsg('Storage exception: ' + e.message); }
    const summary = 'KV: ' + (results.kv?'OK':'Issue') + ' | DTR: ' + (results.dtr?'OK':'Issue') + ' | Storage: ' + (results.storage?'OK':'Issue');
    setStatus('Health check done - ' + summary, !(results.kv && results.dtr));
    lockUI(false);
    }
    // Attach event listeners
    backupBtn.addEventListener('click', backupNow);
    testBtn.addEventListener('click', function(){
      const tmpInput = document.createElement('input');
      tmpInput.type = 'file';
      tmpInput.accept = '.json';
      tmpInput.onchange = function(e){
        const f = e.target.files && e.target.files[0];
        if (f) restoreFile(f, { dryRun: true });
      };
      tmpInput.click();
    });
    restoreBtn.addEventListener('click', function(){
      inputRestore.click();
    });
    inputRestore.addEventListener('change', function(e){
      const f = e.target.files && e.target.files[0];
      if (f) restoreFile(f, { dryRun: false });
      e.target.value = '';
    });
    healthBtn.addEventListener('click', healthCheck);
    listCloudBtn.addEventListener('click', listBackups);
    restoreCloudBtn.addEventListener('click', restoreFromCloud);
  });
})();
</script>

<script>
// ===== DTR Editor Column (Total Regular & OT editable) =====
(function(){
  const LS_OVR_HOURS = 'att_overrides_hours_v1';
  let overridesHours = {};
  try { overridesHours = JSON.parse(localStorage.getItem(LS_OVR_HOURS) || '{}') || {}; } catch(e){ overridesHours = {}; }
  function saveOverridesHours(){ try { localStorage.setItem(LS_OVR_HOURS, JSON.stringify(overridesHours)); } catch(e){} }
  // Persist overrides to Supabase (kv_store) and fetch initial remote data
  function saveOverridesHoursRemote(){
    try {
      const supabaseClient = window.supabase;
      const table = window.SUPABASE_TABLE;
      if(!supabaseClient || !table) return;
      // Upsert the entire overridesHours object as the value for LS_OVR_HOURS
      supabaseClient
        .from(table)
        .upsert({ key: LS_OVR_HOURS, value: overridesHours }, { onConflict: 'key' })
        .then(({ error }) => {
          if (error) console.warn('Supabase upsert overridesHours error:', error);
        });
    } catch(e){ console.warn('Supabase upsert overridesHours failed', e); }
  }
  // Load remote overridesHours from Supabase on startup, merge/replace local state and apply to table
  (async function loadRemoteOverrides(){
    try {
      const supabaseClient = window.supabase;
      const table = window.SUPABASE_TABLE;
      if(!supabaseClient || !table) return;
      const { data, error } = await supabaseClient
        .from(table)
        .select('value')
        .eq('key', LS_OVR_HOURS)
        .maybeSingle();
      if(!error && data && data.value){
        // replace overridesHours with remote value
        if (typeof data.value === 'object') {
          overridesHours = data.value;
          // persist to local storage for offline use
          saveOverridesHours();
          // apply remote values to table after they've loaded
          applyOverridesToTable();
          recomputeDtrSummaryFromTable();
        }
      }
    } catch(e){ console.warn('Load remote overrides failed', e); }
  })();
  // Subscribe to realtime updates for overridesHours in Supabase so edits on other devices reflect here
  try {
    const supabaseClient = window.supabase;
    const table = window.SUPABASE_TABLE;
    if (supabaseClient && table && supabaseClient.channel) {
      supabaseClient
        .channel('dtr_overrides_hours')
        .on(
          'postgres_changes',
          { event: '*', schema: 'public', table: table, filter: `key=eq.${LS_OVR_HOURS}` },
          (payload) => {
            try {
              const newVal = payload.new && payload.new.value;
              if (newVal && typeof newVal === 'object') {
                overridesHours = newVal;
                saveOverridesHours();
                applyOverridesToTable();
                recomputeDtrSummaryFromTable();
              }
            } catch(e) { console.warn('Realtime payload handling error', e); }
          }
        )
        .subscribe();
    }
  } catch(e){ console.warn('Realtime subscription error:', e); }

  function ensureEditorHeader(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const theadRow = table.querySelector('thead tr');
    if(!theadRow) return;
    if(!theadRow.querySelector('.editor-header')){
      const th = document.createElement('th');
      th.textContent = 'Editor';
      th.className = 'editor-header';
      theadRow.appendChild(th);
    }
  }

  function getColIndexes(table){
    const heads = Array.from(table.querySelectorAll('thead th')).map(th=>th.textContent.trim());
    return {
      regIdx: heads.findIndex(t => /(^(Total\s+)?Regular\s+Hrs$)/i.test(t)),
      otIdx:  heads.findIndex(t => /^OT\s*Hrs$/i.test(t))
    };
  }

  // Generate keys for an editor row.
  // - base key: stable across devices (empId + date)
  // - half key: includes segment when table is split (AM/PM/OT)
  function baseKeyForRow(tr){
    const empId = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
    const date  = tr.cells[4] ? tr.cells[4].textContent.trim() : '';
    return empId + '___' + date;
  }
  function keyForRow(tr){
    const base = baseKeyForRow(tr);
    if (tr.dataset && tr.dataset.half) return base + '___' + tr.dataset.half; // AM/PM/OT
    return base;
  }

  function applyOverridesToTable(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const {regIdx, otIdx} = getColIndexes(table);
    if(regIdx < 0 || otIdx < 0) return;
    table.querySelectorAll('tbody tr').forEach(tr=>{
      const kHalf = keyForRow(tr);
      const kBase = baseKeyForRow(tr);
      const ov = overridesHours[kHalf] || overridesHours[kBase];
      if(ov){
        const regVal = (parseFloat(ov.reg)||0).toFixed(2);
        const otVal  = (parseFloat(ov.ot )||0).toFixed(2);
        const regStar = (Object.prototype.hasOwnProperty.call(ov,'regEdited') ? !!ov.regEdited : true);
        const otStar  = (Object.prototype.hasOwnProperty.call(ov,'otEdited')  ? !!ov.otEdited  : true);
        tr.cells[regIdx].textContent = regVal + (regStar ? ' *' : '');
        tr.cells[otIdx ].textContent = otVal  + (otStar  ? ' *' : '');
      }
    });
  }

  function recomputeDtrSummaryFromTable(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    const {regIdx, otIdx} = getColIndexes(table);
    if(regIdx < 0 || otIdx < 0) return;
    let sumReg = 0, sumOt = 0, empSet = new Set();
    table.querySelectorAll('tbody tr').forEach(tr=>{
      const empId = tr.cells[0] ? tr.cells[0].textContent.trim() : '';
      if(empId) empSet.add(empId);
      const reg = parseFloat(tr.cells[regIdx] && tr.cells[regIdx].textContent) || 0;
      const ot  = parseFloat(tr.cells[otIdx]  && tr.cells[otIdx].textContent)  || 0;
      sumReg += reg; sumOt += ot;
    });
    const summaryEl = document.getElementById('dtrSummary');
    if(summaryEl){
      const total = sumReg + sumOt;
      summaryEl.textContent = 'Grand Total Hours: ' + formatHours(total) + ' | Regular: ' + formatHours(sumReg) + ' | OT Hours: ' + formatHours(sumOt) + ' | Employees: ' + empSet.size;
    }
  }

  function addDtrEditorButtons(){
    const table = document.getElementById('resultsTable');
    if(!table) return;
    ensureEditorHeader();
    const {regIdx, otIdx} = getColIndexes(table);
    if(regIdx < 0 || otIdx < 0) return;
    table.querySelectorAll('tbody tr').forEach(tr => {
      if(tr.querySelector('.dtr-edit-btn')) return;
      const td = document.createElement('td');
      td.className = 'editor-cell';
      const btn = document.createElement('button');
      btn.textContent = 'Edit';
      btn.className = 'dtr-edit-btn';
      btn.addEventListener('click', () => {
        const regCell = tr.cells[regIdx];
        const otCell  = tr.cells[otIdx];
        if(btn.textContent === 'Edit'){
          const regVal = parseFloat(regCell.textContent) || 0;
          const otVal  = parseFloat(otCell.textContent)  || 0;
          regCell.innerHTML = '<input type="number" step="0.01" class="edit-reg" value="'+regVal+'">';
          otCell .innerHTML = '<input type="number" step="0.01" class="edit-ot"  value="'+otVal+'">';
          // remember original values and previous per-column edit flags
          try {
            tr.dataset.origReg = String(regVal.toFixed(2));
            tr.dataset.origOt  = String(otVal.toFixed(2));
            const kHalf0 = keyForRow(tr);
            const kBase0 = baseKeyForRow(tr);
            const ov0 = (overridesHours && (overridesHours[kHalf0] || overridesHours[kBase0])) || null;
            const hadAny = !!ov0;
            const hadReg = hadAny ? (Object.prototype.hasOwnProperty.call(ov0,'regEdited') ? !!ov0.regEdited : true) : false;
            const hadOt  = hadAny ? (Object.prototype.hasOwnProperty.call(ov0,'otEdited')  ? !!ov0.otEdited  : true) : false;
            tr.dataset.hadRegEdited = hadReg ? '1' : '0';
            tr.dataset.hadOtEdited  = hadOt  ? '1' : '0';
          } catch(_){}
          btn.textContent = 'Save';
        } else {
          const regInput = tr.querySelector('input.edit-reg');
          const otInput  = tr.querySelector('input.edit-ot');
          const regVal = parseFloat(regInput && regInput.value) || 0;
          const otVal  = parseFloat(otInput  && otInput.value)  || 0;
          const kHalf = keyForRow(tr);
          const kBase = baseKeyForRow(tr);
          // Determine if values actually changed from original
          const origR = parseFloat(tr.dataset.origReg || 'NaN');
          const origO = parseFloat(tr.dataset.origOt  || 'NaN');
          const hadPrevReg = (tr.dataset.hadRegEdited === '1');
          const hadPrevOt  = (tr.dataset.hadOtEdited  === '1');
          const changedReg = (isFinite(origR) && Math.abs(regVal - origR) > 1e-9);
          const changedOt  = (isFinite(origO) && Math.abs(otVal  - origO) > 1e-9);
          const regEdited  = changedReg || hadPrevReg;
          const otEdited   = changedOt  || hadPrevOt;
          if (regEdited || otEdited){
            const payload = { reg: regVal, ot: otVal, regEdited: !!regEdited, otEdited: !!otEdited };
            // Write both the half-specific key and the base key for cross-device stability
            overridesHours[kHalf] = payload;
            overridesHours[kBase] = payload;
          } else {
            // No per-column edits before or now: remove override entries for both keys
            try { if (Object.prototype.hasOwnProperty.call(overridesHours, kHalf)) delete overridesHours[kHalf]; } catch {}
            try { if (Object.prototype.hasOwnProperty.call(overridesHours, kBase)) delete overridesHours[kBase]; } catch {}
          }
          saveOverridesHours();
          if (typeof saveOverridesHoursRemote === 'function') saveOverridesHoursRemote();
          // Write cells, adding asterisk only to edited columns
          const ovNow = overridesHours && (overridesHours[kHalf] || overridesHours[kBase]);
          const starReg = ovNow ? (Object.prototype.hasOwnProperty.call(ovNow,'regEdited') ? !!ovNow.regEdited : true) : false;
          const starOt  = ovNow ? (Object.prototype.hasOwnProperty.call(ovNow,'otEdited')  ? !!ovNow.otEdited  : true) : false;
          tr.cells[regIdx].textContent = regVal.toFixed(2) + (starReg ? ' *' : '');
          tr.cells[otIdx ].textContent = otVal .toFixed(2) + (starOt  ? ' *' : '');
          btn.textContent = 'Edit';
          recomputeDtrSummaryFromTable();
        }
      });
      td.appendChild(btn);
      tr.appendChild(td);
    });
  }

  function afterRender(){
    applyOverridesToTable();
    addDtrEditorButtons();
    recomputeDtrSummaryFromTable();
  }

  function patchOnce(){
    if (window.__DTR_EDITOR_PATCHED) return;
    window.__DTR_EDITOR_PATCHED = true;
    const orig = window.renderResults;
    if (typeof orig === 'function'){
      window.renderResults = function(){
        const out = orig.apply(this, arguments);
        try { afterRender(); } catch(e){}
        return out;
      };
    }
    document.addEventListener('DOMContentLoaded', afterRender);
  }

  patchOnce();
})();
</script>

<script>
// === Reports: match last date (RWH & OTH) width to the common RWH width of other dates ===
(function(){
  function getTable(){
    const host = document.getElementById('r_table');
    return host ? (host.tagName.toLowerCase()==='table' ? host : host.querySelector('table')) : null;
  }
  function bottomHeader(t){ return t && t.tHead ? t.tHead.rows[t.tHead.rows.length-1] : null; }
  function lastPairIdx(t){
    const row = bottomHeader(t); if (!row) return null;
    const ths = Array.from(row.cells);
    let rwh = -1, oth = -1;
    for (let i = ths.length-1; i >= 0; i--){
      const txt = (ths[i].textContent||'').trim().toUpperCase();
      if (oth === -1 && txt === 'OTH'){ oth = i; continue; }
      if (oth !== -1 && txt === 'RWH'){ rwh = i; break; }
    }
    return (rwh !== -1 && oth !== -1) ? {rwh, oth, ths} : null;
  }
  function modeWidth(numbers){
    const map = new Map();
    numbers.forEach(v=>{ map.set(Math.round(v), (map.get(Math.round(v))||0)+1); });
    let best=0, bestCount=-1;
    map.forEach((c, w)=>{ if (c>bestCount){ best=w; bestCount=c; } });
    return best||90;
  }
  function computeRefWidth(t, idx){
    const row = bottomHeader(t); const ths = Array.from(row.cells);
    const widths = [];
    for (let i=0;i<ths.length;i++){
      const txt = (ths[i].textContent||'').trim().toUpperCase();
      if (txt === 'RWH' && i !== idx.rwh){
        widths.push(ths[i].getBoundingClientRect().width);
      }
    }
    if (!widths.length){
      for (let i=0;i<ths.length;i++){
        const txt = (ths[i].textContent||'').trim().toUpperCase();
        if (txt === 'OTH' && i !== idx.oth){
          widths.push(ths[i].getBoundingClientRect().width);
        }
      }
    }
    return modeWidth(widths);
  }
  function classCols(t, idx, cls){
    // add class to header and all body cells at the given column index
    const row = bottomHeader(t);
    if (row && row.cells[idx]) row.cells[idx].classList.add(cls);
    if (t.tBodies && t.tBodies.length){
      for (const tr of Array.from(t.tBodies[0].rows)){
        if (tr.cells[idx]) tr.cells[idx].classList.add(cls);
      }
    }
  }
  function apply(){
    const t = getTable(); if (!t) return false;
    const pair = lastPairIdx(t); if (!pair) return false;
    const w = computeRefWidth(t, pair);

    // ensure a style root with CSS var
    let style = document.getElementById('__match_last_pair_style');
    if (!style){
      style = document.createElement('style');
      style.id = '__match_last_pair_style';
      style.textContent = `
        :root { --LAST_PAIR_W: ${w}px; }
        #r_table { table-layout: fixed; }
        #r_table .__lastR, #r_table .__lastO {
          width: var(--LAST_PAIR_W) !important;
          min-width: var(--LAST_PAIR_W) !important;
          max-width: var(--LAST_PAIR_W) !important;
          box-sizing: border-box;
          white-space: nowrap;
          text-align: center;
          padding-left: 8px; padding-right: 8px;
        }
        #r_table .__lastR > *, #r_table .__lastO > * {
          display:block; max-width:100%; overflow:hidden;
        }
      `;
      document.head.appendChild(style);
    } else {
      style.textContent = style.textContent.replace(/--LAST_PAIR_W:\s*\d+px/, `--LAST_PAIR_W: ${w}px`);
    }

    // mark both columns with classes
    classCols(t, pair.rwh, '__lastR');
    classCols(t, pair.oth, '__lastO');

    // also set parent header colspan cell width to 2*ref
    if (t.tHead && t.tHead.rows.length >= 2){
      const top = t.tHead.rows[t.tHead.rows.length-2];
      let cur = 0;
      for (const th of Array.from(top.cells)){
        const span = Number(th.getAttribute('colspan')||1);
        if (cur <= pair.rwh && pair.oth < cur + span){
          th.style.width = (w*2) + 'px';
          th.style.minWidth = (w*2) + 'px';
          th.style.maxWidth = (w*2) + 'px';
          th.style.boxSizing = 'border-box';
          break;
        }
        cur += span;
      }
    }
    return true;
  }
  function init(){
    let tries = 0;
    const timer = setInterval(()=>{ tries++; if (apply()) clearInterval(timer); if (tries>80) clearInterval(timer); }, 200);
    try{ new MutationObserver(apply).observe(document.body, {childList:true, subtree:true}); }catch(e){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
// === END ===
</script>

<script>
(function(){
  function applyReportSizing(){ /* disabled: CSS handles widths to avoid twitch */ }

  // Apply after build and on any changes
  function initSizingObserver(){ /* no-op; observers removed to prevent jitter */ }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initSizingObserver);
  } else {
    initSizingObserver();
  }
})();
</script>

<script>
(function(){
  function forcePersonnel150(){ /* disabled: using CSS constraints for first column */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // no observers; width handled by CSS
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>

<script>
(function(){
  function applyTotalsWidth100(){ /* disabled: CSS handles totals columns */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // no observers; widths handled by CSS
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>

<script>
// Clean Reports Print: opens a minimal window with just the reports table.
// Note: Browser header/footer (date, title, URL) are controlled by the print dialog.
// To remove them entirely, uncheck "Headers and footers" in the print settings.
(function(){
  function printReportsClean(){
    try{
      var tbl = document.getElementById('r_table');
      if (!tbl) return;
      var hint = document.getElementById('r_range_hint');
      var css = `
        <style>
          html,body{margin:0;padding:10px;font-family:Arial,Helvetica,sans-serif}
          *{-webkit-print-color-adjust:exact;print-color-adjust:exact}
          h3{margin:0 0 8px 0}
          .proj-title{font-weight:700;font-size:14px;margin:10px 0 6px 0}
          table{width:100%;border-collapse:collapse;font-size:12px;table-layout:fixed}
          table, th, td{border:0.6pt solid #000 !important}
          th,td{padding:4px 6px;vertical-align:middle}
          th{background:#f1f5f9;text-align:left}
          thead{display:table-header-group}
          .left{text-align:left}
          .num{text-align:right}
          .proj-block{page-break-after:always}
          /* First column fixed width with ellipsis, no wrap */
          table th:first-child, table td:first-child{
            width:170px !important; min-width:170px !important; max-width:170px !important;
            white-space:nowrap !important; overflow:hidden; text-overflow:ellipsis;
            word-break: keep-all; overflow-wrap: normal; hyphens: none;
          }
          table th:first-child *, table td:first-child *{ white-space:nowrap !important; }
          /* Make RATE compact to leave more room for names */
          table th:nth-child(2), table td:nth-child(2){
            width:70px; min-width:70px; max-width:80px; white-space:nowrap;
          }
          /* First header row date-group cells (colspan=2 each) => 80px */
          thead tr:first-child th:nth-child(n+3):not(:nth-last-child(-n+4)){
            width: 80px; min-width: 80px; max-width: 80px; white-space: nowrap;
          }
          /* Uniform date column widths (RWH/OTH pairs), exclude the last 4 total columns */
          thead tr:nth-child(2) th:not(:nth-last-child(-n+4)){
            width: 40px; min-width: 40px; max-width: 40px; white-space: nowrap;
          }
          tbody td:nth-child(n+3):not(:nth-last-child(-n+4)){
            width: 40px; min-width: 40px; max-width: 40px; white-space: nowrap;
          }
          /* Totals column widths: Total Reg Hrs, Total OT Hrs, Grand Total Hours, Gross */
          thead tr:nth-child(2) th:nth-last-child(4),
          tbody td:nth-last-child(4){ width: 90px; min-width: 90px; max-width: 100px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(3),
          tbody td:nth-last-child(3){ width: 90px; min-width: 90px; max-width: 100px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(2),
          tbody td:nth-last-child(2){ width: 120px; min-width: 120px; max-width: 140px; white-space: nowrap; }
          thead tr:nth-child(2) th:nth-last-child(1),
          tbody td:nth-last-child(1){ width: 110px; min-width: 110px; max-width: 120px; white-space: nowrap; }
          @media print{ @page { margin: 10mm; } }
        </style>`;

      // Build per-project sections with clear headers (strip inline widths)
      var headHTML = '';
      if (tbl.tHead) {
        try{
          var headClone = tbl.tHead.cloneNode(true);
          headClone.querySelectorAll('th,td').forEach(function(el){ el.removeAttribute('style'); });
          // Force first column (PERSONNEL) to fixed 170px and no-wrap in print
          try {
            headClone.querySelectorAll('tr th:first-child').forEach(function(th){
              th.style.width = '170px';
              th.style.minWidth = '170px';
              th.style.maxWidth = '170px';
              th.style.whiteSpace = 'nowrap';
              th.style.overflow = 'hidden';
              th.style.textOverflow = 'ellipsis';
              th.style.wordBreak = 'keep-all';
              th.style.overflowWrap = 'normal';
              th.style.hyphens = 'none';
            });
          } catch(_e) {}
          headHTML = headClone.innerHTML;
        }catch(e){ headHTML = tbl.tHead.innerHTML; }
      }
      var bodies = tbl.querySelectorAll('tbody.proj-page');
      var blocks = '';
      bodies.forEach(function(tb){
        try{
          var projName = (tb.querySelector('.proj-break td')?.textContent || 'Project').trim();
          var clone = tb.cloneNode(true);
          // Remove inline styles from cells to avoid overriding print CSS
          try{ clone.querySelectorAll('th,td').forEach(function(el){ el.removeAttribute('style'); }); }catch(_){ }
          // Enforce first column width and no-wrap inline to survive print engine quirks
          try{
            clone.querySelectorAll('tr > td:first-child').forEach(function(td){
              if (td && !td.hasAttribute('colspan')){
                td.style.width = '170px';
                td.style.minWidth = '170px';
                td.style.maxWidth = '170px';
                td.style.whiteSpace = 'nowrap';
                td.style.overflow = 'hidden';
                td.style.textOverflow = 'ellipsis';
                td.style.wordBreak = 'keep-all';
                td.style.overflowWrap = 'normal';
                td.style.hyphens = 'none';
              }
            });
          }catch(_e){}
          var first = clone.querySelector('.proj-break');
          if (first) first.parentNode.removeChild(first);
          blocks += '<div class="proj-block">' +
                    '<div class="proj-title">Project: ' + projName + (hint ? ' — ' + (hint.textContent||'') : '') + '</div>' +
                    '<table><thead>' + headHTML + '</thead><tbody>' + clone.innerHTML + '</tbody></table>' +
                   '</div>';
        }catch(e){}
      });
      if (!blocks) { blocks = '<div>No project data to print.</div>'; }
      var html = '<!doctype html><html><head><meta charset="utf-8">' + css + '</head><body>' + blocks + '</body></html>';
      var w = window.open('', '', 'width=1024,height=768');
      if (!w) return;
      w.document.open();
      w.document.write(html);
      // Set a blank title to avoid printing the original long page title in some browsers
      try{ w.document.title = ' '; }catch(e){}
      w.document.close();
      w.focus();
      setTimeout(function(){ try{ safePrint(w); }catch(e){} }, 0);
    }catch(e){ console.warn('Clean print failed', e); }
  }

  function attach(){
    var btn = document.getElementById('r_print');
    if (!btn || btn.__cleanPrint) return;
    btn.addEventListener('click', function(ev){ ev.preventDefault(); printReportsClean(); });
    btn.__cleanPrint = true;
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', attach, {once:true}); }
  else { attach(); }
})();
</script>

<script>
(function(){
  function applyGrandAndGross(){ /* disabled: handled via CSS to avoid twitch */ }
  function init(){
    var tbl = document.getElementById('r_table');
    if(!tbl) return;
    // widths handled by CSS; no observers to prevent layout jitter
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>
<!-- Remove Payroll backup/test/restore/health UI -->
<style>
  #backupNowBtn,
  #testRestoreBtn,
  #restoreBundleBtn,
  #healthCheckBtn,
  #backupLog,
  #backupStatus { display: none !important; }
  /* Also hide the extra spacing wrapper if left behind */
  #panelPayroll header > div:has(#backupNowBtn) { display: none !important; }
</style>
<script>
  (function(){
    function removeBackupUI(){
      try {
        var btn = document.getElementById('backupNowBtn');
        if (btn && btn.parentElement) { btn.parentElement.remove(); }
        var log = document.getElementById('backupLog'); if (log) log.remove();
      } catch(e){}
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', removeBackupUI, { once:true });
    } else {
      removeBackupUI();
    }
  })();
  </script>

<script>
// Auto-update "Total Hours" (Reg + OT) using lightweight event hooks
(function(){
  function findColIdxByHeader(tbl, text){
    if (!tbl) return -1;
    const ths = tbl.querySelectorAll('thead th');
    for (let i=0;i<ths.length;i++){
      const t = (ths[i].textContent||'').trim().toLowerCase();
      if (t === String(text||'').toLowerCase()) return i;
    }
    return -1;
  }
  function num(x){
    const n = parseFloat(String(x==null?'':x).replace(/[^0-9.\-]/g,''));
    return isNaN(n) ? 0 : n;
  }
  function computeTotalHoursForTable(){
    const tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    const regIdx = findColIdxByHeader(tbl, 'Regular Hrs') || findColIdxByHeader(tbl, 'Total Regular Hrs');
    const otIdx  = findColIdxByHeader(tbl, 'OT Hrs');
    const totIdx = findColIdxByHeader(tbl, 'Total Hours');
    if (regIdx < 0 || otIdx < 0 || totIdx < 0) return;
    const rows = tbl.tBodies && tbl.tBodies[0] ? Array.from(tbl.tBodies[0].rows) : [];
    for (const tr of rows){
      const regCell = tr.cells[regIdx];
      const otCell  = tr.cells[otIdx];
      const totCell = tr.cells[totIdx];
      if (!regCell || !otCell || !totCell) continue;
      const reg = num(regCell.textContent);
      const ot  = num(otCell.textContent);
      totCell.textContent = (reg + ot).toFixed(2);
    }
  }
  function hookTable(){
    const tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    const run = () => { try{ computeTotalHoursForTable(); }catch(e){} };
    // Also watch DOM changes (rows re-rendered after edits) and recompute
    const tbody = tbl.tBodies && tbl.tBodies[0];
    if (tbody) {
      let t = null;
      const obs = new MutationObserver(() => {
        if (t) clearTimeout(t);
        t = setTimeout(run, 0); // micro-debounce
      });
      obs.observe(tbody, { childList: true, subtree: true, characterData: true });
      // save ref
      window.__dtrTotalsObserver = obs;
    }

    // Recompute on typical edit signals
    ['input','change','keyup'].forEach(evt => tbl.addEventListener(evt, run, true));
    // Also expose a manual trigger for existing code paths
    window.computeTotalHoursForTable = computeTotalHoursForTable;
    // First run
    run();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', hookTable);
  } else {
    hookTable();
  }
})();
</script>

<script>
// ---- Unified visible-rows totals & footer sync (applied) ----
(function(){
  function norm(s){ return String(s||'').trim().toLowerCase(); }
  function num(txt){
    var v = parseFloat(String(txt==null?'':txt).replace(/[^0-9.\-]/g,''));
    return isNaN(v) ? 0 : v;
  }
  function findColIndex(ths, labelOrFn){
    for (var i=0;i<ths.length;i++){
      var t = norm(ths[i].textContent);
      if (typeof labelOrFn === 'function'){ if (labelOrFn(t)) return i; }
      else if (t === norm(labelOrFn)) return i;
    }
    return -1;
  }
  function computeVisibleTotals(){
    var tbl = document.getElementById('resultsTable');
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return null;
    var ths = tbl.querySelectorAll('thead th');
    var idIdx  = findColIndex(ths, 'id');
    var regIdx = findColIndex(ths, function(t){ return t==='regular hrs' || t==='total regular hrs'; });
    var otIdx  = findColIndex(ths, 'ot hrs');
    var totIdx = findColIndex(ths, 'total hours');
    var rows = Array.from(tbl.tBodies[0].rows||[]);
    var reg=0, ot=0, tot=0;
    var seen = new Set();
    for (var r=0; r<rows.length; r++){
      var tr = rows[r];
      var style = window.getComputedStyle(tr);
      if (tr.offsetParent===null || style.display==='none' || style.visibility==='hidden') continue;
      if (regIdx>=0) reg += num(tr.cells[regIdx] && tr.cells[regIdx].textContent);
      if (otIdx>=0)  ot  += num(tr.cells[otIdx] && tr.cells[otIdx].textContent);
      if (totIdx>=0) tot += num(tr.cells[totIdx] && tr.cells[totIdx].textContent);
      if (idIdx>=0){
        var idtxt = String(tr.cells[idIdx] && tr.cells[idIdx].textContent || '').trim();
        if (idtxt) seen.add(idtxt);
      }
    }
    if (totIdx<0) tot = reg + ot;
    return { reg: reg, ot: ot, tot: tot, emp: seen.size, regIdx, otIdx, totIdx, idIdx, ths: ths };
  }
  function rebuildDtrFooter(){
    var tbl = document.getElementById('resultsTable');
    if (!tbl) return;
    var res = computeVisibleTotals();
    if (!res) return;
    var foot = tbl.querySelector('tfoot#resultsFoot');
    if (!foot){
      foot = document.createElement('tfoot');
      foot.id = 'resultsFoot';
      tbl.appendChild(foot);
    }
    var cols = res.ths.length;
    var tr = document.createElement('tr');
    tr.className = 'totals-row';
    for (var i=0;i<cols;i++){
      var td = document.createElement('td');
      td.style.fontWeight = '700';
      td.style.background = '#fafafa';
      var t = norm(res.ths[i].textContent);
      if (i===0) { td.textContent = 'Totals:'; td.style.textAlign='left'; }
      else if (t==='name') { td.textContent = 'Employees: ' + res.emp; }
      else if (i===res.regIdx) { td.textContent = formatHours(res.reg); td.style.textAlign='right'; }
      else if (i===res.otIdx)  { td.textContent = formatHours(res.ot);  td.style.textAlign='right'; }
      else if (i===res.totIdx) { td.textContent = formatHours(res.tot || (res.reg+res.ot)); td.style.textAlign='right'; }
      else if (t==='split' || t==='actions') { td.style.display='none'; td.style.border='0'; }
      else { td.textContent = ''; }
      tr.appendChild(td);
    }
    foot.innerHTML = '';
    foot.appendChild(tr);
    var summaryEl = document.getElementById('dtrSummary');
    if (summaryEl){
      var grand = res.tot || (res.reg + res.ot);
      summaryEl.textContent = 'Grand Total Hours: ' + formatHours(grand) +
        ' | Regular Hours: ' + formatHours(res.reg) +
        ' | OT Hours: ' + formatHours(res.ot) +
        ' | Employees: ' + res.emp;
      summaryEl.style.display = '';
    }
  }
  window.computeVisibleTotals = computeVisibleTotals;
  window.rebuildDtrFooter = rebuildDtrFooter;
  function hook(){
    rebuildDtrFooter();
    var tbl = document.getElementById('resultsTable');
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return;
    var tbody = tbl.tBodies[0];
    var run = function(){ try{ rebuildDtrFooter(); }catch(e){} };
    ['input','change','keyup'].forEach(function(evt){ tbody.addEventListener(evt, run, true); });
    var obs = new MutationObserver(function(){ run(); });
    obs.observe(tbody, { childList:true, subtree:true, characterData:true });
    window.__dtrFooterObserver = obs;
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', hook);
  else hook();
  if (typeof window.renderResults === 'function'){
    var _origRR = window.renderResults;
    window.renderResults = function(){ var r = _origRR.apply(this, arguments); try{ rebuildDtrFooter(); }catch(e){} return r; };
  }
  if (typeof window.calculateAll === 'function'){
    var _origCA = window.calculateAll;
    window.calculateAll = function(){ var r = _origCA.apply(this, arguments); try{ rebuildDtrFooter(); }catch(e){} return r; };
  }
})();
</script>
</body>
<script>
// === CalculateAll Scheduler: coalesce multiple calls per frame ===
(function(){
  try {
    if (window.calculateAll && !window.calculateAll.__scheduledWrapped) {
      const orig = window.calculateAll;
      let scheduled = false;
      function run(){
        scheduled = false;
        try { orig(); } catch(e) { console.warn('calculateAll error', e); }
      }
      const wrap = function(){
        if (scheduled) return;
        scheduled = true;
        (window.requestAnimationFrame || setTimeout)(run, 0);
      };
      wrap.__scheduledWrapped = true;
      window.calculateAll = wrap;
    }
  } catch(e) { /* no-op */ }
})();

// === Deductions render: skip work when hidden; build via fragment ===
(function(){
  function isDeductionsVisible(){
    const el = document.getElementById('deductionsTab');
    return !!(el && el.classList && el.classList.contains('active'));
  }
  try {
    const orig = window.renderDeductionsTable;
    if (typeof orig === 'function' && !orig.__perfWrapped) {
      const optimized = function(){
        if (!isDeductionsVisible()) { window.__deductionsDirty = true; return; }
        window.__deductionsDirty = false;
        try {
          const dtbody = document.querySelector('#deductionsTable tbody');
          if (!dtbody) return;
          const frag = document.createDocumentFragment();
          const div = Number(typeof divisor !== 'undefined' ? divisor : (window.divisor || 1)) || 1;
          dtbody.innerHTML = '';
          const _employees = (typeof employeeList !== 'undefined' ? employeeList : (window.employeeList || []));
          const _regHours = (typeof regHours !== 'undefined' ? regHours : (window.regHours || {}));
          const _storedEmployees = (typeof storedEmployees !== 'undefined' ? storedEmployees : (window.storedEmployees || {}));
          const _rates = (typeof payrollRates !== 'undefined' ? payrollRates : (window.payrollRates || {}));
          const _loanSSS = (typeof loanSSS !== 'undefined' ? loanSSS : (window.loanSSS || {}));
          const _loanPI = (typeof loanPI !== 'undefined' ? loanPI : (window.loanPI || {}));
          const _vale = (typeof vale !== 'undefined' ? vale : (window.vale || {}));
          const _valeWed = (typeof valeWed !== 'undefined' ? valeWed : (window.valeWed || {}));
          const _piRateFn = (typeof pagibigRateByMonthly === 'function' ? pagibigRateByMonthly : (window.pagibigRateByMonthly || null));
          const _phRateFn = (typeof philhealthRateByMonthly === 'function' ? philhealthRateByMonthly : (window.philhealthRateByMonthly || null));
          const _sssFn = (typeof sssShareByMonthly === 'function' ? sssShareByMonthly : (window.sssShareByMonthly || null));
          const _piFlat = (typeof pagibigRate !== 'undefined' ? pagibigRate : (window.pagibigRate || 0));
          const _phFlat = (typeof philhealthRate !== 'undefined' ? philhealthRate : (window.philhealthRate || 0));
          _employees.forEach(emp => {
            const id = emp.id;
            const rH = Number(_regHours[id] || 0);
            const stored = _storedEmployees[id];
            const rate = Number((stored && stored.hourlyRate) ?? (_rates[id] ?? 0)) || 0;
            if (_rates) _rates[id] = rate;
            const lSSS = Number(_loanSSS[id] || 0);
            const lPI = Number(_loanPI[id] || 0);
            const v = Number(_vale[id] || 0);
            const vW = Number(_valeWed[id] || 0);
            const regPay = +(rH * rate).toFixed(2);
            const monthly = rate * 8 * 24;
            const piRate = (_piRateFn ? _piRateFn(monthly) : _piFlat);
            const phRate = (_phRateFn ? _phRateFn(monthly) : _phFlat);
            const pagibig = +((regPay * piRate)).toFixed(2);
            const philhealth = +((regPay * phRate)).toFixed(2);
            const sssFull = (_sssFn ? _sssFn(monthly) : 0);
            const sss = +(sssFull / div).toFixed(2);
            const sssLoan = +(lSSS / div).toFixed(2);
            const piLoan = +(lPI / div).toFixed(2);
            const total = +(pagibig + philhealth + sss + sssLoan + piLoan + v + vW).toFixed(2);
            const tr = document.createElement('tr');
            tr.innerHTML = '<td>'+id+'</td><td class="wrap">'+(emp.name||'')+'</td>'+
              '<td class="num">'+pagibig.toFixed(2)+'</td>'+
              '<td class="num">'+philhealth.toFixed(2)+'</td>'+
              '<td class="num">'+sss.toFixed(2)+'</td>'+
              '<td class="num">'+sssLoan.toFixed(2)+'</td>'+
              '<td class="num">'+piLoan.toFixed(2)+'</td>'+
              '<td class="num">'+v.toFixed(2)+'</td>'+
              '<td class="num">'+vW.toFixed(2)+'</td>'+
              '<td class="num">'+total.toFixed(2)+'</td>';
            frag.appendChild(tr);
          });
          dtbody.appendChild(frag);
        } catch(e) { try { return orig(); } catch(_){} }
        try { (window.scheduleTotals||window.updateDeductionsGrandTotals||function(){})(); } catch(e){}
      };
      optimized.__perfWrapped = true;
      window.renderDeductionsTable = optimized;
    }
  } catch(e) { /* no-op */ }
  // Render pending deductions when its tab becomes active
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest && ev.target.closest('#panelPayroll .tabs .tab-btn');
    if (btn && btn.dataset && btn.dataset.tab === 'deductionsTab'){
      if (window.__deductionsDirty && typeof window.renderDeductionsTable === 'function'){
        try { window.renderDeductionsTable(); } catch(e){}
      }
    }
  }, true);
})();
</script>
<script>
// === RenderResults Scheduler: coalesce rapid calls into one per frame ===
(function(){
  try {
    if (window.renderResults && !window.renderResults.__scheduledWrapped) {
      const orig = window.renderResults;
      let scheduled = false;
      function run(){
        scheduled = false;
        try { orig(); } catch(e) { console.warn('renderResults error', e); }
      }
      const wrap = function(){
        if (scheduled) return;
        scheduled = true;
        (window.requestAnimationFrame || setTimeout)(run, 0);
      };
      wrap.__scheduledWrapped = true;
      window.renderResults = wrap;
    }
  } catch(e) { /* no-op */ }
})();
</script>
<script>
// Minimal Lock Snapshots: capture DTR/Payroll/Reports and render from snapshots when locked.
(function(){
  function getPeriod(){
    const ws = document.getElementById('weekStart');
    const we = document.getElementById('weekEnd');
    const start = ws && ws.value ? ws.value : '';
    const end   = we && we.value ? we.value : '';
    return { start, end };
  }
  function pidFromDates(start, end){
    const norm = (s)=>{ if(!s) return ''; const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/); if(m) return m[1]+m[2]+m[3]; const d=new Date(s); if(!isNaN(d)) return ''+d.getFullYear()+String(d.getMonth()+1).padStart(2,'0')+String(d.getDate()).padStart(2,'0'); return String(s).replace(/[^0-9]/g,''); };
    return `p:${norm(start)}:${norm(end)}`;
  }
  function serializeTableById(id){
    const tbl = document.getElementById(id);
    if (!tbl) return null;
    const headers = [];
    try { tbl.querySelectorAll('thead tr th').forEach(th=> headers.push((th.textContent||'').trim())); } catch {}
    const rows = [];
    const cellsSel = 'td,th';
    tbl.querySelectorAll('tbody tr').forEach(tr=>{
      const arr = [];
      tr.querySelectorAll(cellsSel).forEach(td=>{
        const el = td.querySelector('input,select,textarea');
        if (el) {
          if (el.tagName && el.tagName.toUpperCase()==='SELECT'){
            const opt = el.options && el.selectedIndex>=0 ? el.options[el.selectedIndex] : null;
            arr.push(String((opt && (opt.textContent||opt.label)) || el.value || '').trim());
          } else {
            arr.push(String((typeof el.value!== 'undefined' ? el.value : el.textContent)||'').trim());
          }
        } else arr.push((td.textContent||'').trim());
      });
      rows.push(arr);
    });
    return { headers, rows };
  }
  function renderSimpleTableSnapshot(id, snap){
    if (!snap) return false;
    const tbl = document.getElementById(id);
    if (!tbl) return false;
    const tb = tbl.tBodies && tbl.tBodies[0] || tbl.querySelector('tbody');
    if (tb){ tb.innerHTML = (snap.rows||[]).map(r=>'<tr>'+r.map(c=>`<td>${String(c==null?'':c)}</td>`).join('')+'</tr>').join(''); return true; }
    return false;
  }
  function isLocked(){
    try { if (typeof isSelectedPeriodLocked==='function') return !!isSelectedPeriodLocked(); } catch{}
    try {
      const hist = Array.isArray(window.payrollHistory) ? window.payrollHistory : [];
      const p = getPeriod();
      return hist.some(s=> s && s.locked && s.startDate===p.start && s.endDate===p.end);
    } catch { return false; }
  }
  async function readKVWithLocal(key){
    try { const v = await (window.readKV ? window.readKV(key, null) : Promise.resolve(null)); if (v!=null) return v; } catch{}
    try { const raw = localStorage.getItem(key); if (raw!=null) return JSON.parse(raw); } catch{}
    return null;
  }
  async function writeKVMirror(key, value){
    try { if (window.writeKV) await window.writeKV(key, value); } catch{}
    try { localStorage.setItem(key, JSON.stringify(value)); } catch{}
  }
  async function renderFromSnapshots(){
    const p = getPeriod();
    const pid = pidFromDates(p.start, p.end);
    const [dtr, payroll, reports] = await Promise.all([
      readKVWithLocal(`snap:dtr:${pid}`),
      readKVWithLocal(`snap:payroll:${pid}`),
      readKVWithLocal(`snap:reports:${pid}`)
    ]);
    if (dtr) renderSimpleTableSnapshot('resultsTable', dtr);
    if (reports){ if (!renderSimpleTableSnapshot('projectTotalsTable', reports)) renderSimpleTableSnapshot('r_table', reports); }
    if (payroll){
      try {
        const tb = document.querySelector('#payrollTable tbody');
        const fmt = (n)=> Number(n||0).toFixed(2);
        tb.innerHTML = (payroll.rows||[]).map(r=>{
          return '<tr>' +
            `<td>${r.id||''}</td><td class="wrap">${r.name||''}</td>`+
            `<td class="rate num">${fmt(r.rate)}</td>`+
            `<td class="regHrs num">${fmt(r.regHrs)}</td>`+
            `<td class="otHrs num">${fmt(r.otHrs)}</td>`+
            `<td class="adjHrs num">${fmt(r.adjHrs)}</td>`+
            `<td class="totalHrs num">${fmt(r.totalHrs)}</td>`+
            `<td class="regPay num">${fmt(r.regPay)}</td>`+
            `<td class="otPay num">${fmt(r.otPay)}</td>`+
            `<td class="adjAmt num">${fmt(r.adjAmt)}</td>`+
            `<td class="bantay num">${fmt(r.bantay)}</td>`+
            `<td class="grossPay num">${fmt(r.grossPay)}</td>`+
            `<td class="pagibig num">${fmt(r.pagibig)}</td>`+
            `<td class="philhealth num">${fmt(r.philhealth)}</td>`+
            `<td class="sss num">${fmt(r.sss)}</td>`+
            `<td class="loanSSS num">${fmt(r.loanSSS)}</td>`+
            `<td class="loanPI num">${fmt(r.loanPI)}</td>`+
            `<td class="vale num">${fmt(r.vale)}</td>`+
            `<td class="valeWed num">${fmt(r.valeWed)}</td>`+
            `<td class="totalDed num">${fmt(r.totalDed)}</td>`+
            `<td class="netPay num">${fmt(r.netPay)}</td>`+
            `<td></td>`+
          '</tr>';
        }).join('');
        const totals = payroll.totals || {};
        document.querySelectorAll('#payrollTable tfoot [data-col]').forEach(td=>{ const k=td.dataset.col; td.textContent = Number(totals[k]||0).toFixed(2); });
      } catch{}
    }
    try { setPayrollLockedUI(true); } catch{}
  }
  async function lockPeriod(){
    const p = getPeriod(); if (!p.start || !p.end) { alert('Select a period first.'); return; }
    try { if (typeof window.renderResults==='function') window.renderResults(); } catch{}
    try { if (typeof window.rebuildReports==='function') window.rebuildReports(); else if (typeof window.renderProjectTotals==='function') window.renderProjectTotals(); } catch{}
    const pid = pidFromDates(p.start, p.end);
    const dtr = serializeTableById('resultsTable') || { headers:[], rows:[] };
    const reports = serializeTableById('projectTotalsTable') || serializeTableById('r_table') || { headers:[], rows:[] };
    const payroll = (typeof window.buildSnapshot==='function') ? await window.buildSnapshot(p.start, p.end) : null;
    await writeKVMirror(`snap:dtr:${pid}`, dtr);
    await writeKVMirror(`snap:payroll:${pid}`, payroll);
    await writeKVMirror(`snap:reports:${pid}`, reports);
    await renderFromSnapshots();
    try { setPayrollLockedUI(true); } catch{}
  }
  async function unlockPeriod(){ /* no-op for snapshots; UI will recompute naturally */ try { setPayrollLockedUI(false); } catch{} }

  function guard(name){
    try {
      const fn = window[name]; if (typeof fn !== 'function' || fn.__guarded) return;
      const wrapped = function(){ if (isLocked()){ renderFromSnapshots(); return; } return fn.apply(this, arguments); };
      wrapped.__guarded = true; window[name] = wrapped;
    } catch{}
  }
  ['renderResults','calculatePayrollFromResultsTable','calculatePayrollFromRecords','rebuildReports','renderProjectTotals','calculateAll','renderTable'].forEach(guard);

  document.addEventListener('DOMContentLoaded', function(){
    // Delegate to existing dashboard lock/unlock buttons if present
    document.addEventListener('click', function(ev){
      const t = ev.target;
      if (!t) return;
      if (t.closest && t.closest('#activePayrollTable') && t.classList && t.classList.contains('lockActive')){ setTimeout(lockPeriod, 0); }
      if (t.classList && t.classList.contains('unlockSnapshot')){ setTimeout(unlockPeriod, 0); setTimeout(function(){ if (!isLocked()) renderFromSnapshots(); }, 100); }
    }, true);
    // On load, if selected period is locked, render snapshots immediately
    try { if (isLocked()) { renderFromSnapshots(); setPayrollLockedUI(true);} else { setPayrollLockedUI(false);} } catch{}

    // Ensure Payroll tab restores snapshot on activation when locked
    try {
      var tp = document.getElementById('tabPayroll');
      var tp2 = document.getElementById('old-tabPayroll');
      function onOpenPayroll(){ try { if (isLocked()) { renderFromSnapshots(); setPayrollLockedUI(true); } } catch(e){} }
      if (tp && !tp.__lockBind){ tp.addEventListener('click', onOpenPayroll); tp.__lockBind = true; }
      if (tp2 && !tp2.__lockBind){ tp2.addEventListener('click', onOpenPayroll); tp2.__lockBind = true; }
    } catch(e){}

    // Period change stabilization to avoid flashing stale locked snapshots
    var __lockStableAt = 0;
    function markPeriodChanged(){ try { __lockStableAt = Date.now() + 250; } catch(e){} }
    function isStable(){ try { return Date.now() >= __lockStableAt; } catch(e){ return true; } }
    // Wrap isLocked to respect stabilization window
    try {
      var _isLocked = isLocked;
      isLocked = function(){ if (!isStable()) return false; return _isLocked(); };
    } catch(e){}
    function scheduleUiReeval(){ setTimeout(function(){ try { setPayrollLockedUI(isLocked()); if (isLocked()) renderFromSnapshots(); } catch(e){} }, 260); }
    try { var ws = document.getElementById('weekStart'); if (ws && !ws.__lockBind){ ws.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); ws.__lockBind = true; } } catch(e){}
    try { var we = document.getElementById('weekEnd'); if (we && !we.__lockBind){ we.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); we.__lockBind = true; } } catch(e){}
    try { var sel = document.getElementById('activePayrollSelect'); if (sel && !sel.__lockBind){ sel.addEventListener('change', function(){ markPeriodChanged(); scheduleUiReeval(); }); sel.__lockBind = true; } } catch(e){}
  });

  try { window.lockPeriod = lockPeriod; window.unlockPeriod = unlockPeriod; } catch{}
})();

// Toggle Payroll table inputs read-only state based on lock
function setPayrollLockedUI(locked){
  try {
    // 1) Toggle form controls (inputs only) inside Payroll panel; leave tab buttons enabled
    var panel = document.getElementById('panelPayroll');
    if (panel){
      var inputs = panel.querySelectorAll('input, select, textarea');
      inputs.forEach(function(el){ el.disabled = !!locked; });
      // Explicitly disable file-import fields when locked
      if (locked){
        panel.querySelectorAll('#importSss, #deductionsFileInput').forEach(function(el){ el.disabled = true; });
      }
    }
    // 2) Also toggle just the payroll grid controls for safety
    document.querySelectorAll('#payrollTable input, #payrollTable select, #payrollTable textarea').forEach(function(el){ el.disabled = !!locked; });
    // 3) Re-assert on DOM mutations while locked (payroll table only)
    var tbl = document.getElementById('payrollTable');
    if (tbl){
      if (locked && !tbl.__lockObs){
        var mo = new MutationObserver(function(){ try { document.querySelectorAll('#payrollTable input, #payrollTable select, #payrollTable textarea').forEach(function(el){ el.disabled = true; }); } catch(e){} });
        mo.observe(tbl, { childList: true, subtree: true });
        tbl.__lockObs = mo;
      } else if (!locked && tbl.__lockObs){ try { tbl.__lockObs.disconnect(); } catch(e){}; tbl.__lockObs = null; }
    }
  } catch(e){}
}
</script>
<script>
// Normalize Deductions note: rename Column 8 label from Vale to Account in the help text.
document.addEventListener('DOMContentLoaded', function(){
  try{
    var note = document.querySelector('#deductionsTab .section.note');
    if (note && note.innerHTML && /Column\s*8:<\/strong>\s*Vale/i.test(note.innerHTML)){
      note.innerHTML = note.innerHTML.replace(/(Column\s*8:<\/strong>)\s*Vale/i, '$1 Account');
    }
  }catch(e){}
});
</script>
</html>
